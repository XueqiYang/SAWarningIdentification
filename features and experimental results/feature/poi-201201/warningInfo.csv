MT_CORRECTNESS,LI_LAZY_INIT_STATIC,org/apache/poi/POIDataSamples.java,getDDFInstance,89-89,[        if(_instDDF == null) _instDDF = new POIDataSamples("ddf");],,
MT_CORRECTNESS,LI_LAZY_INIT_STATIC,org/apache/poi/POIDataSamples.java,getDiagramInstance,74-74,[        if(_instOpenxml4j == null) _instOpenxml4j = new POIDataSamples("diagram");],,
MT_CORRECTNESS,LI_LAZY_INIT_STATIC,org/apache/poi/POIDataSamples.java,getDocumentInstance,64-64,[        if(_instDocument == null) _instDocument = new POIDataSamples("document");],,
MT_CORRECTNESS,LI_LAZY_INIT_STATIC,org/apache/poi/POIDataSamples.java,getHMEFInstance,104-104,[        if(_instHMEF == null) _instHMEF = new POIDataSamples("hmef");],,
MT_CORRECTNESS,LI_LAZY_INIT_STATIC,org/apache/poi/POIDataSamples.java,getHPSFInstance,94-94,[        if(_instHPSF == null) _instHPSF = new POIDataSamples("hpsf");],,
MT_CORRECTNESS,LI_LAZY_INIT_STATIC,org/apache/poi/POIDataSamples.java,getHSMFInstance,109-109,[        if(_instHSMF == null) _instHSMF = new POIDataSamples("hsmf");],,
MT_CORRECTNESS,LI_LAZY_INIT_STATIC,org/apache/poi/POIDataSamples.java,getOpenXML4JInstance,79-79,[        if(_instDiagram == null) _instDiagram = new POIDataSamples("openxml4j");],,
MT_CORRECTNESS,LI_LAZY_INIT_STATIC,org/apache/poi/POIDataSamples.java,getPOIFSInstance,84-84,[        if(_instPOIFS == null) _instPOIFS = new POIDataSamples("poifs");],,
MT_CORRECTNESS,LI_LAZY_INIT_STATIC,org/apache/poi/POIDataSamples.java,getPublisherInstance,99-99,[        if(_instHPBF == null) _instHPBF = new POIDataSamples("publisher");],,
MT_CORRECTNESS,LI_LAZY_INIT_STATIC,org/apache/poi/POIDataSamples.java,getSlideShowInstance,69-69,[        if(_instSlideshow == null) _instSlideshow = new POIDataSamples("slideshow");],,
MT_CORRECTNESS,LI_LAZY_INIT_STATIC,org/apache/poi/POIDataSamples.java,getSpreadSheetInstance,59-59,[        if(_instSpreadsheet == null) _instSpreadsheet = new POIDataSamples("spreadsheet");],,
BAD_PRACTICE,NP_TOSTRING_COULD_RETURN_NULL,org/apache/poi/POIXMLDocumentPart.java,toString,281-281,[        return packagePart == null ? null : packagePart.toString();],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/poi/POIXMLProperties.java,,170-269,[	public class CoreProperties {, 		private PackagePropertiesPart part;, 		private CoreProperties(PackagePropertiesPart part) {, 			this.part = part;, 		}, , 		public String getCategory() {, 			return part.getCategoryProperty().getValue();, 		}, 		public void setCategory(String category) {, 			part.setCategoryProperty(category);, 		}, 		public String getContentStatus() {, 			return part.getContentStatusProperty().getValue();, 		}, 		public void setContentStatus(String contentStatus) {, 			part.setContentStatusProperty(contentStatus);, 		}, 		public String getContentType() {, 			return part.getContentTypeProperty().getValue();, 		}, 		public void setContentType(String contentType) {, 			part.setContentTypeProperty(contentType);, 		}, 		public Date getCreated() {, 			return part.getCreatedProperty().getValue();, 		}, 		public void setCreated(Nullable<Date> date) {, 			part.setCreatedProperty(date);, 		}, 		public void setCreated(String date) {, 			part.setCreatedProperty(date);, 		}, 		public String getCreator() {, 			return part.getCreatorProperty().getValue();, 		}, 		public void setCreator(String creator) {, 			part.setCreatorProperty(creator);, 		}, 		public String getDescription() {, 			return part.getDescriptionProperty().getValue();, 		}, 		public void setDescription(String description) {, 			part.setDescriptionProperty(description);, 		}, 		public String getIdentifier() {, 			return part.getIdentifierProperty().getValue();, 		}, 		public void setIdentifier(String identifier) {, 			part.setIdentifierProperty(identifier);, 		}, 		public String getKeywords() {, 			return part.getKeywordsProperty().getValue();, 		}, 		public void setKeywords(String keywords) {, 			part.setKeywordsProperty(keywords);, 		}, 		public Date getLastPrinted() {, 			return part.getLastPrintedProperty().getValue();, 		}, 		public void setLastPrinted(Nullable<Date> date) {, 			part.setLastPrintedProperty(date);, 		}, 		public void setLastPrinted(String date) {, 			part.setLastPrintedProperty(date);, 		}, 		public Date getModified() {, 			return part.getModifiedProperty().getValue();, 		}, 		public void setModified(Nullable<Date> date) {, 			part.setModifiedProperty(date);, 		}, 		public void setModified(String date) {, 			part.setModifiedProperty(date);, 		}, 		public String getSubject() {, 			return part.getSubjectProperty().getValue();, 		}, 		public void setSubjectProperty(String subject) {, 			part.setSubjectProperty(subject);, 		}, 		public void setTitle(String title) {, 			part.setTitleProperty(title);, 		}, 		public String getTitle() {, 			return part.getTitleProperty().getValue();, 		}, 		public String getRevision() {, 			return part.getRevisionProperty().getValue();, 		}, 		public void setRevision(String revision) {, 			try {, 				Long.valueOf(revision);, 				part.setRevisionProperty(revision);, 			}, 			catch (NumberFormatException e) {}, 		}, , 		public PackagePropertiesPart getUnderlyingProperties() {, 			return part;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/poi/POIXMLProperties.java,,290-389,[	public class CustomProperties {, 		/**, 		 *  Each custom property element contains an fmtid attribute, 		 *  with the same GUID value ({D5CDD505-2E9C-101B-9397-08002B2CF9AE})., 		 */, 		public static final String FORMAT_ID = "{D5CDD505-2E9C-101B-9397-08002B2CF9AE}";, , 		private org.openxmlformats.schemas.officeDocument.x2006.customProperties.PropertiesDocument props;, 		private CustomProperties(org.openxmlformats.schemas.officeDocument.x2006.customProperties.PropertiesDocument props) {, 			this.props = props;, 		}, , 		public org.openxmlformats.schemas.officeDocument.x2006.customProperties.CTProperties getUnderlyingProperties() {, 			return props.getProperties();, 		}, , 		/**, 		 * Add a new property, 		 *, 		 * @param name the property name, 		 * @throws IllegalArgumentException if a property with this name already exists, 		 */, 		private CTProperty add(String name) {, 			if(contains(name)) {, 				throw new IllegalArgumentException("A property with this name " +, 						"already exists in the custom properties");, 			}, , 			CTProperty p = props.getProperties().addNewProperty();, 			int pid = nextPid();, 			p.setPid(pid);, 			p.setFmtid(FORMAT_ID);, 			p.setName(name);, 			return p;, 		}, , 		/**, 		 * Add a new string property, 		 *, 		 * @throws IllegalArgumentException if a property with this name already exists, 		 */, 		 public void addProperty(String name, String value){, 			CTProperty p = add(name);, 			p.setLpwstr(value);, 		}, , 		/**, 		 * Add a new double property, 		 *, 		 * @throws IllegalArgumentException if a property with this name already exists, 		 */, 		public void addProperty(String name, double value){, 			CTProperty p = add(name);, 			p.setR8(value);, 		}, , 		/**, 		 * Add a new integer property, 		 *, 		 * @throws IllegalArgumentException if a property with this name already exists, 		 */, 		public void addProperty(String name, int value){, 			CTProperty p = add(name);, 			p.setI4(value);, 		}, , 		/**, 		 * Add a new boolean property, 		 *, 		 * @throws IllegalArgumentException if a property with this name already exists, 		 */, 		public void addProperty(String name, boolean value){, 			CTProperty p = add(name);, 			p.setBool(value);, 		}, , 		/**, 		 * Generate next id that uniquely relates a custom property, 		 *, 		 * @return next property id starting with 2, 		 */, 		protected int nextPid(){, 			int propid = 1;, 			for(CTProperty p : props.getProperties().getPropertyList()){, 				if(p.getPid() > propid) propid = p.getPid();, 			}, 			return propid + 1;, 		}, , 		/**, 		 * Check if a property with this name already exists in the collection of custom properties, 		 *, 		 * @param name the name to check, 		 * @return whether a property with the given name exists in the custom properties, 		 */, 		public boolean contains(String name){, 			for(CTProperty p : props.getProperties().getPropertyList()){, 				if(p.getName().equals(name)) return true;, 			}, 			return false;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/poi/POIXMLProperties.java,,276-283,[	public class ExtendedProperties {, 		private org.openxmlformats.schemas.officeDocument.x2006.extendedProperties.PropertiesDocument props;, 		private ExtendedProperties(org.openxmlformats.schemas.officeDocument.x2006.extendedProperties.PropertiesDocument props) {, 			this.props = props;, 		}, , 		public org.openxmlformats.schemas.officeDocument.x2006.extendedProperties.CTProperties getUnderlyingProperties() {, 			return props.getProperties();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/poi/TestPOIDocumentScratchpad.java,testReadProperties,57-57,[		assertNotNull(doc.getDocumentSummaryInformation());],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/poi/TestPOIDocumentScratchpad.java,testWriteProperties,78-78,[		doc.writeProperties(outFS);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/poi/TestPOIDocumentScratchpad.java,testWriteReadProperties,90-90,[    	doc.writeProperties(outFS);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/poi/TestPOIDocumentScratchpad.java,testReadProperties2,67-67,[		assertNotNull(doc2.getDocumentSummaryInformation());],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/poi/TestPOIXMLDocument.java,assertReadWrite,96-96,[        FileOutputStream out = new FileOutputStream(tmp);],,assertReadWrite,97-97,[        doc.write(out);],,
STYLE,DLS_DEAD_LOCAL_STORE_OF_NULL,org/apache/poi/TestPOIXMLProperties.java,testWorkbookExtendedProperties,68-68,[		ctProps = null;],,
STYLE,DLS_DEAD_LOCAL_STORE_OF_NULL,org/apache/poi/TestPOIXMLProperties.java,testWorkbookExtendedProperties,69-69,[		properties = null;],,
STYLE,DLS_DEAD_LOCAL_STORE_OF_NULL,org/apache/poi/TestPOIXMLProperties.java,testWorkbookExtendedProperties,70-70,[		props = null;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/poi/ddf/AbstractEscherOptRecord.java,,132-137,[        {,             public int compare( EscherProperty p1, EscherProperty p2 ),             {,                 short s1 = p1.getPropertyNumber();,                 short s2 = p2.getPropertyNumber();,                 return s1 < s2 ? -1 : s1 == s2 ? 0 : 1;],,
STYLE,REC_CATCH_EXCEPTION,org/apache/poi/ddf/DefaultEscherRecordFactory.java,createRecord,105-105,[        } catch (Exception e) {],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/poi/ddf/EscherComplexProperty.java,equals,97-108,[        if (this == o) {,             return true;,         },         if (!(o instanceof EscherComplexProperty)) {,             return false;,         }, ,         EscherComplexProperty escherComplexProperty = (EscherComplexProperty) o;, ,         if ( !Arrays.equals( _complexData, escherComplexProperty._complexData ) ) return false;, ,         return true;],,
STYLE,RV_RETURN_VALUE_IGNORED_NO_SIDE_EFFECT,org/apache/poi/ddf/EscherArrayProperty.java,setArrayData,153-153,[            LittleEndian.getShort(data, offset + 2); // numReserved],,
BAD_PRACTICE,NM_CONFUSING,org/apache/poi/ddf/EscherBSERecord.java,getUid,180-180,[        return field_3_uid;],,getUID,76-76,[        return field_1_UID;],,
BAD_PRACTICE,NM_CONFUSING,org/apache/poi/ddf/EscherBSERecord.java,setUid,187-188,[        field_3_uid = uid;,     }],,setUID,81-82,[        this.field_1_UID = field_1_UID;,     }],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/poi/ddf/EscherBSERecord.java,serialize,120-120,[        if (_remainingData == null)],,
I18N,DM_DEFAULT_ENCODING,org/apache/poi/ddf/EscherBitmapBlip.java,toString,103-103,[            extraData = b.toString();],,
BAD_PRACTICE,NM_CONFUSING,org/apache/poi/ddf/EscherBlipRecord.java,getPicturedata,69-69,[        return field_pictureData;],,getPictureData,177-196,[                EscherContainerRecord shapeDescription = getEscherShapeRecordContainer( getShapeId() );,                 if ( shapeDescription == null ),                     return null;, ,                 EscherOptRecord escherOptRecord = shapeDescription,                         .getChildById( EscherOptRecord.RECORD_ID );,                 if ( escherOptRecord == null ),                     return null;, ,                 EscherSimpleProperty escherProperty = escherOptRecord,                         .lookup( EscherProperties.BLIP__BLIPTODISPLAY );,                 if ( escherProperty == null ),                     return null;, ,                 int bitmapIndex = escherProperty.getPropertyValue();,                 EscherBlipRecord escherBlipRecord = getBitmapRecord( bitmapIndex );,                 if ( escherBlipRecord == null ),                     return null;, ,                 return escherBlipRecord.getPicturedata();],,
I18N,DM_DEFAULT_ENCODING,org/apache/poi/ddf/EscherBlipWMFRecord.java,toString,329-329,[            extraData = b.toString();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/poi/ddf/EscherBlipWMFRecord.java,getRecordSize,116-116,[        return 58 + field_12_data.length;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/poi/ddf/EscherBlipWMFRecord.java,serialize,93-93,[        int remainingBytes = field_12_data.length + 36;],,
I18N,DM_DEFAULT_ENCODING,org/apache/poi/ddf/EscherClientAnchorRecord.java,toString,140-140,[            extraData = b.toString();],,
STYLE,REC_CATCH_EXCEPTION,org/apache/poi/ddf/EscherClientAnchorRecord.java,toString,142-142,[        catch ( Exception e )],,
I18N,DM_DEFAULT_ENCODING,org/apache/poi/ddf/EscherClientDataRecord.java,toString,87-87,[            extraData = b.toString();],,
STYLE,REC_CATCH_EXCEPTION,org/apache/poi/ddf/EscherClientDataRecord.java,toString,89-89,[        catch ( Exception e )],,
STYLE,RV_RETURN_VALUE_IGNORED_NO_SIDE_EFFECT,org/apache/poi/ddf/EscherDggRecord.java,fillFields,72-72,[        LittleEndian.getInt( data, pos + size );size+=4; // field_2_numIdClusters],,
STYLE,INT_VACUOUS_BIT_OPERATION,org/apache/poi/ddf/EscherDump.java,dec1616,747-747,[        result += (short) ( n32 & (short) 0xFFFF );],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/poi/ddf/EscherDump.java,,437-440,[            public PropName(int id, String name) {,                 _id = id;,                 _name = name;,             }],,
STYLE,REC_CATCH_EXCEPTION,org/apache/poi/ddf/EscherTextboxRecord.java,toString,128-128,[        catch ( Exception e )],,
CORRECTNESS,EC_BAD_ARRAY_COMPARE,org/apache/poi/ddf/TestEscherBlipRecord.java,testReadPICT,128-128,[        assertEquals(blip1.getPrimaryUID(), blip2.getPrimaryUID());],,
CORRECTNESS,EC_BAD_ARRAY_COMPARE,org/apache/poi/ddf/TestEscherBlipRecord.java,testReadPICT,127-127,[        assertEquals(blip1.getUID(), blip2.getUID());],,
CORRECTNESS,EC_BAD_ARRAY_COMPARE,org/apache/poi/ddf/TestEscherBlipRecord.java,testReadPNG,76-76,[        assertEquals(blip1.getUID(), blip2.getUID());],,
BAD_PRACTICE,RR_NOT_CHECKED,org/apache/poi/ddf/TestEscherBlipRecord.java,read,148-148,[            is.read(data);],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/poi/ddf/TestEscherBlipRecord.java,read,145-153,[        byte[] data = new byte[(int)file.length()];,         try {,             FileInputStream is = new FileInputStream(file);,             is.read(data);,             is.close();,         } catch (IOException e) {,             throw new RuntimeException(e);,         },         return data;],,
I18N,DM_CONVERT_CASE,org/apache/poi/dev/RecordGenerator.java,generateRecords,95-95,[                transform(file, new File(destinationFilepath), new File(recordStyleDir + "/" + extendstg.toLowerCase() + ".xsl"));],,generateRecords,104-104,[                    String temp = (recordStyleDir + "/" + extendstg.toLowerCase() + "_test.xsl");],,
I18N,DM_DEFAULT_ENCODING,org/apache/poi/dev/RecordGenerator.java,transform,129-129,[        final Reader r = new FileReader(xslt);],,
STYLE,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,org/apache/poi/dev/RecordGenerator.java,generateRecords,71-71,[        for (int i = 0; i < definitionsFile.listFiles().length; i++) {],,
STYLE,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,org/apache/poi/dev/RecordGenerator.java,generateRecords,72-72,[            File file = definitionsFile.listFiles()[i];],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/poi/dev/RecordGenerator.java,generateRecords,93-93,[                destinationPathFile.mkdirs();],,generateRecords,101-101,[                destinationPathFile.mkdirs();],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/poi/extractor/CommandLineTextExtractor.java,,28-28,[   public static String DIVIDER = "=======================";],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/poi/extractor/ExtractorFactory.java,getEmbededDocsTextExtractors,321-321,[		if(],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/poi/extractor/ExtractorFactory.java,getEmbededDocsTextExtractors,322-322,[		      (dirs == null || dirs.size() == 0) &&],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/poi/extractor/TestExtractorFactory.java,testPackage,429-429,[				ExtractorFactory.createExtractor(OPCPackage.open(docx.toString()))],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/poi/extractor/TestExtractorFactory.java,testPackage,438-438,[				ExtractorFactory.createExtractor(OPCPackage.open(pptx.toString()))],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/poi/extractor/TestExtractorFactory.java,testPackage,447-447,[			ExtractorFactory.createExtractor(OPCPackage.open(txt.toString()));],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/poi/extractor/TestExtractorFactory.java,testPackage,420-420,[				ExtractorFactory.createExtractor(OPCPackage.open(xlsx.toString()))],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/poi/extractor/TestExtractorFactory.java,testPreferEventBased,488-488,[            ExtractorFactory.createExtractor(OPCPackage.open(xlsx.toString()))],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/poi/hdf/event/EventBridge.java,createSectionHdrFtr,403-421,[    switch(type),     {,       case HeaderFooter.HEADER_EVEN:,            arrayIndex = (HEADER_EVEN_INDEX + (index * 6));,            break;,       case HeaderFooter.FOOTER_EVEN:,            arrayIndex = (FOOTER_EVEN_INDEX + (index * 6));,            break;,       case HeaderFooter.HEADER_ODD:,            arrayIndex = (HEADER_ODD_INDEX + (index * 6));,            break;,       case HeaderFooter.FOOTER_ODD:,            arrayIndex = (FOOTER_ODD_INDEX + (index * 6));,            break;,       case HeaderFooter.HEADER_FIRST:,            arrayIndex = (HEADER_FIRST_INDEX + (index * 6));,            break;,       case HeaderFooter.FOOTER_FIRST:,            arrayIndex = (FOOTER_FIRST_INDEX + (index * 6));],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/poi/hdf/event/EventBridge.java,getBulletText,368-374,[    switch (lvl._ixchFollow),     {,       case 0:,         bulletBuffer.append('\u0009');,         break;,       case 1:,         bulletBuffer.append(' ');],,
BAD_PRACTICE,DE_MIGHT_IGNORE,org/apache/poi/hdf/extractor/NewOleFile.java,main,110-110,[      catch(Exception e)],,
BAD_PRACTICE,RR_NOT_CHECKED,org/apache/poi/hdf/extractor/NewOleFile.java,initializePropertySets,146-146,[                read(propArray);],,
BAD_PRACTICE,RR_NOT_CHECKED,org/apache/poi/hdf/extractor/NewOleFile.java,readIntLE,235-235,[        read(intBytes);],,
STYLE,IM_BAD_CHECK_FOR_ODD,org/apache/poi/hdf/extractor/StyleDescription.java,<init>,94-94,[          if(upxSize % 2 == 1)],,
BAD_PRACTICE,NM_CONFUSING,org/apache/poi/hdf/extractor/StyleDescription.java,getCHPX,110-110,[      return _chpx;],,getChpx,37-37,[    return super.getGrpprl();],,
BAD_PRACTICE,NM_CONFUSING,org/apache/poi/hdf/extractor/StyleDescription.java,getPAPX,114-114,[      return _papx;],,getPapx,36-36,[    return super.getGrpprl();],,
BAD_PRACTICE,BIT_SIGNED_CHECK,org/apache/poi/hdf/extractor/StyleSheet.java,doCHPOperation,325-325,[               boolean fAdjust = (param & 0x0100) > 0;],,
BAD_PRACTICE,BIT_SIGNED_CHECK,org/apache/poi/hdf/extractor/StyleSheet.java,doTAPOperation,1033-1033,[                 if((varParam[2] & 0x08) > 0)],,
BAD_PRACTICE,BIT_SIGNED_CHECK,org/apache/poi/hdf/extractor/StyleSheet.java,doTAPOperation,1038-1038,[                 else if((varParam[2] & 0x04) > 0)],,
BAD_PRACTICE,BIT_SIGNED_CHECK,org/apache/poi/hdf/extractor/StyleSheet.java,doTAPOperation,1043-1043,[                 else if((varParam[2] & 0x02) > 0)],,
BAD_PRACTICE,BIT_SIGNED_CHECK,org/apache/poi/hdf/extractor/StyleSheet.java,doTAPOperation,1048-1048,[                 else if((varParam[2] & 0x01) > 0)],,
STYLE,DB_DUPLICATE_SWITCH_CLAUSES,org/apache/poi/hdf/extractor/StyleSheet.java,doCHPOperation,339-340,[               newCHP._lidDefault = (short)param;,                break;],,doCHPOperation,547-548,[               newCHP._lidDefault = (short)param;,                break;],,
STYLE,DB_DUPLICATE_SWITCH_CLAUSES,org/apache/poi/hdf/extractor/StyleSheet.java,doPAPOperation,832-833,[               newPAP._dxaFromText = param;,                break;],,doPAPOperation,877-878,[               newPAP._dxaFromText = param;,                break;],,
STYLE,DB_DUPLICATE_SWITCH_CLAUSES,org/apache/poi/hdf/extractor/StyleSheet.java,uncompressProperty,629-631,[                   opSize = 2;,                    param = Utils.convertBytesToShort(grpprl, offset);,                    break;],,uncompressProperty,638-640,[                   opSize = 2;,                    param = Utils.convertBytesToShort(grpprl, offset);,                    break;],,
BAD_PRACTICE,DE_MIGHT_IGNORE,org/apache/poi/hdf/extractor/StyleSheet.java,uncompressProperty,592-592,[          catch(Exception e){}],,
STYLE,ICAST_QUESTIONABLE_UNSIGNED_RIGHT_SHIFT,org/apache/poi/hdf/extractor/StyleSheet.java,doCHPOperation,165-165,[               short chsDiff = (short)((param & 0xff0000) >>> 8);],,
CORRECTNESS,INT_BAD_COMPARISON_WITH_SIGNED_BYTE,org/apache/poi/hdf/extractor/StyleSheet.java,doCHPOperation,321-321,[               if(hpsPos != 0x80)],,doCHPOperation,326-326,[               if(fAdjust && hpsPos != 128 && hpsPos != 0 && oldCHP._hpsPos == 0)],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/poi/hdf/extractor/StyleSheet.java,doCHPOperation,137-553,[      switch(operand),       {,           case 0:,                newCHP._fRMarkDel = getFlag(param);,                break;,           case 0x1:,                newCHP._fRMark = getFlag(param);,                break;,           case 0x2:,                break;,           case 0x3:,                newCHP._fcPic = param;,                newCHP._fSpec = true;,                break;,           case 0x4:,                newCHP._ibstRMark = (short)param;,                break;,           case 0x5:,                newCHP._dttmRMark[0] = Utils.convertBytesToShort(grpprl, (offset - 4));,                newCHP._dttmRMark[1] = Utils.convertBytesToShort(grpprl, (offset - 2));,                break;,           case 0x6:,                newCHP._fData = getFlag(param);,                break;,           case 0x7:,                //don't care about this,                break;,           case 0x8:,                short chsDiff = (short)((param & 0xff0000) >>> 8);,                newCHP._fChsDiff = getFlag(chsDiff);,                newCHP._chse = (short)(param & 0xffff);,                break;,           case 0x9:,                newCHP._fSpec = true;,                newCHP._ftcSym = Utils.convertBytesToShort(varParam, 0);,                newCHP._xchSym = Utils.convertBytesToShort(varParam, 2);,                break;,           case 0xa:,                newCHP._fOle2 = getFlag(param);,                break;,           case 0xb:,                //?,                break;,           case 0xc:,                newCHP._icoHighlight = (byte)param;,                newCHP._highlighted = getFlag(param);,                break;,           case 0xd:,                break;,           case 0xe:,                newCHP._fcObj = param;,                break;,           case 0xf:,                break;,           case 0x10:,                //?,                break;,           case 0x11:,                break;,           case 0x12:,                break;,           case 0x13:,                break;,           case 0x14:,                break;,           case 0x15:,                break;,           case 0x16:,                break;,           case 0x17:,                break;,           case 0x18:,                break;,           case 0x19:,                break;,           case 0x1a:,                break;,           case 0x1b:,                break;,           case 0x1c:,                break;,           case 0x1d:,                break;,           case 0x1e:,                break;,           case 0x1f:,                break;,           case 0x20:,                break;,           case 0x21:,                break;,           case 0x22:,                break;,           case 0x23:,                break;,           case 0x24:,                break;,           case 0x25:,                break;,           case 0x26:,                break;,           case 0x27:,                break;,           case 0x28:,                break;,           case 0x29:,                break;,           case 0x2a:,                break;,           case 0x2b:,                break;,           case 0x2c:,                break;,           case 0x2d:,                break;,           case 0x2e:,                break;,           case 0x2f:,                break;,           case 0x30:,                newCHP._istd = param;,                break;,           case 0x31:,                //permutation vector for fast saves who cares!,                break;,           case 0x32:,                newCHP._bold = false;,                newCHP._italic = false;,                newCHP._fOutline = false;,                newCHP._fStrike = false;,                newCHP._fShadow = false;,                newCHP._fSmallCaps = false;,                newCHP._fCaps = false;,                newCHP._fVanish = false;,                newCHP._kul = 0;,                newCHP._ico = 0;,                break;,           case 0x33:,                newCHP.copy(oldCHP);,                return;,           case 0x34:,                break;,           case 0x35:,                newCHP._bold = getCHPFlag((byte)param, oldCHP._bold);,                break;,           case 0x36:,                newCHP._italic = getCHPFlag((byte)param, oldCHP._italic);,                break;,           case 0x37:,                newCHP._fStrike = getCHPFlag((byte)param, oldCHP._fStrike);,                break;,           case 0x38:,                newCHP._fOutline = getCHPFlag((byte)param, oldCHP._fOutline);,                break;,           case 0x39:,                newCHP._fShadow = getCHPFlag((byte)param, oldCHP._fShadow);,                break;,           case 0x3a:,                newCHP._fSmallCaps = getCHPFlag((byte)param, oldCHP._fSmallCaps);,                break;,           case 0x3b:,                newCHP._fCaps = getCHPFlag((byte)param, oldCHP._fCaps);,                break;,           case 0x3c:,                newCHP._fVanish = getCHPFlag((byte)param, oldCHP._fVanish);,                break;,           case 0x3d:,                newCHP._ftc = (short)param;,                break;,           case 0x3e:,                newCHP._kul = (byte)param;,                break;,           case 0x3f:,                int hps = param & 0xff;,                if(hps != 0),                {,                   newCHP._hps = hps;,                },                byte cInc = (byte)(((byte)(param & 0xfe00) >>> 4) >> 1);,                if(cInc != 0),                {,                   newCHP._hps = Math.max(newCHP._hps + (cInc * 2), 2);,                },                byte hpsPos = (byte)((param & 0xff0000) >>> 8);,                if(hpsPos != 0x80),                {,                   newCHP._hpsPos = hpsPos;,                },                boolean fAdjust = (param & 0x0100) > 0;,                if(fAdjust && hpsPos != 128 && hpsPos != 0 && oldCHP._hpsPos == 0),                {,                   newCHP._hps = Math.max(newCHP._hps + (-2), 2);,                },                if(fAdjust && hpsPos == 0 && oldCHP._hpsPos != 0),                {,                   newCHP._hps = Math.max(newCHP._hps + 2, 2);,                },                break;,           case 0x40:,                newCHP._dxaSpace = param;,                break;,           case 0x41:,                newCHP._lidDefault = (short)param;,                break;,           case 0x42:,                newCHP._ico = (byte)param;,                break;,           case 0x43:,                newCHP._hps = param;,                break;,           case 0x44:,                byte hpsLvl = (byte)param;,                newCHP._hps = Math.max(newCHP._hps + (hpsLvl * 2), 2);,                break;,           case 0x45:,                newCHP._hpsPos = (short)param;,                break;,           case 0x46:,                if(param != 0),                {,                   if(oldCHP._hpsPos == 0),                   {,                       newCHP._hps = Math.max(newCHP._hps + (-2), 2);,                   },                },                else,                {,                   if(oldCHP._hpsPos != 0),                   {,                       newCHP._hps = Math.max(newCHP._hps + 2, 2);,                   },                },                break;,           case 0x47:,                CHP genCHP = new CHP();,                genCHP._ftc = 4;,                genCHP = (CHP)uncompressProperty(varParam, genCHP, styleSheet);,                CHP styleCHP = styleSheet.getStyleDescription(oldCHP._baseIstd).getCHP();,                if(genCHP._bold == newCHP._bold),                {,                   newCHP._bold = styleCHP._bold;,                },                if(genCHP._italic == newCHP._italic),                {,                   newCHP._italic = styleCHP._italic;,                },                if(genCHP._fSmallCaps == newCHP._fSmallCaps),                {,                   newCHP._fSmallCaps = styleCHP._fSmallCaps;,                },                if(genCHP._fVanish == newCHP._fVanish),                {,                   newCHP._fVanish = styleCHP._fVanish;,                },                if(genCHP._fStrike == newCHP._fStrike),                {,                   newCHP._fStrike = styleCHP._fStrike;,                },                if(genCHP._fCaps == newCHP._fCaps),                {,                   newCHP._fCaps = styleCHP._fCaps;,                },                if(genCHP._ftcAscii == newCHP._ftcAscii),                {,                   newCHP._ftcAscii = styleCHP._ftcAscii;,                },                if(genCHP._ftcFE == newCHP._ftcFE),                {,                   newCHP._ftcFE = styleCHP._ftcFE;,                },                if(genCHP._ftcOther == newCHP._ftcOther),                {,                   newCHP._ftcOther = styleCHP._ftcOther;,                },                if(genCHP._hps == newCHP._hps),                {,                   newCHP._hps = styleCHP._hps;,                },                if(genCHP._hpsPos == newCHP._hpsPos),                {,                   newCHP._hpsPos = styleCHP._hpsPos;,                },                if(genCHP._kul == newCHP._kul),                {,                   newCHP._kul = styleCHP._kul;,                },                if(genCHP._dxaSpace == newCHP._dxaSpace),                {,                   newCHP._dxaSpace = styleCHP._dxaSpace;,                },                if(genCHP._ico == newCHP._ico),                {,                   newCHP._ico = styleCHP._ico;,                },                if(genCHP._lidDefault == newCHP._lidDefault),                {,                   newCHP._lidDefault = styleCHP._lidDefault;,                },                if(genCHP._lidFE == newCHP._lidFE),                {,                   newCHP._lidFE = styleCHP._lidFE;,                },                break;,           case 0x48:,                newCHP._iss = (byte)param;,                break;,           case 0x49:,                newCHP._hps = Utils.convertBytesToShort(varParam, 0);,                break;,           case 0x4a:,                int increment = Utils.convertBytesToShort(varParam, 0);,                newCHP._hps = Math.max(newCHP._hps + increment, 8);,                break;,           case 0x4b:,                newCHP._hpsKern = param;,                break;,           case 0x4c:,                doCHPOperation(oldCHP, newCHP, 0x47, param, varParam, grpprl, offset, styleSheet);,                break;,           case 0x4d:,                float percentage = param/100.0f;,                int add = (int)(percentage * newCHP._hps);,                newCHP._hps += add;,                break;,           case 0x4e:,                newCHP._ysr = (byte)param;,                break;,           case 0x4f:,                newCHP._ftcAscii = (short)param;,                break;,           case 0x50:,                newCHP._ftcFE = (short)param;,                break;,           case 0x51:,                newCHP._ftcOther = (short)param;,                break;,           case 0x52:,                break;,           case 0x53:,                newCHP._fDStrike = getFlag(param);,                break;,           case 0x54:,                newCHP._fImprint = getFlag(param);,                break;,           case 0x55:,                newCHP._fSpec = getFlag(param);,                break;,           case 0x56:,                newCHP._fObj = getFlag(param);,                break;,           case 0x57:,                newCHP._fPropMark = getFlag(varParam[0]);,                newCHP._ibstPropRMark = Utils.convertBytesToShort(varParam, 1);,                newCHP._dttmPropRMark = Utils.convertBytesToInt(varParam, 3);,                break;,           case 0x58:,                newCHP._fEmboss = getFlag(param);,                break;,           case 0x59:,                newCHP._sfxtText = (byte)param;,                break;,           case 0x5a:,                break;,           case 0x5b:,                break;,           case 0x5c:,                break;,           case 0x5d:,                break;,           case 0x5e:,                break;,           case 0x5f:,                break;,           case 0x60:,                break;,           case 0x61:,                break;,           case 0x62:,                newCHP._fDispFldRMark = getFlag(varParam[0]);,                newCHP._ibstDispFldRMark = Utils.convertBytesToShort(varParam, 1);,                newCHP._dttmDispFldRMark = Utils.convertBytesToInt(varParam, 3);,                System.arraycopy(varParam, 7, newCHP._xstDispFldRMark, 0, 32);,                break;,           case 0x63:,                newCHP._ibstRMarkDel = (short)param;,                break;,           case 0x64:,                newCHP._dttmRMarkDel[0] = Utils.convertBytesToShort(grpprl, offset - 4);,                newCHP._dttmRMarkDel[1] = Utils.convertBytesToShort(grpprl, offset - 2);,                break;,           case 0x65:,                newCHP._brc[0] = Utils.convertBytesToShort(grpprl, offset - 4);,                newCHP._brc[1] = Utils.convertBytesToShort(grpprl, offset - 2);,                break;,           case 0x66:,                newCHP._shd = (short)param;,                break;,           case 0x67:,                break;,           case 0x68:,                break;,           case 0x69:,                break;,           case 0x6a:,                break;,           case 0x6b:,                break;,           case 0x6c:,                break;,           case 0x6d:,                newCHP._lidDefault = (short)param;,                break;,           case 0x6e:,                newCHP._lidFE = (short)param;,                break;,           case 0x6f:,                newCHP._idctHint = (byte)param;],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/poi/hdf/extractor/StyleSheet.java,uncompressProperty,669-690,[          switch(propertyType),           {,               case PAP_TYPE:,                    if(type == 1)//papx stores TAP sprms along with PAP sprms,                    {,                      doPAPOperation((PAP)newProperty, operand, param, varParam, grpprl,,                                     offset, spra);,                    },                    break;,               case CHP_TYPE:, ,                    doCHPOperation((CHP)parent, (CHP)newProperty, operand, param, varParam,,                                   grpprl, offset, styleSheet);,                    break;,               case SEP_TYPE:, ,                    doSEPOperation((SEP)newProperty, operand, param, varParam);,                    break;,               case TAP_TYPE:,                    if(type == 5),                    {,                      doTAPOperation((TAP)newProperty, operand, param, varParam);],,
STYLE,UC_USELESS_CONDITION,org/apache/poi/hdf/extractor/StyleSheet.java,doPAPOperation,713-713,[               if(newPAP._istd <=9 || newPAP._istd >=1)],,
STYLE,UC_USELESS_OBJECT,org/apache/poi/hdf/extractor/StyleSheet.java,<init>,42-42,[      int[] rgftc = new int[3];],,
BAD_PRACTICE,BIT_SIGNED_CHECK,org/apache/poi/hdf/extractor/TC.java,convertBytesToTC,49-49,[    tc._fFirstMerged = (rgf & 0x0001) > 0;],,
BAD_PRACTICE,BIT_SIGNED_CHECK,org/apache/poi/hdf/extractor/TC.java,convertBytesToTC,50-50,[    tc._fMerged = (rgf & 0x0002) > 0;],,
BAD_PRACTICE,BIT_SIGNED_CHECK,org/apache/poi/hdf/extractor/TC.java,convertBytesToTC,51-51,[    tc._fVertical = (rgf & 0x0004) > 0;],,
BAD_PRACTICE,BIT_SIGNED_CHECK,org/apache/poi/hdf/extractor/TC.java,convertBytesToTC,52-52,[    tc._fBackward = (rgf & 0x0008) > 0;],,
BAD_PRACTICE,BIT_SIGNED_CHECK,org/apache/poi/hdf/extractor/TC.java,convertBytesToTC,53-53,[    tc._fRotateFont = (rgf & 0x0010) > 0;],,
BAD_PRACTICE,BIT_SIGNED_CHECK,org/apache/poi/hdf/extractor/TC.java,convertBytesToTC,54-54,[    tc._fVertMerge = (rgf & 0x0020) > 0;],,
BAD_PRACTICE,BIT_SIGNED_CHECK,org/apache/poi/hdf/extractor/TC.java,convertBytesToTC,55-55,[    tc._fVertRestart = (rgf & 0x0040) > 0;],,
BAD_PRACTICE,EQ_COMPARETO_USE_OBJECT_EQUALS,org/apache/poi/hdf/extractor/TextPiece.java,compareTo,48-48,[       return 0;],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/poi/hdf/extractor/TextPiece.java,,35-48,[    super(start, start + length, null);,       _usesUnicode = unicode;,       _length = length;,       //_fcStart = start;,       //_fcEnd = start + length;, ,   },    public boolean usesUnicode(),   {,       return _usesUnicode;,   }, ,    public int compareTo(Object obj) {,        return 0;],,
BAD_PRACTICE,BIT_SIGNED_CHECK,org/apache/poi/hdf/extractor/WordDocument.java,initDocProperties,528-528,[    _docProps._fFacingPages = (dop[0] & 0x1) > 0;],,
I18N,DM_DEFAULT_ENCODING,org/apache/poi/hdf/extractor/WordDocument.java,writeAllText,167-167,[	String sText = new String(_header, start, end-start);],,
BAD_PRACTICE,RR_NOT_CHECKED,org/apache/poi/hdf/extractor/WordDocument.java,processComplexFile,281-281,[      filesystem.createDocumentInputStream(tablename).read(tableStream);],,
BAD_PRACTICE,RR_NOT_CHECKED,org/apache/poi/hdf/extractor/WordDocument.java,readFIB,226-226,[      filesystem.createDocumentInputStream("WordDocument").read(_header);],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/poi/hdf/extractor/WordDocument.java,findSectionHdrFtr,483-501,[    switch(type),     {,       case HeaderFooter.HEADER_EVEN:,            arrayIndex = (HEADER_EVEN_INDEX + (index * 6));,            break;,       case HeaderFooter.FOOTER_EVEN:,            arrayIndex = (FOOTER_EVEN_INDEX + (index * 6));,            break;,       case HeaderFooter.HEADER_ODD:,            arrayIndex = (HEADER_ODD_INDEX + (index * 6));,            break;,       case HeaderFooter.FOOTER_ODD:,            arrayIndex = (FOOTER_ODD_INDEX + (index * 6));,            break;,       case HeaderFooter.HEADER_FIRST:,            arrayIndex = (HEADER_FIRST_INDEX + (index * 6));,            break;,       case HeaderFooter.FOOTER_FIRST:,            arrayIndex = (FOOTER_FIRST_INDEX + (index * 6));],,
STYLE,UCF_USELESS_CONTROL_FLOW,org/apache/poi/hdf/extractor/WordDocument.java,addParagraphProperties,1168-1168,[    if(pap._lspd[1] == 0)],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/poi/hdf/extractor/WordDocument.java,createRegion,823-823,[    return "<fo:region-" + where + " overflow=\"scroll\" region-name=\"" + name + "\"/>";],,
BAD_PRACTICE,NP_CLONE_COULD_RETURN_NULL,org/apache/poi/hdf/extractor/data/LVL.java,clone,61-61,[    return obj;],,clone,52-52,[    LVL obj = null;],,clone,57-57,[    catch(Exception e)],,clone,59-59,[      e.printStackTrace();],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/poi/hdf/extractor/util/BTreeSet.java,,44-110,[    private Comparator comparator = null;,     int order;,     int size = 0;, ,     /*,      *                             Constructors,      * A no-arg constructor is supported in accordance with the specifications of the,      * java.util.Collections interface.  If the order for the B-Tree is not specified,      * at construction it defaults to 32.,     */, ,     public BTreeSet() {,         this(6);           // Default order for a BTreeSet is 32,     }, ,     public BTreeSet(Collection c) {,         this(6);           // Default order for a BTreeSet is 32,         addAll(c);,     }, ,     public BTreeSet(int order) {,         this(order, null);,     }, ,     public BTreeSet(int order, Comparator comparator) {,         this.order = order;,         this.comparator = comparator;,         root = new BTreeNode(null);,     }, , ,     /*,      * Public Methods,     */,     public boolean add(Object x) throws IllegalArgumentException {,         if (x == null) throw new IllegalArgumentException();,         return root.insert(x, -1);,     }, ,     public boolean contains(Object x) {,         return root.includes(x);,     }, ,     public boolean remove(Object x) {,         if (x == null) return false;,         return root.delete(x, -1);,     }, ,     public int size() {,         return size;,     }, ,     public void clear() {,         root = new BTreeNode(null);,         size = 0;,     }, ,     public java.util.Iterator iterator() {,         return new BTIterator();,     }, , ,     /*,      * Private methods,     */,     int compare(Object x, Object y) {,         return (comparator == null ? ((Comparable)x).compareTo(y) : comparator.compare(x, y));],,
STYLE,DB_DUPLICATE_SWITCH_CLAUSES,org/apache/poi/hdf/extractor/util/NumberFormatter.java,getNumber,69-69,[        return _arabic[num - 1];],,getNumber,79-79,[        return _arabic[num - 1];],,
I18N,DM_CONVERT_CASE,org/apache/poi/hdf/extractor/util/NumberFormatter.java,getNumber,71-71,[        return _roman[num-1].toUpperCase();],,getNumber,75-75,[        return _letter[num-1].toUpperCase();],,
BAD_PRACTICE,EQ_COMPARETO_USE_OBJECT_EQUALS,org/apache/poi/hdf/extractor/util/PropertyNode.java,compareTo,51-62,[      int fcStart = ((PropertyNode)o).getStart();,       if(_fcStart == fcStart),       {,         return 0;,       },       else if(_fcStart < fcStart),       {,         return -1;,       },       else,       {,         return 1;],,
BAD_PRACTICE,EQ_COMPARETO_USE_OBJECT_EQUALS,org/apache/poi/hdf/extractor/util/SepxNode.java,compareTo,41-41,[      return 0;],,
STYLE,DMI_HARDCODED_ABSOLUTE_FILENAME,org/apache/poi/hdf/model/HDFObjectFactory.java,main,63-63,[        HDFObjectFactory f = new HDFObjectFactory(new FileInputStream("c:\\test.doc"));],,
BAD_PRACTICE,RR_NOT_CHECKED,org/apache/poi/hdf/model/HDFObjectFactory.java,<init>,94-94,[        _filesystem.createDocumentInputStream("WordDocument").read(_mainDocument);],,
BAD_PRACTICE,RR_NOT_CHECKED,org/apache/poi/hdf/model/HDFObjectFactory.java,getTypes,129-129,[        filesystem.createDocumentInputStream("WordDocument").read(mainDocument);],,
BAD_PRACTICE,RR_NOT_CHECKED,org/apache/poi/hdf/model/HDFObjectFactory.java,initTableStream,161-161,[        _filesystem.createDocumentInputStream(tablename).read(_tableBuffer);],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/poi/hdf/model/HDFObjectFactory.java,initParagraphProperties,361-443,[        int parOffset = _fib.getFcPlcfbtePapx();,         int parPlcSize = _fib.getLcbPlcfbtePapx();, ,         //characters,         int charOffset = _fib.getFcPlcfbteChpx();,         int charPlcSize = _fib.getLcbPlcfbteChpx();, ,         PlexOfCps charPlcf = new PlexOfCps(charPlcSize, 4);,         PlexOfCps parPlcf = new PlexOfCps(parPlcSize, 4);, ,         //Initialize character property stuff,         int currentCharPage = LittleEndian.getInt(_tableBuffer, charOffset + charPlcf.getStructOffset(0));,         int charPlcfLen = charPlcf.length();,         int currentPageIndex = 0;,         byte[] fkp = new byte[512];,         System.arraycopy(_mainDocument, (currentCharPage * 512), fkp, 0, 512);,         CHPFormattedDiskPage cfkp = new CHPFormattedDiskPage(fkp);,         int currentChpxIndex = 0;,         int currentArraySize = cfkp.size();, , ,         int arraySize = parPlcf.length();, ,         //first we must go through the bin table and find the fkps,         for(int x = 0; x < arraySize; x++),         {,             int PN = LittleEndian.getInt(_tableBuffer, parOffset + parPlcf.getStructOffset(x));, ,             fkp = new byte[512];,             System.arraycopy(_mainDocument, (PN * 512), fkp, 0, 512);, ,             PAPFormattedDiskPage pfkp = new PAPFormattedDiskPage(fkp);,             //take each fkp and get the paps,             int crun = pfkp.size();,             for(int y = 0; y < crun; y++),             {,                 //get the beginning fc of each paragraph text run,                 int fcStart = pfkp.getStart(y);,                 int fcEnd = pfkp.getEnd(y);, ,                 //get the papx for this paragraph,                 byte[] papx = pfkp.getGrpprl(y);, ,                 _listener.paragraph(new PapxNode(fcStart, fcEnd, papx));, ,                 //get the character runs for this paragraph,                 int charStart = 0;,                 int charEnd = 0;,                 //add the character runs,                 do,                 {,                   if (currentChpxIndex < currentArraySize),                   {,                     charStart = cfkp.getStart(currentChpxIndex);,                     charEnd = cfkp.getEnd(currentChpxIndex);,                     byte[] chpx = cfkp.getGrpprl(currentChpxIndex);,                     _listener.characterRun(new ChpxNode(charStart, charEnd, chpx));,                     if (charEnd < fcEnd),                     {,                       currentChpxIndex++;,                     },                     else,                     {,                       break;,                     },                   },                   else,                   {,                     currentCharPage = LittleEndian.getInt(_tableBuffer, charOffset + charPlcf.getStructOffset(++currentPageIndex));,                     fkp = new byte[512];,                     System.arraycopy(_mainDocument, (currentCharPage * 512), fkp, 0, 512);,                     cfkp = new CHPFormattedDiskPage(fkp);,                     currentChpxIndex = 0;,                     currentArraySize = cfkp.size();,                   },                 },                 while(currentCharPage <= charPlcfLen + 1);, ,             }, ,         }, ,     }],,
BAD_PRACTICE,BIT_SIGNED_CHECK,org/apache/poi/hdf/model/hdftypes/DocumentProperties.java,<init>,40-40,[        _fFacingPages = (dopArray[0] & 0x1) > 0;],,
BAD_PRACTICE,NP_CLONE_COULD_RETURN_NULL,org/apache/poi/hdf/model/hdftypes/LVL.java,clone,63-63,[    return obj;],,clone,54-54,[    LVL obj = null;],,clone,59-59,[    catch(Exception e)],,clone,61-61,[      e.printStackTrace();],,
BAD_PRACTICE,EQ_COMPARETO_USE_OBJECT_EQUALS,org/apache/poi/hdf/model/hdftypes/PropertyNode.java,compareTo,70-81,[      int fcEnd = ((PropertyNode)o).getEnd();,       if(_fcEnd == fcEnd),       {,         return 0;,       },       else if(_fcEnd < fcEnd),       {,         return -1;,       },       else,       {,         return 1;],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/poi/hdf/model/hdftypes/SectionProperties.java,,82-100,[  {,       setBkc((byte)2);,       setDyaPgn(720);,       setDxaPgn(720);,       setFEndNote(true);,       setFEvenlySpaced(true);,       setXaPage(12240);,       setYaPage(15840);,       setDyaHdrTop(720);,       setDyaHdrBottom(720);,       setDmOrientPage((byte)1);,       setDxaColumns(720);,       setDyaTop(1440);,       setDxaLeft(1800);,       setDyaBottom(1440);,       setDxaRight(1800);,       setPgnStart(1);, ,   }],,
BAD_PRACTICE,EQ_COMPARETO_USE_OBJECT_EQUALS,org/apache/poi/hdf/model/hdftypes/SepxNode.java,compareTo,41-41,[      return 0;],,
STYLE,IM_BAD_CHECK_FOR_ODD,org/apache/poi/hdf/model/hdftypes/StyleDescription.java,<init>,94-94,[          if(upxSize % 2 == 1)],,
BAD_PRACTICE,BIT_SIGNED_CHECK,org/apache/poi/hdf/model/hdftypes/StyleSheet.java,doCHPOperation,389-389,[               boolean fAdjust = (param & 0x0100) > 0;],,
BAD_PRACTICE,BIT_SIGNED_CHECK,org/apache/poi/hdf/model/hdftypes/StyleSheet.java,doTAPOperation,1182-1182,[                 if((varParam[2] & 0x08) > 0)],,
BAD_PRACTICE,BIT_SIGNED_CHECK,org/apache/poi/hdf/model/hdftypes/StyleSheet.java,doTAPOperation,1188-1188,[                 else if((varParam[2] & 0x04) > 0)],,
BAD_PRACTICE,BIT_SIGNED_CHECK,org/apache/poi/hdf/model/hdftypes/StyleSheet.java,doTAPOperation,1194-1194,[                 else if((varParam[2] & 0x02) > 0)],,
BAD_PRACTICE,BIT_SIGNED_CHECK,org/apache/poi/hdf/model/hdftypes/StyleSheet.java,doTAPOperation,1200-1200,[                 else if((varParam[2] & 0x01) > 0)],,
STYLE,DB_DUPLICATE_SWITCH_CLAUSES,org/apache/poi/hdf/model/hdftypes/StyleSheet.java,doCHPOperation,368-369,[               newCHP.setFtcAscii((short)param);,                break;],,doCHPOperation,529-530,[               newCHP.setFtcAscii((short)param);,                break;],,
STYLE,DB_DUPLICATE_SWITCH_CLAUSES,org/apache/poi/hdf/model/hdftypes/StyleSheet.java,doCHPOperation,403-404,[               newCHP.setLidDefault((short)param);,                break;],,doCHPOperation,617-618,[               newCHP.setLidDefault((short)param);,                break;],,
STYLE,DB_DUPLICATE_SWITCH_CLAUSES,org/apache/poi/hdf/model/hdftypes/StyleSheet.java,doPAPOperation,944-945,[               newPAP.setDxaFromText(param);,                break;],,doPAPOperation,995-996,[               newPAP.setDxaFromText(param);,                break;],,
STYLE,DB_DUPLICATE_SWITCH_CLAUSES,org/apache/poi/hdf/model/hdftypes/StyleSheet.java,uncompressProperty,720-722,[                   opSize = 2;,                    param = LittleEndian.getShort(grpprl, offset);,                    break;],,uncompressProperty,729-731,[                   opSize = 2;,                    param = LittleEndian.getShort(grpprl, offset);,                    break;],,
BAD_PRACTICE,DE_MIGHT_IGNORE,org/apache/poi/hdf/model/hdftypes/StyleSheet.java,uncompressProperty,683-683,[          catch(Exception e){}],,
STYLE,ICAST_QUESTIONABLE_UNSIGNED_RIGHT_SHIFT,org/apache/poi/hdf/model/hdftypes/StyleSheet.java,doCHPOperation,222-222,[               short chsDiff = (short)((param & 0xff0000) >>> 8);],,
CORRECTNESS,INT_BAD_COMPARISON_WITH_SIGNED_BYTE,org/apache/poi/hdf/model/hdftypes/StyleSheet.java,doCHPOperation,385-385,[               if(hpsPos != 0x80)],,doCHPOperation,390-390,[               if(fAdjust && hpsPos != 128 && hpsPos != 0 && oldCHP.getHpsPos() == 0)],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/poi/hdf/model/hdftypes/StyleSheet.java,doCHPOperation,192-623,[      switch(operand),       {,           case 0:,                newCHP.setFRMarkDel(getFlag(param));,                break;,           case 0x1:,                newCHP.setFRMark(getFlag(param));,                break;,           case 0x2:,                break;,           case 0x3:,                newCHP.setFcPic(param);,                newCHP.setFSpec(true);,                break;,           case 0x4:,                newCHP.setIbstRMark((short)param);,                break;,           case 0x5:,                short[] dttmRMark = new short[2];,                dttmRMark[0] = LittleEndian.getShort(grpprl, (offset - 4));,                dttmRMark[1] = LittleEndian.getShort(grpprl, (offset - 2));,                newCHP.setDttmRMark(dttmRMark);,                break;,           case 0x6:,                newCHP.setFData(getFlag(param));,                break;,           case 0x7:,                //don't care about this,                break;,           case 0x8:,                short chsDiff = (short)((param & 0xff0000) >>> 8);,                newCHP.setFChsDiff(getFlag(chsDiff));,                newCHP.setChse((short)(param & 0xffff));,                break;,           case 0x9:,                newCHP.setFSpec(true);,                newCHP.setFtcSym(LittleEndian.getShort(varParam, 0));,                newCHP.setXchSym(LittleEndian.getShort(varParam, 2));,                break;,           case 0xa:,                newCHP.setFOle2(getFlag(param));,                break;,           case 0xb:,                //?,                break;,           case 0xc:,                newCHP.setIcoHighlight((byte)param);,                newCHP.setFHighlight(getFlag(param));,                break;,           case 0xd:,                break;,           case 0xe:,                newCHP.setFcObj(param);,                break;,           case 0xf:,                break;,           case 0x10:,                //?,                break;,           case 0x11:,                break;,           case 0x12:,                break;,           case 0x13:,                break;,           case 0x14:,                break;,           case 0x15:,                break;,           case 0x16:,                break;,           case 0x17:,                break;,           case 0x18:,                break;,           case 0x19:,                break;,           case 0x1a:,                break;,           case 0x1b:,                break;,           case 0x1c:,                break;,           case 0x1d:,                break;,           case 0x1e:,                break;,           case 0x1f:,                break;,           case 0x20:,                break;,           case 0x21:,                break;,           case 0x22:,                break;,           case 0x23:,                break;,           case 0x24:,                break;,           case 0x25:,                break;,           case 0x26:,                break;,           case 0x27:,                break;,           case 0x28:,                break;,           case 0x29:,                break;,           case 0x2a:,                break;,           case 0x2b:,                break;,           case 0x2c:,                break;,           case 0x2d:,                break;,           case 0x2e:,                break;,           case 0x2f:,                break;,           case 0x30:,                newCHP.setIstd(param);,                break;,           case 0x31:,                //permutation vector for fast saves, who cares!,                break;,           case 0x32:,                newCHP.setFBold(false);,                newCHP.setFItalic(false);,                newCHP.setFOutline(false);,                newCHP.setFStrike(false);,                newCHP.setFShadow(false);,                newCHP.setFSmallCaps(false);,                newCHP.setFCaps(false);,                newCHP.setFVanish(false);,                newCHP.setKul((byte)0);,                newCHP.setIco((byte)0);,                break;,           case 0x33:,                try,                {,                    newCHP = (CharacterProperties)oldCHP.clone();,                },                catch(CloneNotSupportedException e),                {,                    //do nothing,                },                return;,           case 0x34:,                break;,           case 0x35:,                newCHP.setFBold(getCHPFlag((byte)param, oldCHP.isFBold()));,                break;,           case 0x36:,                newCHP.setFItalic(getCHPFlag((byte)param, oldCHP.isFItalic()));,                break;,           case 0x37:,                newCHP.setFStrike(getCHPFlag((byte)param, oldCHP.isFStrike()));,                break;,           case 0x38:,                newCHP.setFOutline(getCHPFlag((byte)param, oldCHP.isFOutline()));,                break;,           case 0x39:,                newCHP.setFShadow(getCHPFlag((byte)param, oldCHP.isFShadow()));,                break;,           case 0x3a:,                newCHP.setFSmallCaps(getCHPFlag((byte)param, oldCHP.isFSmallCaps()));,                break;,           case 0x3b:,                newCHP.setFCaps(getCHPFlag((byte)param, oldCHP.isFCaps()));,                break;,           case 0x3c:,                newCHP.setFVanish(getCHPFlag((byte)param, oldCHP.isFVanish()));,                break;,           case 0x3d:,                newCHP.setFtcAscii((short)param);,                break;,           case 0x3e:,                newCHP.setKul((byte)param);,                break;,           case 0x3f:,                int hps = param & 0xff;,                if(hps != 0),                {,                   newCHP.setHps(hps);,                },                byte cInc = (byte)(((byte)(param & 0xfe00) >>> 4) >> 1);,                if(cInc != 0),                {,                   newCHP.setHps(Math.max(newCHP.getHps() + (cInc * 2), 2));,                },                byte hpsPos = (byte)((param & 0xff0000) >>> 8);,                if(hpsPos != 0x80),                {,                   newCHP.setHpsPos(hpsPos);,                },                boolean fAdjust = (param & 0x0100) > 0;,                if(fAdjust && hpsPos != 128 && hpsPos != 0 && oldCHP.getHpsPos() == 0),                {,                   newCHP.setHps(Math.max(newCHP.getHps() + (-2), 2));,                },                if(fAdjust && hpsPos == 0 && oldCHP.getHpsPos() != 0),                {,                   newCHP.setHps(Math.max(newCHP.getHps() + 2, 2));,                },                break;,           case 0x40:,                newCHP.setDxaSpace(param);,                break;,           case 0x41:,                newCHP.setLidDefault((short)param);,                break;,           case 0x42:,                newCHP.setIco((byte)param);,                break;,           case 0x43:,                newCHP.setHps(param);,                break;,           case 0x44:,                byte hpsLvl = (byte)param;,                newCHP.setHps(Math.max(newCHP.getHps() + (hpsLvl * 2), 2));,                break;,           case 0x45:,                newCHP.setHpsPos((short)param);,                break;,           case 0x46:,                if(param != 0),                {,                   if(oldCHP.getHpsPos() == 0),                   {,                       newCHP.setHps(Math.max(newCHP.getHps() + (-2), 2));,                   },                },                else,                {,                   if(oldCHP.getHpsPos() != 0),                   {,                       newCHP.setHps(Math.max(newCHP.getHps() + 2, 2));,                   },                },                break;,           case 0x47:,                CharacterProperties genCHP = new CharacterProperties();,                genCHP.setFtcAscii(4);,                genCHP = (CharacterProperties)uncompressProperty(varParam, genCHP, styleSheet);,                CharacterProperties styleCHP = styleSheet.getStyleDescription(oldCHP.getBaseIstd()).getCHP();,                if(genCHP.isFBold() == newCHP.isFBold()),                {,                   newCHP.setFBold(styleCHP.isFBold());,                },                if(genCHP.isFItalic() == newCHP.isFItalic()),                {,                   newCHP.setFItalic(styleCHP.isFItalic());,                },                if(genCHP.isFSmallCaps() == newCHP.isFSmallCaps()),                {,                   newCHP.setFSmallCaps(styleCHP.isFSmallCaps());,                },                if(genCHP.isFVanish() == newCHP.isFVanish()),                {,                   newCHP.setFVanish(styleCHP.isFVanish());,                },                if(genCHP.isFStrike() == newCHP.isFStrike()),                {,                   newCHP.setFStrike(styleCHP.isFStrike());,                },                if(genCHP.isFCaps() == newCHP.isFCaps()),                {,                   newCHP.setFCaps(styleCHP.isFCaps());,                },                if(genCHP.getFtcAscii() == newCHP.getFtcAscii()),                {,                   newCHP.setFtcAscii(styleCHP.getFtcAscii());,                },                if(genCHP.getFtcFE() == newCHP.getFtcFE()),                {,                   newCHP.setFtcFE(styleCHP.getFtcFE());,                },                if(genCHP.getFtcOther() == newCHP.getFtcOther()),                {,                   newCHP.setFtcOther(styleCHP.getFtcOther());,                },                if(genCHP.getHps() == newCHP.getHps()),                {,                   newCHP.setHps(styleCHP.getHps());,                },                if(genCHP.getHpsPos() == newCHP.getHpsPos()),                {,                   newCHP.setHpsPos(styleCHP.getHpsPos());,                },                if(genCHP.getKul() == newCHP.getKul()),                {,                   newCHP.setKul(styleCHP.getKul());,                },                if(genCHP.getDxaSpace() == newCHP.getDxaSpace()),                {,                   newCHP.setDxaSpace(styleCHP.getDxaSpace());,                },                if(genCHP.getIco() == newCHP.getIco()),                {,                   newCHP.setIco(styleCHP.getIco());,                },                if(genCHP.getLidDefault() == newCHP.getLidDefault()),                {,                   newCHP.setLidDefault(styleCHP.getLidDefault());,                },                if(genCHP.getLidFE() == newCHP.getLidFE()),                {,                   newCHP.setLidFE(styleCHP.getLidFE());,                },                break;,           case 0x48:,                newCHP.setIss((byte)param);,                break;,           case 0x49:,                newCHP.setHps(LittleEndian.getShort(varParam, 0));,                break;,           case 0x4a:,                int increment = LittleEndian.getShort(varParam, 0);,                newCHP.setHps(Math.max(newCHP.getHps() + increment, 8));,                break;,           case 0x4b:,                newCHP.setHpsKern(param);,                break;,           case 0x4c:,                doCHPOperation(oldCHP, newCHP, 0x47, param, varParam, grpprl, offset, styleSheet);,                break;,           case 0x4d:,                float percentage = param/100.0f;,                int add = (int)(percentage * newCHP.getHps());,                newCHP.setHps(newCHP.getHps() + add);,                break;,           case 0x4e:,                newCHP.setYsr((byte)param);,                break;,           case 0x4f:,                newCHP.setFtcAscii((short)param);,                break;,           case 0x50:,                newCHP.setFtcFE((short)param);,                break;,           case 0x51:,                newCHP.setFtcOther((short)param);,                break;,           case 0x52:,                break;,           case 0x53:,                newCHP.setFDStrike(getFlag(param));,                break;,           case 0x54:,                newCHP.setFImprint(getFlag(param));,                break;,           case 0x55:,                newCHP.setFSpec(getFlag(param));,                break;,           case 0x56:,                newCHP.setFObj(getFlag(param));,                break;,           case 0x57:,                newCHP.setFPropMark(varParam[0]);,                newCHP.setIbstPropRMark(LittleEndian.getShort(varParam, 1));,                newCHP.setDttmPropRMark(LittleEndian.getInt(varParam, 3));,                break;,           case 0x58:,                newCHP.setFEmboss(getFlag(param));,                break;,           case 0x59:,                newCHP.setSfxtText((byte)param);,                break;,           case 0x5a:,                break;,           case 0x5b:,                break;,           case 0x5c:,                break;,           case 0x5d:,                break;,           case 0x5e:,                break;,           case 0x5f:,                break;,           case 0x60:,                break;,           case 0x61:,                break;,           case 0x62:,                byte[] xstDispFldRMark = new byte[32];,                newCHP.setFDispFldRMark(varParam[0]);,                newCHP.setIbstDispFldRMark(LittleEndian.getShort(varParam, 1));,                newCHP.setDttmDispFldRMark(LittleEndian.getInt(varParam, 3));,                System.arraycopy(varParam, 7, xstDispFldRMark, 0, 32);,                newCHP.setXstDispFldRMark(xstDispFldRMark);,                break;,           case 0x63:,                newCHP.setIbstRMarkDel((short)param);,                break;,           case 0x64:,                short[] dttmRMarkDel = new short[2];,                dttmRMarkDel[0] = LittleEndian.getShort(grpprl, offset - 4);,                dttmRMarkDel[1] = LittleEndian.getShort(grpprl, offset - 2);,                newCHP.setDttmRMarkDel(dttmRMarkDel);,                break;,           case 0x65:,                short[] brc = new short[2];,                brc[0] = LittleEndian.getShort(grpprl, offset - 4);,                brc[1] = LittleEndian.getShort(grpprl, offset - 2);,                newCHP.setBrc(brc);,                break;,           case 0x66:,                newCHP.setShd((short)param);,                break;,           case 0x67:,                break;,           case 0x68:,                break;,           case 0x69:,                break;,           case 0x6a:,                break;,           case 0x6b:,                break;,           case 0x6c:,                break;,           case 0x6d:,                newCHP.setLidDefault((short)param);,                break;,           case 0x6e:,                newCHP.setLidFE((short)param);,                break;,           case 0x6f:,                newCHP.setIdctHint((byte)param);],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/poi/hdf/model/hdftypes/StyleSheet.java,uncompressProperty,765-789,[          switch(propertyType),           {,               case PAP_TYPE:,                    if(type == 1)//papx stores TAP sprms along with PAP sprms,                    {,                      doPAPOperation((ParagraphProperties)newProperty, operand,,                                     param, varParam, grpprl,,                                     offset, spra);,                    },                    break;,               case CHP_TYPE:, ,                    doCHPOperation((CharacterProperties)parent,,                                   (CharacterProperties)newProperty,,                                   operand, param, varParam,,                                   grpprl, offset, styleSheet);,                    break;,               case SEP_TYPE:, ,                    doSEPOperation((SectionProperties)newProperty, operand, param, varParam);,                    break;,               case TAP_TYPE:,                    if(type == 5),                    {,                      doTAPOperation((TableProperties)newProperty, operand, param, varParam);],,
STYLE,UC_USELESS_OBJECT,org/apache/poi/hdf/model/hdftypes/StyleSheet.java,<init>,55-55,[      int[] rgftc = new int[3];],,
BAD_PRACTICE,BIT_SIGNED_CHECK,org/apache/poi/hdf/model/hdftypes/TableCellDescriptor.java,convertBytesToTC,51-51,[    tc.setFFirstMerged((rgf & 0x0001) > 0);],,
BAD_PRACTICE,BIT_SIGNED_CHECK,org/apache/poi/hdf/model/hdftypes/TableCellDescriptor.java,convertBytesToTC,52-52,[    tc.setFMerged((rgf & 0x0002) > 0);],,
BAD_PRACTICE,BIT_SIGNED_CHECK,org/apache/poi/hdf/model/hdftypes/TableCellDescriptor.java,convertBytesToTC,53-53,[    tc.setFVertical((rgf & 0x0004) > 0);],,
BAD_PRACTICE,BIT_SIGNED_CHECK,org/apache/poi/hdf/model/hdftypes/TableCellDescriptor.java,convertBytesToTC,54-54,[    tc.setFBackward((rgf & 0x0008) > 0);],,
BAD_PRACTICE,BIT_SIGNED_CHECK,org/apache/poi/hdf/model/hdftypes/TableCellDescriptor.java,convertBytesToTC,55-55,[    tc.setFRotateFont((rgf & 0x0010) > 0);],,
BAD_PRACTICE,BIT_SIGNED_CHECK,org/apache/poi/hdf/model/hdftypes/TableCellDescriptor.java,convertBytesToTC,56-56,[    tc.setFVertMerge((rgf & 0x0020) > 0);],,
BAD_PRACTICE,BIT_SIGNED_CHECK,org/apache/poi/hdf/model/hdftypes/TableCellDescriptor.java,convertBytesToTC,57-57,[    tc.setFVertRestart((rgf & 0x0040) > 0);],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/poi/hdf/model/hdftypes/TableCellDescriptor.java,,45-77,[  {,   },   static TableCellDescriptor convertBytesToTC(byte[] array, int offset),   {,     TableCellDescriptor tc = new TableCellDescriptor();,     int rgf = LittleEndian.getShort(array, offset);,     tc.setFFirstMerged((rgf & 0x0001) > 0);,     tc.setFMerged((rgf & 0x0002) > 0);,     tc.setFVertical((rgf & 0x0004) > 0);,     tc.setFBackward((rgf & 0x0008) > 0);,     tc.setFRotateFont((rgf & 0x0010) > 0);,     tc.setFVertMerge((rgf & 0x0020) > 0);,     tc.setFVertRestart((rgf & 0x0040) > 0);,     tc.setVertAlign((byte)((rgf & 0x0180) >> 7));, ,     short[] brcTop = new short[2];,     short[] brcLeft = new short[2];,     short[] brcBottom = new short[2];,     short[] brcRight = new short[2];, ,     brcTop[0] = LittleEndian.getShort(array, offset + 4);,     brcTop[1] = LittleEndian.getShort(array, offset + 6);, ,     brcLeft[0] = LittleEndian.getShort(array, offset + 8);,     brcLeft[1] = LittleEndian.getShort(array, offset + 10);, ,     brcBottom[0] = LittleEndian.getShort(array, offset + 12);,     brcBottom[1] = LittleEndian.getShort(array, offset + 14);, ,     brcRight[0] = LittleEndian.getShort(array, offset + 16);,     brcRight[1] = LittleEndian.getShort(array, offset + 18);, ,     return tc;],,
STYLE,UC_USELESS_OBJECT,org/apache/poi/hdf/model/hdftypes/TableCellDescriptor.java,convertBytesToTC,62-62,[    short[] brcBottom = new short[2];],,
STYLE,UC_USELESS_OBJECT,org/apache/poi/hdf/model/hdftypes/TableCellDescriptor.java,convertBytesToTC,61-61,[    short[] brcLeft = new short[2];],,
STYLE,UC_USELESS_OBJECT,org/apache/poi/hdf/model/hdftypes/TableCellDescriptor.java,convertBytesToTC,63-63,[    short[] brcRight = new short[2];],,
STYLE,UC_USELESS_OBJECT,org/apache/poi/hdf/model/hdftypes/TableCellDescriptor.java,convertBytesToTC,60-60,[    short[] brcTop = new short[2];],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/poi/hdf/model/hdftypes/TextPiece.java,,41-51,[      super(start, start + length, null);,       _usesUnicode = unicode;,       _length = length;, ,   },   /**,    * @return If this text piece uses unicode,    */,    public boolean usesUnicode(),    {,       return _usesUnicode;],,
CORRECTNESS,DMI_INVOKING_TOSTRING_ON_ARRAY,org/apache/poi/hdf/model/hdftypes/definitions/DOPAbstractType.java,getAsumyi,555-555,[        buffer.append(" (").append(getAsumyi()).append(" )\n");],,
CORRECTNESS,DMI_INVOKING_TOSTRING_ON_ARRAY,org/apache/poi/hdf/model/hdftypes/definitions/DOPAbstractType.java,getDogrid,530-530,[        buffer.append(" (").append(getDogrid()).append(" )\n");],,
CORRECTNESS,DMI_INVOKING_TOSTRING_ON_ARRAY,org/apache/poi/hdf/model/hdftypes/definitions/DOPAbstractType.java,getDoptypography,526-526,[        buffer.append(" (").append(getDoptypography()).append(" )\n");],,
CORRECTNESS,DMI_INVOKING_TOSTRING_ON_ARRAY,org/apache/poi/hdf/model/hdftypes/definitions/DOPAbstractType.java,getSpare,578-578,[        buffer.append(" (").append(getSpare()).append(" )\n");],,
BAD_PRACTICE,NM_CONFUSING,org/apache/poi/hdf/model/hdftypes/definitions/DOPAbstractType.java,getCPg,955-955,[        return field_21_cPg;],,getCpg,1320-1320,[        return field_47_cpg;],,
BAD_PRACTICE,NM_CONFUSING,org/apache/poi/hdf/model/hdftypes/definitions/DOPAbstractType.java,setCPg,963-964,[        this.field_21_cPg = field_21_cPg;,     }],,setCpg,1329-1330,[        this.field_47_cpg = field_47_cpg;,     }],,
BAD_PRACTICE,NM_CONFUSING,org/apache/poi/hdf/model/hdftypes/definitions/FIBAbstractType.java,getFcPlcffldHdrTxbx,4527-4527,[        return field_172_fcPlcffldHdrTxbx;],,getFcPlcffldHdrtxbx,849-849,[      return _fieldHandler.getFieldOffset(FIBFieldHandler.PLCFFLDHDRTXBX);],,
BAD_PRACTICE,NM_CONFUSING,org/apache/poi/hdf/model/hdftypes/definitions/FIBAbstractType.java,getLcbPlcffldHdrTxbx,4543-4543,[        return field_173_lcbPlcffldHdrTxbx;],,getLcbPlcffldHdrtxbx,855-855,[      return _fieldHandler.getFieldSize(FIBFieldHandler.PLCFFLDHDRTXBX);],,
BAD_PRACTICE,NM_CONFUSING,org/apache/poi/hdf/model/hdftypes/definitions/FIBAbstractType.java,setFcPlcffldHdrTxbx,4535-4536,[        this.field_172_fcPlcffldHdrTxbx = field_172_fcPlcffldHdrTxbx;,     }],,setFcPlcffldHdrtxbx,861-862,[        _fieldHandler.setFieldOffset( FIBFieldHandler.PLCFFLDHDRTXBX, offset );,     }],,
BAD_PRACTICE,NM_CONFUSING,org/apache/poi/hdf/model/hdftypes/definitions/FIBAbstractType.java,setLcbPlcffldHdrTxbx,4551-4552,[        this.field_173_lcbPlcffldHdrTxbx = field_173_lcbPlcffldHdrTxbx;,     }],,setLcbPlcffldHdrtxbx,867-868,[        _fieldHandler.setFieldSize( FIBFieldHandler.PLCFFLDHDRTXBX, size );,     }],,
BAD_PRACTICE,NM_CONFUSING,org/apache/poi/hdf/model/hdftypes/definitions/PAPAbstractType.java,getIlvl,305-305,[        return field_12_ilvl;],,getILvl,183-183,[        return ( byte )iLvl.getValue(field_2_flags);],,
BAD_PRACTICE,NM_CONFUSING,org/apache/poi/hdf/model/hdftypes/definitions/PAPAbstractType.java,setIlvl,313-314,[        this.field_12_ilvl = field_12_ilvl;,     }],,setILvl,173-174,[        field_2_flags = iLvl.setValue(field_2_flags, value);,     }],,
STYLE,DB_DUPLICATE_SWITCH_CLAUSES,org/apache/poi/hdf/model/util/NumberFormatter.java,getNumber,69-69,[        return _arabic[num - 1];],,getNumber,79-79,[        return _arabic[num - 1];],,
I18N,DM_CONVERT_CASE,org/apache/poi/hdf/model/util/NumberFormatter.java,getNumber,71-71,[        return _roman[num-1].toUpperCase();],,getNumber,75-75,[        return _letter[num-1].toUpperCase();],,
I18N,DM_DEFAULT_ENCODING,org/apache/poi/hdgf/HDGFDiagram.java,<init>,83-83,[		String typeString = new String(_docstream, 0, 20);],,
BAD_PRACTICE,RR_NOT_CHECKED,org/apache/poi/hdgf/HDGFDiagram.java,<init>,80-80,[		dir.createDocumentInputStream("VisioDocument").read(_docstream);],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/poi/hdgf/TestHDGFLZW.java,,25-25,[	public static final byte[] testTrailerComp = new byte[] {],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/poi/hdgf/TestHDGFLZW.java,,75-75,[	public static final byte[] testTrailerDecomp = new byte[] {],,
PERFORMANCE,DM_FP_NUMBER_CTOR,org/apache/poi/hdgf/chunks/Chunk.java,processCommands,176-176,[						LittleEndian.getDouble(contents, offset)],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/poi/hdgf/chunks/Chunk.java,,283-283,[			this.offset = offset;],,
I18N,DM_DEFAULT_ENCODING,org/apache/poi/hdgf/chunks/ChunkFactory.java,processChunkParseCommands,73-73,[		BufferedReader inp = new BufferedReader(new InputStreamReader(cpd));],,
STYLE,NP_DEREFERENCE_OF_READLINE_VALUE,org/apache/poi/hdgf/chunks/ChunkFactory.java,processChunkParseCommands,88-88,[			while( ! (line = inp.readLine()).startsWith("end") ) {],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/poi/hdgf/chunks/ChunkFactory.java,,194-207,[		public CommandDefinition(int type, int offset, String name) {, 			this.type = type;, 			this.offset = offset;, 			this.name = name;, 		}, , 		public String getName() {, 			return name;, 		}, 		public int getOffset() {, 			return offset;, 		}, 		public int getType() {, 			return type;],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/poi/hdgf/chunks/TestChunks.java,,23-23,[public static final byte[] data_a = new byte[] { 70, 0, 0, 0,],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/poi/hdgf/chunks/TestChunks.java,,53-53,[public static final byte[] data_b = new byte[] { 70, 0, 0, 0,],,
PERFORMANCE,SBSC_USE_STRINGBUFFER_CONCATENATION,org/apache/poi/hdgf/dev/VSDDumper.java,dumpStream,59-59,[			ind += "    ";],,
I18N,DM_DEFAULT_ENCODING,org/apache/poi/hdgf/extractor/TestVisioExtractor.java,testMain,117-117,[		String text = baos.toString();],,
I18N,DM_DEFAULT_ENCODING,org/apache/poi/hdgf/extractor/TestVisioExtractor.java,testMain,106-106,[		PrintStream capture = new PrintStream(baos);],,
BAD_PRACTICE,BIT_SIGNED_CHECK,org/apache/poi/hdgf/pointers/PointerV6.java,destinationCompressed,38-38,[		return (format & 2) > 0;],,
STYLE,BC_VACUOUS_INSTANCEOF,org/apache/poi/hdgf/streams/TestStreamBasics.java,testCompressedStream,96-96,[		assertTrue(stream.getStore() instanceof StreamStore);],,
STYLE,BC_VACUOUS_INSTANCEOF,org/apache/poi/hdgf/streams/TestStreamBasics.java,testUncompressedStream,120-120,[		assertTrue(stream.getStore() instanceof StreamStore);],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/poi/hdgf/streams/TestStreamBasics.java,,27-27,[	public static final byte[] compressedStream = new byte[] {],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/poi/hdgf/streams/TestStreamBasics.java,,51-51,[	public static final byte[] uncompressedStream = new byte[] {],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/poi/hdgf/streams/TestStreamBasics.java,,24-24,[	public static final byte[] compressedStreamDCHeader = new byte[] {],,
BAD_PRACTICE,RR_NOT_CHECKED,org/apache/poi/hdgf/streams/TestStreamBugs.java,setUp,52-52,[		filesystem.createDocumentInputStream("VisioDocument").read(contents);],,
STYLE,UC_USELESS_VOID_METHOD,org/apache/poi/hdgf/streams/TestStreamBugs.java,TOIMPLEMENTtestGetCertainChunks,63-63,[	}],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/poi/hdgf/streams/TestStreamBugs.java,testGetChildren,66-66,[		Pointer trailerPointer = ptrFactory.createPointer(contents, 0x24);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/poi/hdgf/streams/TestStreamBugs.java,testGetTrailer,56-56,[		Pointer trailerPointer = ptrFactory.createPointer(contents, 0x24);],,
BAD_PRACTICE,RR_NOT_CHECKED,org/apache/poi/hdgf/streams/TestStreamComplex.java,setUp,50-50,[		filesystem.createDocumentInputStream("VisioDocument").read(contents);],,
BAD_PRACTICE,NM_CONFUSING,org/apache/poi/hmef/Attachment.java,getFilename,114-114,[      return getString(TNEFProperty.ID_ATTACHTITLE);],,getFileName,223-223,[    return fileName;],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/poi/hmef/Attachment.java,getRenderedMetaFile,155-155,[      if(meta == null) return null;],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/poi/hmef/CompressedRTF.java,,36-36,[   public static final byte[] COMPRESSED_SIGNATURE =],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/poi/hmef/CompressedRTF.java,,38-38,[   public static final byte[] UNCOMPRESSED_SIGNATURE =],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/poi/hmef/HMEFMessage.java,,60-60,[      fileId = LittleEndian.readUShort(inp);],,
BAD_PRACTICE,BIT_SIGNED_CHECK,org/apache/poi/hmef/attribute/MAPIAttribute.java,create,113-113,[         if( (typeAndMV & Types.MULTIVALUED_FLAG) > 0 ) {],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/poi/hmef/attribute/TNEFAttribute.java,,53-53,[      checksum = LittleEndian.readUShort(inp);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/poi/hmef/attribute/TestMAPIAttributes.java,testCommon,172-172,[      assertEquals("This is a test message", quick.getSubject());],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/poi/hmef/attribute/TestMAPIAttributes.java,testCounts,50-50,[      assertEquals(54, quick.getMessageMAPIAttributes().size());],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/poi/hmef/attribute/TestMAPIAttributes.java,testTyped,132-132,[      attr = quick.getMessageMAPIAttribute(MAPIProperty.CONVERSATION_TOPIC);],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/poi/hmef/extractor/HMEFContentsExtractor.java,extractAttachments,104-104,[         FileOutputStream fout = new FileOutputStream(file);],,extractAttachments,105-105,[         fout.write( att.getContents() );],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/poi/hmef/extractor/HMEFContentsExtractor.java,extractMessageBody,73-73,[      FileOutputStream fout = new FileOutputStream(dest);],,extractMessageBody,75-75,[      MAPIRtfAttribute body = (MAPIRtfAttribute)],,extractMessageBody,76-76,[         message.getMessageMAPIAttribute(MAPIProperty.RTF_COMPRESSED);],,extractMessageBody,77-77,[      fout.write(body.getData());],,
I18N,DM_DEFAULT_ENCODING,org/apache/poi/hpbf/dev/HPBFDumper.java,dumpCONTENTSguessed,268-268,[				startType[i] = new String(data, offset+2, 4);],,dumpCONTENTSguessed,272-272,[				endType[i] = new String(data, offset+12, 4);],,
I18N,DM_DEFAULT_ENCODING,org/apache/poi/hpbf/dev/HPBFDumper.java,dumpCONTENTSraw,203-203,[		System.out.println(],,dumpCONTENTSraw,217-217,[			String text = new String(data, pos, 4);],,
BAD_PRACTICE,RR_NOT_CHECKED,org/apache/poi/hpbf/dev/HPBFDumper.java,getData,52-52,[		dir.createDocumentInputStream(name).read(d);],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/poi/hpbf/model/HPBFPart.java,getPath,104-104,[	public final String[] getPath() {return null;}],,
BAD_PRACTICE,RR_NOT_CHECKED,org/apache/poi/hpbf/model/HPBFPart.java,<init>,52-52,[		dir.createDocumentInputStream(name).read(data);],,
I18N,DM_DEFAULT_ENCODING,org/apache/poi/hpbf/model/QuillContents.java,<init>,43-43,[		String f8 = new String(data, 0, 8);],,<init>,55-55,[				String thingType = new String(data, offset+2, 4);],,<init>,59-59,[				String bitType = new String(data, offset+12, 4);],,
I18N,DM_DEFAULT_ENCODING,org/apache/poi/hpsf/ClassID.java,hashCode,215-215,[        return new String(bytes).hashCode();],,
I18N,DM_DEFAULT_ENCODING,org/apache/poi/hpsf/CodePageString.java,getJavaValue,183-183,[            result = new String( _value );],,
I18N,DM_DEFAULT_ENCODING,org/apache/poi/hpsf/CodePageString.java,setJavaValue,214-214,[            _value = ( string + "\0" ).getBytes();],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/poi/hpsf/CustomProperties.java,,60-420,[public class CustomProperties extends HashMap<Object,CustomProperty>, {, ,     /**,      * <p>Maps property IDs to property names.</p>,      */,     private Map<Long,String> dictionaryIDToName = new HashMap<Long,String>();, ,     /**,      * <p>Maps property names to property IDs.</p>,      */,     private Map<String,Long> dictionaryNameToID = new HashMap<String,Long>();, ,     /**,      * <p>Tells whether this object is pure or not.</p>,      */,     private boolean isPure = true;, , ,     /**,      * <p>Puts a {@link CustomProperty} into this map. It is assumed that the,      * {@link CustomProperty} already has a valid ID. Otherwise use,      * {@link #put(CustomProperty)}.</p>,      */,     public CustomProperty put(final String name, final CustomProperty cp),     {,         if (name == null),         {,             /* Ignoring a property without a name. */,             isPure = false;,             return null;,         },         if (!(name.equals(cp.getName()))),             throw new IllegalArgumentException("Parameter \"name\" (" + name +,                     ") and custom property's name (" + cp.getName() +,                     ") do not match.");, ,         /* Register name and ID in the dictionary. Mapping in both directions is possible. If there is already a  */,         final Long idKey = Long.valueOf(cp.getID());,         final Long oldID = dictionaryNameToID.get(name);,         dictionaryIDToName.remove(oldID);,         dictionaryNameToID.put(name, idKey);,         dictionaryIDToName.put(idKey, name);, ,         /* Put the custom property into this map. */,         final CustomProperty oldCp = super.remove(oldID);,         super.put(idKey, cp);,         return oldCp;,     }, , , ,     /**,      * <p>Puts a {@link CustomProperty} that has not yet a valid ID into this,      * map. The method will allocate a suitable ID for the custom property:</p>,      *,      * <ul>,      *,      * <li><p>If there is already a property with the same name, take the ID,      * of that property.</p></li>,      *,      * <li><p>Otherwise find the highest ID and use its value plus one.</p></li>,      *,      * </ul>,      *,      * @param customProperty,      * @return If the was already a property with the same name, the,      * @throws ClassCastException,      */,     private Object put(final CustomProperty customProperty) throws ClassCastException,     {,         final String name = customProperty.getName();, ,         /* Check whether a property with this name is in the map already. */,         final Long oldId = (Long) dictionaryNameToID.get(name);,         if (oldId != null),             customProperty.setID(oldId.longValue());,         else,         {,             long max = 1;,             for (final Iterator<Long> i = dictionaryIDToName.keySet().iterator(); i.hasNext();),             {,                 final long id = i.next().longValue();,                 if (id > max),                     max = id;,             },             customProperty.setID(max + 1);,         },         return this.put(name, customProperty);,     }, , , ,     /**,      * <p>Removes a custom property.</p>,      * @param name The name of the custom property to remove,      * @return The removed property or <code>null</code> if the specified property was not found.,      *,      * @see java.util.HashSet#remove(java.lang.Object),      */,     public Object remove(final String name),     {,         final Long id = (Long) dictionaryNameToID.get(name);,         if (id == null),             return null;,         dictionaryIDToName.remove(id);,         dictionaryNameToID.remove(name);,         return super.remove(id);,     }, ,     /**,      * <p>Adds a named string property.</p>,      *,      * @param name The property's name.,      * @param value The property's value.,      * @return the property that was stored under the specified name before, or,      *         <code>null</code> if there was no such property before.,      */,     public Object put(final String name, final String value),     {,         final MutableProperty p = new MutableProperty();,         p.setID(-1);,         p.setType(Variant.VT_LPWSTR);,         p.setValue(value);,         final CustomProperty cp = new CustomProperty(p, name);,         return put(cp);,     }, ,     /**,      * <p>Adds a named long property.</p>,      *,      * @param name The property's name.,      * @param value The property's value.,      * @return the property that was stored under the specified name before, or,      *         <code>null</code> if there was no such property before.,      */,     public Object put(final String name, final Long value),     {,         final MutableProperty p = new MutableProperty();,         p.setID(-1);,         p.setType(Variant.VT_I8);,         p.setValue(value);,         final CustomProperty cp = new CustomProperty(p, name);,         return put(cp);,     }, ,     /**,      * <p>Adds a named double property.</p>,      *,      * @param name The property's name.,      * @param value The property's value.,      * @return the property that was stored under the specified name before, or,      *         <code>null</code> if there was no such property before.,      */,     public Object put(final String name, final Double value),     {,         final MutableProperty p = new MutableProperty();,         p.setID(-1);,         p.setType(Variant.VT_R8);,         p.setValue(value);,         final CustomProperty cp = new CustomProperty(p, name);,         return put(cp);,     }, ,     /**,      * <p>Adds a named integer property.</p>,      *,      * @param name The property's name.,      * @param value The property's value.,      * @return the property that was stored under the specified name before, or,      *         <code>null</code> if there was no such property before.,      */,     public Object put(final String name, final Integer value),     {,         final MutableProperty p = new MutableProperty();,         p.setID(-1);,         p.setType(Variant.VT_I4);,         p.setValue(value);,         final CustomProperty cp = new CustomProperty(p, name);,         return put(cp);,     }, ,     /**,      * <p>Adds a named boolean property.</p>,      *,      * @param name The property's name.,      * @param value The property's value.,      * @return the property that was stored under the specified name before, or,      *         <code>null</code> if there was no such property before.,      */,     public Object put(final String name, final Boolean value),     {,         final MutableProperty p = new MutableProperty();,         p.setID(-1);,         p.setType(Variant.VT_BOOL);,         p.setValue(value);,         final CustomProperty cp = new CustomProperty(p, name);,         return put(cp);,     }, , ,     /**,      * <p>Gets a named value from the custom properties.</p>,      *,      * @param name the name of the value to get,      * @return the value or <code>null</code> if a value with the specified,      *         name is not found in the custom properties.,      */,     public Object get(final String name),     {,         final Long id = (Long) dictionaryNameToID.get(name);,         final CustomProperty cp = (CustomProperty) super.get(id);,         return cp != null ? cp.getValue() : null;,     }, , , ,     /**,      * <p>Adds a named date property.</p>,      *,      * @param name The property's name.,      * @param value The property's value.,      * @return the property that was stored under the specified name before, or,      *         <code>null</code> if there was no such property before.,      */,     public Object put(final String name, final Date value),     {,         final MutableProperty p = new MutableProperty();,         p.setID(-1);,         p.setType(Variant.VT_FILETIME);,         p.setValue(value);,         final CustomProperty cp = new CustomProperty(p, name);,         return put(cp);,     }, ,     /**,      * Returns a set of all the names of our,      *  custom properties. Equivalent to ,      *  {@link #nameSet()},      */,     public Set keySet() {,         return dictionaryNameToID.keySet();,     }, ,     /**,      * Returns a set of all the names of our,      *  custom properties,      */,     public Set<String> nameSet() {,         return dictionaryNameToID.keySet();,     }, ,     /**,      * Returns a set of all the IDs of our,      *  custom properties,      */,     public Set<String> idSet() {,         return dictionaryNameToID.keySet();,     }, , ,     /**,      * <p>Sets the codepage.</p>,      *,      * @param codepage the codepage,      */,     public void setCodepage(final int codepage),     {,         final MutableProperty p = new MutableProperty();,         p.setID(PropertyIDMap.PID_CODEPAGE);,         p.setType(Variant.VT_I2);,         p.setValue(Integer.valueOf(codepage));,         put(new CustomProperty(p));,     }, , , ,     /**,      * <p>Gets the dictionary which contains IDs and names of the named custom,      * properties.,      *,      * @return the dictionary.,      */,     Map<Long,String> getDictionary(),     {,         return dictionaryIDToName;,     }, , ,     /**,      * Checks against both String Name and Long ID,      */,    public boolean containsKey(Object key) {,       if(key instanceof Long) {,          return super.containsKey((Long)key);,       },       if(key instanceof String) {,          return super.containsKey((Long)dictionaryNameToID.get(key));,       },       return false;,    }, ,    /**,     * Checks against both the property, and its values. ,     */,    public boolean containsValue(Object value) {,       if(value instanceof CustomProperty) {,          return super.containsValue((CustomProperty)value);,       } else {,          for(CustomProperty cp : super.values()) {,             if(cp.getValue() == value) {,                return true;,             },          },       },       return false;,    }, , , ,    /**,      * <p>Gets the codepage.</p>,      *,      * @return the codepage or -1 if the codepage is undefined.,      */,     public int getCodepage(),     {,         int codepage = -1;,         for (final Iterator<CustomProperty> i = this.values().iterator(); codepage == -1 && i.hasNext();),         {,             final CustomProperty cp = i.next();,             if (cp.getID() == PropertyIDMap.PID_CODEPAGE),                 codepage = ((Integer) cp.getValue()).intValue();,         },         return codepage;,     }, , , ,     /**,      * <p>Tells whether this {@link CustomProperties} instance is pure or one or,      * more properties of the underlying low-level property set has been,      * dropped.</p>,      *,      * @return <code>true</code> if the {@link CustomProperties} is pure, else,      *         <code>false</code>.,      */,     public boolean isPure(),     {,         return isPure;,     }, ,     /**,      * <p>Sets the purity of the custom property set.</p>,      *,      * @param isPure the purity,      */,     public void setPure(final boolean isPure),     {,         this.isPure = isPure;,     }],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/poi/hpsf/Property.java,equals,346-369,[        if (!(o instanceof Property)) {,             return false;,         },         final Property p = (Property) o;,         final Object pValue = p.getValue();,         final long pId = p.getID();,         if (id != pId || (id != 0 && !typesAreEqual(type, p.getType()))),             return false;,         if (value == null && pValue == null),             return true;,         if (value == null || pValue == null),             return false;, ,         /* It's clear now that both values are non-null. */,         final Class<?> valueClass = value.getClass();,         final Class<?> pValueClass = pValue.getClass();,         if (!(valueClass.isAssignableFrom(pValueClass)) &&,             !(pValueClass.isAssignableFrom(valueClass))),             return false;, ,         if (value instanceof byte[]),             return Util.equal((byte[]) value, (byte[]) pValue);, ,         return value.equals(pValue);],,
BAD_PRACTICE,HE_HASHCODE_NO_EQUALS,org/apache/poi/hpsf/CustomProperty.java,hashCode,119-119,[        return (int) this.getID();],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/poi/hpsf/Decimal.java,,37-37,[        field_1_wReserved = LittleEndian.getShort( data, offset );],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/poi/hpsf/Decimal.java,,40-40,[        field_2_scale = data[offset];],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/poi/hpsf/Decimal.java,,43-43,[        field_3_sign = data[offset];],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/poi/hpsf/Decimal.java,,46-46,[        field_4_hi32 = LittleEndian.getInt( data, offset );],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/poi/hpsf/Decimal.java,,49-49,[        field_5_lo64 = LittleEndian.getLong( data, offset );],,
BAD_PRACTICE,NM_CONFUSING,org/apache/poi/hpsf/MutableProperty.java,setID,65-66,[        this.id = id;,     }],,setId,154-155,[		graphicFrame.getNvGraphicFramePr().getCNvPr().setId(id);, 	}],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/poi/hpsf/PropertySet.java,equals,636-657,[        if (o == null || !(o instanceof PropertySet)),             return false;,         final PropertySet ps = (PropertySet) o;,         int byteOrder1 = ps.getByteOrder();,         int byteOrder2 = getByteOrder();,         ClassID classID1 = ps.getClassID();,         ClassID classID2 = getClassID();,         int format1 = ps.getFormat();,         int format2 = getFormat();,         int osVersion1 = ps.getOSVersion();,         int osVersion2 = getOSVersion();,         int sectionCount1 = ps.getSectionCount();,         int sectionCount2 = getSectionCount();,         if (byteOrder1 != byteOrder2      ||,             !classID1.equals(classID2)    ||,             format1 != format2            ||,             osVersion1 != osVersion2      ||,             sectionCount1 != sectionCount2),             return false;, ,         /* Compare the sections: */,         return Util.equals(getSections(), ps.getSections());],,
STYLE,EQ_DOESNT_OVERRIDE_EQUALS,org/apache/poi/hpsf/Section.java,equals,487-551,[        if (o == null || !(o instanceof Section)),             return false;,         final Section s = (Section) o;,         if (!s.getFormatID().equals(getFormatID())),             return false;, ,         /* Compare all properties except 0 and 1 as they must be handled,          * specially. */,         Property[] pa1 = new Property[getProperties().length];,         Property[] pa2 = new Property[s.getProperties().length];,         System.arraycopy(getProperties(), 0, pa1, 0, pa1.length);,         System.arraycopy(s.getProperties(), 0, pa2, 0, pa2.length);, ,         /* Extract properties 0 and 1 and remove them from the copy of the,          * arrays. */,         Property p10 = null;,         Property p20 = null;,         for (int i = 0; i < pa1.length; i++),         {,             final long id = pa1[i].getID();,             if (id == 0),             {,                 p10 = pa1[i];,                 pa1 = remove(pa1, i);,                 i--;,             },             if (id == 1),             {,                 // p11 = pa1[i];,                 pa1 = remove(pa1, i);,                 i--;,             },         },         for (int i = 0; i < pa2.length; i++),         {,             final long id = pa2[i].getID();,             if (id == 0),             {,                 p20 = pa2[i];,                 pa2 = remove(pa2, i);,                 i--;,             },             if (id == 1),             {,                 // p21 = pa2[i];,                 pa2 = remove(pa2, i);,                 i--;,             },         }, ,         /* If the number of properties (not counting property 1) is unequal the,          * sections are unequal. */,         if (pa1.length != pa2.length),             return false;, ,         /* If the dictionaries are unequal the sections are unequal. */,         boolean dictionaryEqual = true;,         if (p10 != null && p20 != null),             dictionaryEqual = p10.getValue().equals(p20.getValue());,         else if (p10 != null || p20 != null),             dictionaryEqual = false;,         if (dictionaryEqual) {,             return Util.equals(pa1, pa2);,         },         return false;],,
STYLE,IM_BAD_CHECK_FOR_ODD,org/apache/poi/hpsf/MutableSection.java,writeDictionary,516-516,[                if (sLength % 2 == 1)],,
PERFORMANCE,WMI_WRONG_MAP_ITERATOR,org/apache/poi/hpsf/MutableSection.java,writeDictionary,510-510,[            final String value = dictionary.get(key);],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/poi/hpsf/MutableSection.java,,427-435,[            {,                 public int compare(final Property p1, final Property p2),                 {,                     if (p1.getID() < p2.getID()),                         return -1;,                     else if (p1.getID() == p2.getID()),                         return 0;,                     else,                         return 1;],,
I18N,DM_DEFAULT_ENCODING,org/apache/poi/hpsf/Property.java,readDictionary,240-240,[                        b.append(new String(src, o, (int) sLength));],,
BAD_PRACTICE,NM_CONFUSING,org/apache/poi/hpsf/Property.java,getID,74-74,[        return id;],,getId,147-147,[		return graphicFrame.getNvGraphicFramePr().getCNvPr().getId();],,
BAD_PRACTICE,RR_NOT_CHECKED,org/apache/poi/hpsf/PropertySet.java,<init>,245-245,[            stream.read(buffer, 0, buffer.length);],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/poi/hpsf/Section.java,getPIDString,454-454,[        if (s == null)],,
BAD_PRACTICE,EQ_COMPARETO_USE_OBJECT_EQUALS,org/apache/poi/hpsf/Section.java,compareTo,312-318,[            final int otherOffset = o.offset;,             if (offset < otherOffset),                 return -1;,             else if (offset == otherOffset),                 return 0;,             else,                 return 1;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/poi/hpsf/Section.java,,297-332,[    class PropertyListEntry implements Comparable<PropertyListEntry>,     {,         int id;,         int offset;,         int length;, ,         /**,          * <p>Compares this {@link PropertyListEntry} with another one by their,          * offsets. A {@link PropertyListEntry} is "smaller" than another one if,          * its offset from the section's begin is smaller.</p>,          *,          * @see Comparable#compareTo(java.lang.Object),          */,         public int compareTo(final PropertyListEntry o),         {,             final int otherOffset = o.offset;,             if (offset < otherOffset),                 return -1;,             else if (offset == otherOffset),                 return 0;,             else,                 return 1;,         }, ,         public String toString(),         {,             final StringBuffer b = new StringBuffer();,             b.append(getClass().getName());,             b.append("[id=");,             b.append(id);,             b.append(", offset=");,             b.append(offset);,             b.append(", length=");,             b.append(length);,             b.append(']');,             return b.toString();],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/poi/hpsf/Thumbnail.java,,71-71,[    public static int CFTAG_WINDOWS = -1;],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/poi/hpsf/Thumbnail.java,,105-105,[    public static int CF_METAFILEPICT = 3;],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/poi/hpsf/Thumbnail.java,,45-45,[    public static int OFFSET_CF = 8;],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/poi/hpsf/Thumbnail.java,,35-35,[    public static int OFFSET_CFTAG = 4;],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/poi/hpsf/Thumbnail.java,,63-63,[    public static int OFFSET_WMFDATA = 20;],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/poi/hpsf/Thumbnail.java,,87-87,[    public static int CFTAG_FMTID = -3;],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/poi/hpsf/Thumbnail.java,,79-79,[    public static int CFTAG_MACINTOSH = -2;],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/poi/hpsf/Thumbnail.java,,95-95,[    public static int CFTAG_NODATA = 0;],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/poi/hpsf/Thumbnail.java,,124-124,[    public static int CF_BITMAP = 2;],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/poi/hpsf/Thumbnail.java,,110-110,[    public static int CF_DIB = 8;],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/poi/hpsf/Thumbnail.java,,115-115,[    public static int CF_ENHMETAFILE = 14;],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/poi/hpsf/Thumbnail.java,,87-87,[    public static int CFTAG_FMTID = -3;],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/poi/hpsf/Thumbnail.java,,79-79,[    public static int CFTAG_MACINTOSH = -2;],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/poi/hpsf/Thumbnail.java,,95-95,[    public static int CFTAG_NODATA = 0;],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/poi/hpsf/Thumbnail.java,,124-124,[    public static int CF_BITMAP = 2;],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/poi/hpsf/Thumbnail.java,,110-110,[    public static int CF_DIB = 8;],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/poi/hpsf/Thumbnail.java,,115-115,[    public static int CF_ENHMETAFILE = 14;],,
STYLE,UC_USELESS_CONDITION,org/apache/poi/hpsf/VariantBool.java,<init>,51-51,[        _value = value != 0;],,
STYLE,UC_USELESS_CONDITION_TYPE,org/apache/poi/hpsf/VariantBool.java,<init>,45-45,[            _value = true;],,<init>,43-43,[        if ( value == 0xffff )],,
MT_CORRECTNESS,LI_LAZY_INIT_STATIC,org/apache/poi/hpsf/VariantSupport.java,writeUnsupportedTypeMessage,95-96,[            if (unsupportedMessage == null),                 unsupportedMessage = new LinkedList();],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/poi/hpsf/VariantSupport.java,,110-110,[    final static public int[] SUPPORTED_TYPES = { Variant.VT_EMPTY,],,
STYLE,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,org/apache/poi/hpsf/basic/AllDataFilesTester.java,runTests,70-70,[        for (int i = 0; i < docs.length; i++)],,runTests,64-64,[        final File[] docs = dataDir.listFiles(new FileFilter()],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/poi/hpsf/basic/AllDataFilesTester.java,,65-68,[        {,             public boolean accept(final File file),             {,                 return file.isFile() && file.getName().startsWith("Test");],,
I18N,DM_DEFAULT_ENCODING,org/apache/poi/hpsf/basic/TestBasic.java,testPropertySetMethods,166-166,[            Assert.assertEquals(new String(ps.getClassID().getBytes()),],,
I18N,DM_CONVERT_CASE,org/apache/poi/hpsf/basic/TestClassID.java,testClassID,118-118,[        Assert.assertEquals(clsidTest.toString().toUpperCase(),],,
PERFORMANCE,DM_FP_NUMBER_CTOR,org/apache/poi/hpsf/basic/TestMetaDataIPI.java,testConvAndExistence,636-636,[		customProperties.put("double", new Double(12345.2));],,testConvAndExistence,637-637,[		customProperties.put("negdouble", new Double(-12345.3));],,testConvAndExistence,694-694,[		assertEquals("int", new Double(12345.2), d);],,testConvAndExistence,697-697,[		assertEquals("string", new Double(-12345.3), d);],,
PERFORMANCE,DM_FP_NUMBER_CTOR,org/apache/poi/hpsf/basic/TestMetaDataIPI.java,testOne,218-218,[		customProperties.put("Sample Double", new Double(-1.0001));],,testOne,263-263,[		assertEquals("Custom Float", new Double(-1.0001), a6);],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/poi/hpsf/basic/TestMetaDataIPI.java,testConvAndExistence,628-628,[		customProperties.put("int", new Integer(12345));],,testConvAndExistence,629-629,[		customProperties.put("negint", new Integer(-12345));],,testConvAndExistence,676-676,[		assertEquals("int", new Integer(12345), a3);],,testConvAndExistence,679-679,[		assertEquals("negint", new Integer(-12345), a3);],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/poi/hpsf/basic/TestMetaDataIPI.java,testConvAndExistence,630-630,[		customProperties.put("long", new Long(12345));],,testConvAndExistence,631-631,[		customProperties.put("neglong", new Long(-12345));],,testConvAndExistence,682-682,[		assertEquals("neglong", new Long(-12345), al);],,testConvAndExistence,685-685,[		assertEquals("long", new Long(12345), al);],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/poi/hpsf/basic/TestMetaDataIPI.java,testOne,214-214,[		customProperties.put("Sample Integer", new Integer(12345));],,testOne,219-219,[		customProperties.put("Sample Negative Integer", new Integer(-100000));],,testOne,256-256,[		assertEquals("Sample Number", new Integer(12345), a3);],,testOne,266-266,[		assertEquals("Neg", new Integer(-100000), a7);],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/poi/hpsf/basic/TestMetaDataIPI.java,testThree,431-431,[		customProperties.put("Sample Number", new Integer(12345));],,testThree,473-473,[		assertEquals("Sample Number", new Integer(12345), a3);],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/poi/hpsf/basic/TestMetaDataIPI.java,testTwo,318-318,[		customProperties.put("Sample Number", new Integer(12345));],,testTwo,359-359,[		assertEquals("Sample Number", new Integer(12345), a3);],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/poi/hpsf/basic/TestMetaDataIPI.java,testUnicode,555-555,[		customProperties.put("Sample Number", new Integer(12345));],,testUnicode,597-597,[		assertEquals("Sample Number", new Integer(12345), a3);],,
STYLE,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,org/apache/poi/hpsf/basic/TestReadAllFiles.java,testReadAllFiles,56-56,[            for (int i = 0; i < fileList.length; i++)],,testReadAllFiles,47-47,[        final File[] fileList = dataDir.listFiles(new FileFilter()],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/poi/hpsf/basic/TestReadAllFiles.java,,48-51,[            {,                 public boolean accept(final File f),                 {,                     return f.isFile();],,
PERFORMANCE,DM_FP_NUMBER_CTOR,org/apache/poi/hpsf/basic/TestWrite.java,testVariantTypes,383-383,[            check(Variant.VT_R8, new Double(29.0), codepage);],,testVariantTypes,386-386,[            check(Variant.VT_R8, new Double(-29.0), codepage);],,testVariantTypes,392-392,[            check(Variant.VT_R8, new Double(Double.MAX_VALUE), codepage);],,testVariantTypes,393-393,[            check(Variant.VT_R8, new Double(Double.MIN_VALUE), codepage);],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/poi/hpsf/basic/TestWrite.java,testVariantTypes,388-388,[            check(Variant.VT_I4, new Integer(Integer.MAX_VALUE), codepage);],,testVariantTypes,389-389,[            check(Variant.VT_I4, new Integer(Integer.MIN_VALUE), codepage);],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/poi/hpsf/basic/TestWrite.java,testVariantTypes,390-390,[            check(Variant.VT_I8, new Long(Long.MAX_VALUE), codepage);],,testVariantTypes,391-391,[            check(Variant.VT_I8, new Long(Long.MIN_VALUE), codepage);],,
STYLE,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,org/apache/poi/hpsf/basic/TestWrite.java,testRecreate,679-679,[        for (int i = 0; i < fileList.length; i++)],,testRecreate,672-672,[        final File[] fileList = dataDir.listFiles(new FileFilter()],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION,org/apache/poi/hpsf/basic/TestWrite.java,testWriteEmptyPropertySet,184-184,[        r.read(new FileInputStream(filename));],,testWriteEmptyPropertySet,185-185,[    }],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION,org/apache/poi/hpsf/basic/TestWrite.java,testWriteSimplePropertySet,245-245,[        r.read(new FileInputStream(filename));],,testWriteSimplePropertySet,246-246,[        Assert.assertNotNull(psa[0]);],,testWriteSimplePropertySet,247-247,[        Assert.assertTrue(psa[0].isSummaryInformation());],,testWriteSimplePropertySet,249-249,[        final Section s = (Section) (psa[0].getSections().get(0));],,testWriteSimplePropertySet,250-250,[        Object p1 = s.getProperty(PropertyIDMap.PID_AUTHOR);],,testWriteSimplePropertySet,251-251,[        Object p2 = s.getProperty(PropertyIDMap.PID_TITLE);],,testWriteSimplePropertySet,252-252,[        Assert.assertEquals(AUTHOR, p1);],,testWriteSimplePropertySet,253-253,[        Assert.assertEquals(TITLE, p2);],,testWriteSimplePropertySet,254-254,[    }],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION,org/apache/poi/hpsf/basic/TestWrite.java,testWriteTwoSections,322-322,[        r.read(new FileInputStream(filename));],,testWriteTwoSections,323-323,[        Assert.assertNotNull(psa[0]);],,testWriteTwoSections,324-324,[        Section s = (Section) (psa[0].getSections().get(0));],,testWriteTwoSections,325-325,[        assertEquals(s.getFormatID(), formatID);],,testWriteTwoSections,326-326,[        Object p = s.getProperty(2);],,testWriteTwoSections,327-327,[        Assert.assertEquals(SECTION1, p);],,testWriteTwoSections,328-328,[        s = (Section) (psa[0].getSections().get(1));],,testWriteTwoSections,329-329,[        p = s.getProperty(2);],,testWriteTwoSections,330-330,[        Assert.assertEquals(SECTION2, p);],,testWriteTwoSections,331-331,[    }],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/poi/hpsf/basic/TestWrite.java,testDictionary,758-758,[            final OutputStream out = new FileOutputStream(copy);],,testDictionary,759-759,[            final POIFSFileSystem poiFs = new POIFSFileSystem();],,testDictionary,760-760,[            final MutablePropertySet ps1 = new MutablePropertySet();],,testDictionary,761-761,[            final MutableSection s = (MutableSection) ps1.getSections().get(0);],,testDictionary,762-762,[            final Map m = new HashMap(3, 1.0f);],,testDictionary,763-763,[            m.put(Long.valueOf(1), "String 1");],,testDictionary,764-764,[            m.put(Long.valueOf(2), "String 2");],,testDictionary,765-765,[            m.put(Long.valueOf(3), "String 3");],,testDictionary,766-766,[            s.setDictionary(m);],,testDictionary,767-767,[            s.setFormatID(SectionIDMap.DOCUMENT_SUMMARY_INFORMATION_ID[0]);],,testDictionary,768-768,[            int codepage = Constants.CP_UNICODE;],,testDictionary,769-769,[            s.setProperty(PropertyIDMap.PID_CODEPAGE, Variant.VT_I2,],,testDictionary,770-770,[                          Integer.valueOf(codepage));],,testDictionary,771-771,[            poiFs.createDocument(ps1.toInputStream(), "Test");],,testDictionary,790-790,[        catch (Exception ex)],,testDictionary,792-792,[            handle(ex);],,testDictionary,794-794,[    }],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/poi/hpsf/basic/TestWrite.java,testDictionaryWithInvalidCodepage,810-810,[            final OutputStream out = new FileOutputStream(copy);],,testDictionaryWithInvalidCodepage,811-811,[            final POIFSFileSystem poiFs = new POIFSFileSystem();],,testDictionaryWithInvalidCodepage,812-812,[            final MutablePropertySet ps1 = new MutablePropertySet();],,testDictionaryWithInvalidCodepage,813-813,[            final MutableSection s = (MutableSection) ps1.getSections().get(0);],,testDictionaryWithInvalidCodepage,814-814,[            final Map m = new HashMap(3, 1.0f);],,testDictionaryWithInvalidCodepage,815-815,[            m.put(Long.valueOf(1), "String 1");],,testDictionaryWithInvalidCodepage,816-816,[            m.put(Long.valueOf(2), "String 2");],,testDictionaryWithInvalidCodepage,817-817,[            m.put(Long.valueOf(3), "String 3");],,testDictionaryWithInvalidCodepage,818-818,[            s.setDictionary(m);],,testDictionaryWithInvalidCodepage,819-819,[            s.setFormatID(SectionIDMap.DOCUMENT_SUMMARY_INFORMATION_ID[0]);],,testDictionaryWithInvalidCodepage,820-820,[            int codepage = 12345;],,testDictionaryWithInvalidCodepage,821-821,[            s.setProperty(PropertyIDMap.PID_CODEPAGE, Variant.VT_I2,],,testDictionaryWithInvalidCodepage,822-822,[                          Integer.valueOf(codepage));],,testDictionaryWithInvalidCodepage,823-823,[            poiFs.createDocument(ps1.toInputStream(), "Test");],,testDictionaryWithInvalidCodepage,832-832,[        catch (Exception ex)],,testDictionaryWithInvalidCodepage,834-834,[            handle(ex);],,testDictionaryWithInvalidCodepage,836-836,[    }],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/poi/hpsf/basic/TestWrite.java,testRecreate,702-702,[            final OutputStream out = new FileOutputStream(copy);],,testRecreate,703-703,[            final POIFSFileSystem poiFs = new POIFSFileSystem();],,testRecreate,704-704,[            for (int i = 0; i < psf1.length; i++)],,testRecreate,706-706,[                final InputStream in =],,testRecreate,707-707,[                    new ByteArrayInputStream(psf1[i].getBytes());],,testRecreate,708-708,[                final PropertySet psIn = PropertySetFactory.create(in);],,testRecreate,739-739,[        catch (Exception ex)],,testRecreate,741-741,[            handle(ex);],,testRecreate,743-743,[    }],,
STYLE,REC_CATCH_EXCEPTION,org/apache/poi/hpsf/basic/TestWrite.java,testDictionary,790-790,[        catch (Exception ex)],,
STYLE,REC_CATCH_EXCEPTION,org/apache/poi/hpsf/basic/TestWrite.java,testNoFormatID,137-137,[        catch (Exception ex)],,
STYLE,REC_CATCH_EXCEPTION,org/apache/poi/hpsf/basic/TestWrite.java,testRecreate,739-739,[        catch (Exception ex)],,
STYLE,REC_CATCH_EXCEPTION,org/apache/poi/hpsf/basic/TestWrite.java,testVariantTypes,429-429,[        catch (Exception ex)],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/poi/hpsf/basic/TestWrite.java,,229-241,[            {,                 public void processPOIFSReaderEvent,                     (final POIFSReaderEvent event),                 {,                     try,                     {,                         psa[0] = PropertySetFactory.create(event.getStream());,                     },                     catch (Exception ex),                     {,                         fail(org.apache.poi.hpsf.Util.toString(ex));,                     },                 }],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/poi/hpsf/basic/TestWrite.java,,303-319,[            {,                 public void processPOIFSReaderEvent,                     (final POIFSReaderEvent event),                 {,                     try,                     {,                         psa[0] = PropertySetFactory.create(event.getStream());,                     },                     catch (Exception ex),                     {,                         ex.printStackTrace();,                         throw new RuntimeException(ex.toString());,                         /* FIXME (2): Replace the previous line by the following,                          * one once we no longer need JDK 1.3 compatibility. */,                         // throw new RuntimeException(ex);,                     },                 }],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/poi/hpsf/basic/TestWrite.java,,673-676,[            {,                 public boolean accept(final File f),                 {,                     return f.getName().startsWith("Test");],,
PERFORMANCE,DM_FP_NUMBER_CTOR,org/apache/poi/hpsf/basic/TestWriteWellKnown.java,testWriteWellKnown,284-284,[        final Double POSITIVE_DOUBLE = new  Double(4444);],,testWriteWellKnown,287-287,[        final Double NEGATIVE_DOUBLE = new  Double(4444);],,testWriteWellKnown,293-293,[        final Double MAX_DOUBLE = new Double(Double.MAX_VALUE);],,testWriteWellKnown,294-294,[        final Double MIN_DOUBLE = new Double(Double.MIN_VALUE);],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/poi/hpsf/basic/TestWriteWellKnown.java,testWriteWellKnown,282-282,[        final Integer POSITIVE_INTEGER = new Integer(2222);],,testWriteWellKnown,285-285,[        final Integer NEGATIVE_INTEGER = new Integer(2222);],,testWriteWellKnown,289-289,[        final Integer MAX_INTEGER = new Integer(Integer.MAX_VALUE);],,testWriteWellKnown,290-290,[        final Integer MIN_INTEGER = new Integer(Integer.MIN_VALUE);],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/poi/hpsf/basic/TestWriteWellKnown.java,testWriteWellKnown,283-283,[        final Long POSITIVE_LONG = new  Long(3333);],,testWriteWellKnown,286-286,[        final Long NEGATIVE_LONG = new  Long(3333);],,testWriteWellKnown,291-291,[        final Long MAX_LONG = new Long(Long.MAX_VALUE);],,testWriteWellKnown,292-292,[        final Long MIN_LONG = new Long(Long.MIN_VALUE);],,
STYLE,ICAST_INTEGER_MULTIPLY_CAST_TO_LONG,org/apache/poi/hpsf/basic/TestWriteWellKnown.java,testWriteWellKnown,251-251,[        final long   P_EDIT_TIME = ++nr * 1000 * 10;],,
STYLE,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,org/apache/poi/hpsf/basic/TestWriteWellKnown.java,testReadCustomPropertiesFromFiles,652-652,[        for (int i = 0; i < docs.length; i++)],,testReadCustomPropertiesFromFiles,644-644,[        final File[] docs = dataDir.listFiles(new FileFilter()],,
STYLE,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,org/apache/poi/hpsf/basic/TestWriteWellKnown.java,testReadDocumentSummaryInformation,101-101,[        for (int i = 0; i < docs.length; i++)],,testReadDocumentSummaryInformation,95-95,[        final File[] docs = dataDir.listFiles(new FileFilter()],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/poi/hpsf/basic/TestWriteWellKnown.java,testWriteWellKnown,380-380,[        OutputStream out = new FileOutputStream(doc2);],,testWriteWellKnown,381-381,[        poifs.writeFilesystem(out);],,
STYLE,RV_RETURN_VALUE_IGNORED_NO_SIDE_EFFECT,org/apache/poi/hpsf/basic/TestWriteWellKnown.java,testReadDocumentSummaryInformation,133-133,[                dsi.getByteOrder();],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/poi/hpsf/basic/TestWriteWellKnown.java,,96-99,[        {,             public boolean accept(final File file),             {,                 return file.isFile() && file.getName().startsWith("Test");],,
STYLE,RV_RETURN_VALUE_IGNORED_NO_SIDE_EFFECT,org/apache/poi/hpsf/basic/TestWriteWellKnown.java,runTest,636-636,[                    cp.getName();],,
STYLE,RV_RETURN_VALUE_IGNORED_NO_SIDE_EFFECT,org/apache/poi/hpsf/basic/TestWriteWellKnown.java,runTest,637-637,[                    cp.getValue();],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/poi/hpsf/basic/TestWriteWellKnown.java,,591-639,[        {,             public void runTest(final File file) throws FileNotFoundException,,                     IOException, NoPropertySetStreamException,,                     MarkUnsupportedException,,                     UnexpectedPropertySetTypeException,             {,                 /* Read a test document <em>doc</em> into a POI filesystem. */,                 final POIFSFileSystem poifs = new POIFSFileSystem(new FileInputStream(file));,                 final DirectoryEntry dir = poifs.getRoot();,                 DocumentEntry dsiEntry = null;,                 try,                 {,                     dsiEntry = (DocumentEntry) dir.getEntry(DocumentSummaryInformation.DEFAULT_STREAM_NAME);,                 },                 catch (FileNotFoundException ex),                 {,                     /*,                      * A missing document summary information stream is not an error,                      * and therefore silently ignored here.,                      */,                 }, ,                 /*,                  * If there is a document summry information stream, read it from,                  * the POI filesystem, else create a new one.,                  */,                 DocumentSummaryInformation dsi;,                 if (dsiEntry != null),                 {,                     final DocumentInputStream dis = new DocumentInputStream(dsiEntry);,                     final PropertySet ps = new PropertySet(dis);,                     dsi = new DocumentSummaryInformation(ps);,                 },                 else,                     dsi = PropertySetFactory.newDocumentSummaryInformation();,                 final CustomProperties cps = dsi.getCustomProperties();, ,                 if (cps == null),                     /* The document does not have custom properties. */,                     return;, ,                 for (final Iterator i = cps.entrySet().iterator(); i.hasNext();),                 {,                     final Map.Entry e = (Entry) i.next();,                     final CustomProperty cp = (CustomProperty) e.getValue();,                     cp.getName();,                     cp.getValue();,                 },             }],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/poi/hpsf/basic/TestWriteWellKnown.java,,645-648,[        {,             public boolean accept(final File file),             {,                 return file.isFile() && file.getName().startsWith("Test");],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION,org/apache/poi/hpsf/basic/Util.java,readPOIFiles,170-170,[        r.read(new FileInputStream(poiFs));],,readPOIFiles,171-171,[        POIFile[] result = new POIFile[files.size()];],,readPOIFiles,172-172,[        for (int i = 0; i < result.length; i++)],,readPOIFiles,174-174,[        return result;],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION,org/apache/poi/hpsf/basic/Util.java,readPropertySets,232-232,[        r.read(new FileInputStream(poiFs));],,readPropertySets,233-233,[        POIFile[] result = new POIFile[files.size()];],,readPropertySets,234-234,[        for (int i = 0; i < result.length; i++)],,readPropertySets,236-236,[        return result;],,
STYLE,REC_CATCH_EXCEPTION,org/apache/poi/hpsf/basic/Util.java,processPOIFSReaderEvent,220-220,[                catch (Exception ex)],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/poi/hpsf/examples/CopyCompare.java,equal,228-228,[                msg.append("Document \"" + e2 + "\" exitsts, document \"" +],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/poi/hpsf/examples/CopyCompare.java,equal,197-197,[                msg.append("Document \"" + e1 + "\" exists, document \"" +],,
CORRECTNESS,NP_NULL_PARAM_DEREF,org/apache/poi/hpsf/examples/CopyCompare.java,copy,366-366,[                    copy(poiFs, path, name, ps);],,copy,353-353,[                    PropertySet ps = null;],,copy,358-358,[                    catch (NoPropertySetStreamException ex)],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/poi/hpsf/examples/ModifyDocumentSummaryInformation.java,main,171-171,[        customProperties.put("Sample Number", new Integer(12345));],,
CORRECTNESS,NP_NULL_ON_SOME_PATH_EXCEPTION,org/apache/poi/hpsf/examples/WriteAuthorAndTitle.java,processPOIFSReaderEvent,191-191,[                    if (ps.isSummaryInformation())],,processPOIFSReaderEvent,177-177,[                    PropertySet ps = null;],,processPOIFSReaderEvent,182-182,[                    catch (NoPropertySetStreamException ex)],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION,org/apache/poi/hpsf/examples/WriteTitle.java,main,103-103,[        poiFs.writeFilesystem(new FileOutputStream(fileName));],,main,104-104,[    }],,
I18N,DM_DEFAULT_ENCODING,org/apache/poi/hpsf/extractor/HPSFPropertiesExtractor.java,getPropertyValueText,127-127,[			return new String(b);],,
MT_CORRECTNESS,LI_LAZY_INIT_STATIC,org/apache/poi/hpsf/wellknown/PropertyIDMap.java,getDocumentSummaryInformationProperties,355-376,[        if (documentSummaryInformationProperties == null),         {,             PropertyIDMap m = new PropertyIDMap(17, (float) 1.0);,             m.put(PID_DICTIONARY, "PID_DICTIONARY");,             m.put(PID_CODEPAGE, "PID_CODEPAGE");,             m.put(PID_CATEGORY, "PID_CATEGORY");,             m.put(PID_PRESFORMAT, "PID_PRESFORMAT");,             m.put(PID_BYTECOUNT, "PID_BYTECOUNT");,             m.put(PID_LINECOUNT, "PID_LINECOUNT");,             m.put(PID_PARCOUNT, "PID_PARCOUNT");,             m.put(PID_SLIDECOUNT, "PID_SLIDECOUNT");,             m.put(PID_NOTECOUNT, "PID_NOTECOUNT");,             m.put(PID_HIDDENCOUNT, "PID_HIDDENCOUNT");,             m.put(PID_MMCLIPCOUNT, "PID_MMCLIPCOUNT");,             m.put(PID_SCALE, "PID_SCALE");,             m.put(PID_HEADINGPAIR, "PID_HEADINGPAIR");,             m.put(PID_DOCPARTS, "PID_DOCPARTS");,             m.put(PID_MANAGER, "PID_MANAGER");,             m.put(PID_COMPANY, "PID_COMPANY");,             m.put(PID_LINKSDIRTY, "PID_LINKSDIRTY");,             documentSummaryInformationProperties =,                 new PropertyIDMap(Collections.unmodifiableMap(m));],,
MT_CORRECTNESS,LI_LAZY_INIT_STATIC,org/apache/poi/hpsf/wellknown/PropertyIDMap.java,getSummaryInformationProperties,318-340,[        if (summaryInformationProperties == null),         {,             PropertyIDMap m = new PropertyIDMap(18, (float) 1.0);,             m.put(PID_TITLE, "PID_TITLE");,             m.put(PID_SUBJECT, "PID_SUBJECT");,             m.put(PID_AUTHOR, "PID_AUTHOR");,             m.put(PID_KEYWORDS, "PID_KEYWORDS");,             m.put(PID_COMMENTS, "PID_COMMENTS");,             m.put(PID_TEMPLATE, "PID_TEMPLATE");,             m.put(PID_LASTAUTHOR, "PID_LASTAUTHOR");,             m.put(PID_REVNUMBER, "PID_REVNUMBER");,             m.put(PID_EDITTIME, "PID_EDITTIME");,             m.put(PID_LASTPRINTED, "PID_LASTPRINTED");,             m.put(PID_CREATE_DTM, "PID_CREATE_DTM");,             m.put(PID_LASTSAVE_DTM, "PID_LASTSAVE_DTM");,             m.put(PID_PAGECOUNT, "PID_PAGECOUNT");,             m.put(PID_WORDCOUNT, "PID_WORDCOUNT");,             m.put(PID_CHARCOUNT, "PID_CHARCOUNT");,             m.put(PID_THUMBNAIL, "PID_THUMBNAIL");,             m.put(PID_APPNAME, "PID_APPNAME");,             m.put(PID_SECURITY, "PID_SECURITY");,             summaryInformationProperties =,                 new PropertyIDMap(Collections.unmodifiableMap(m));],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/poi/hpsf/wellknown/PropertyIDMap.java,,264-394,[        super(initialCapacity, loadFactor);,     }, , , ,     /**,      * <p>Creates a {@link PropertyIDMap} backed by another map.</p>,      *,      * @param map The instance to be created is backed by this map.,      */,     public PropertyIDMap(final Map map),     {,         super(map);,     }, , , ,     /**,      * <p>Puts a ID string for an ID into the {@link,      * PropertyIDMap}.</p>,      *,      * @param id The ID.,      * @param idString The ID string.,      * @return As specified by the {@link java.util.Map} interface, this method,      * returns the previous value associated with the specified,      * <var>id</var>, or <code>null</code> if there was no mapping for,      * key.,      */,     public Object put(final long id, final String idString),     {,         return put(Long.valueOf(id), idString);,     }, , , ,     /**,      * <p>Gets the ID string for an ID from the {@link,      * PropertyIDMap}.</p>,      *,      * @param id The ID.,      * @return The ID string associated with <var>id</var>.,      */,     public Object get(final long id),     {,         return get(Long.valueOf(id));,     }, , , ,     /**,      * @return the Summary Information properties singleton,      */,     public static PropertyIDMap getSummaryInformationProperties(),     {,         if (summaryInformationProperties == null),         {,             PropertyIDMap m = new PropertyIDMap(18, (float) 1.0);,             m.put(PID_TITLE, "PID_TITLE");,             m.put(PID_SUBJECT, "PID_SUBJECT");,             m.put(PID_AUTHOR, "PID_AUTHOR");,             m.put(PID_KEYWORDS, "PID_KEYWORDS");,             m.put(PID_COMMENTS, "PID_COMMENTS");,             m.put(PID_TEMPLATE, "PID_TEMPLATE");,             m.put(PID_LASTAUTHOR, "PID_LASTAUTHOR");,             m.put(PID_REVNUMBER, "PID_REVNUMBER");,             m.put(PID_EDITTIME, "PID_EDITTIME");,             m.put(PID_LASTPRINTED, "PID_LASTPRINTED");,             m.put(PID_CREATE_DTM, "PID_CREATE_DTM");,             m.put(PID_LASTSAVE_DTM, "PID_LASTSAVE_DTM");,             m.put(PID_PAGECOUNT, "PID_PAGECOUNT");,             m.put(PID_WORDCOUNT, "PID_WORDCOUNT");,             m.put(PID_CHARCOUNT, "PID_CHARCOUNT");,             m.put(PID_THUMBNAIL, "PID_THUMBNAIL");,             m.put(PID_APPNAME, "PID_APPNAME");,             m.put(PID_SECURITY, "PID_SECURITY");,             summaryInformationProperties =,                 new PropertyIDMap(Collections.unmodifiableMap(m));,         },         return summaryInformationProperties;,     }, , , ,     /**,      * <p>Returns the Document Summary Information properties,      * singleton.</p>,      *,      * @return The Document Summary Information properties singleton.,      */,     public static PropertyIDMap getDocumentSummaryInformationProperties(),     {,         if (documentSummaryInformationProperties == null),         {,             PropertyIDMap m = new PropertyIDMap(17, (float) 1.0);,             m.put(PID_DICTIONARY, "PID_DICTIONARY");,             m.put(PID_CODEPAGE, "PID_CODEPAGE");,             m.put(PID_CATEGORY, "PID_CATEGORY");,             m.put(PID_PRESFORMAT, "PID_PRESFORMAT");,             m.put(PID_BYTECOUNT, "PID_BYTECOUNT");,             m.put(PID_LINECOUNT, "PID_LINECOUNT");,             m.put(PID_PARCOUNT, "PID_PARCOUNT");,             m.put(PID_SLIDECOUNT, "PID_SLIDECOUNT");,             m.put(PID_NOTECOUNT, "PID_NOTECOUNT");,             m.put(PID_HIDDENCOUNT, "PID_HIDDENCOUNT");,             m.put(PID_MMCLIPCOUNT, "PID_MMCLIPCOUNT");,             m.put(PID_SCALE, "PID_SCALE");,             m.put(PID_HEADINGPAIR, "PID_HEADINGPAIR");,             m.put(PID_DOCPARTS, "PID_DOCPARTS");,             m.put(PID_MANAGER, "PID_MANAGER");,             m.put(PID_COMPANY, "PID_COMPANY");,             m.put(PID_LINKSDIRTY, "PID_LINKSDIRTY");,             documentSummaryInformationProperties =,                 new PropertyIDMap(Collections.unmodifiableMap(m));,         },         return documentSummaryInformationProperties;,     }, , , ,     /**,      * <p>For the most basic testing.</p>,      *,      * @param args The command-line arguments,      */,     public static void main(final String[] args),     {,         PropertyIDMap s1 = getSummaryInformationProperties();,         PropertyIDMap s2 = getDocumentSummaryInformationProperties();,         System.out.println("s1: " + s1);,         System.out.println("s2: " + s2);,     }],,
I18N,DM_DEFAULT_ENCODING,org/apache/poi/hpsf/wellknown/SectionIDMap.java,get,144-144,[        return (PropertyIDMap) super.get(new String(sectionFormatID));],,
I18N,DM_DEFAULT_ENCODING,org/apache/poi/hpsf/wellknown/SectionIDMap.java,put,175-175,[        return super.put(new String(sectionFormatID), propertyIDMap);],,
MT_CORRECTNESS,LI_LAZY_INIT_STATIC,org/apache/poi/hpsf/wellknown/SectionIDMap.java,getInstance,93-100,[        if (defaultMap == null),         {,             final SectionIDMap m = new SectionIDMap();,             m.put(SUMMARY_INFORMATION_ID,,                   PropertyIDMap.getSummaryInformationProperties());,             m.put(DOCUMENT_SUMMARY_INFORMATION_ID[0],,                   PropertyIDMap.getDocumentSummaryInformationProperties());,             defaultMap = m;],,
MALICIOUS_CODE,MS_MUTABLE_ARRAY,org/apache/poi/hpsf/wellknown/SectionIDMap.java,,56-56,[    public static final byte[][] DOCUMENT_SUMMARY_INFORMATION_ID = new byte[][]],,
MALICIOUS_CODE,MS_MUTABLE_ARRAY,org/apache/poi/hpsf/wellknown/SectionIDMap.java,,44-44,[    public static final byte[] SUMMARY_INFORMATION_ID = new byte[]],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/poi/hpsf/wellknown/SectionIDMap.java,,39-194,[public class SectionIDMap extends HashMap {, ,     /**,      * <p>The SummaryInformation's section's format ID.</p>,      */,     public static final byte[] SUMMARY_INFORMATION_ID = new byte[],     {,         (byte) 0xF2, (byte) 0x9F, (byte) 0x85, (byte) 0xE0,,         (byte) 0x4F, (byte) 0xF9, (byte) 0x10, (byte) 0x68,,         (byte) 0xAB, (byte) 0x91, (byte) 0x08, (byte) 0x00,,         (byte) 0x2B, (byte) 0x27, (byte) 0xB3, (byte) 0xD9,     };, ,     /**,      * <p>The DocumentSummaryInformation's first and second sections' format,      * ID.</p>,      */,     public static final byte[][] DOCUMENT_SUMMARY_INFORMATION_ID = new byte[][],     {,         {,             (byte) 0xD5, (byte) 0xCD, (byte) 0xD5, (byte) 0x02,,             (byte) 0x2E, (byte) 0x9C, (byte) 0x10, (byte) 0x1B,,             (byte) 0x93, (byte) 0x97, (byte) 0x08, (byte) 0x00,,             (byte) 0x2B, (byte) 0x2C, (byte) 0xF9, (byte) 0xAE,         },,         {,             (byte) 0xD5, (byte) 0xCD, (byte) 0xD5, (byte) 0x05,,             (byte) 0x2E, (byte) 0x9C, (byte) 0x10, (byte) 0x1B,,             (byte) 0x93, (byte) 0x97, (byte) 0x08, (byte) 0x00,,             (byte) 0x2B, (byte) 0x2C, (byte) 0xF9, (byte) 0xAE,         },     };, ,     /**,      * <p>A property without a known name is described by this string.</p>,      */,     public static final String UNDEFINED = "[undefined]";, ,     /**,      * <p>The default section ID map. It maps section format IDs to,      * {@link PropertyIDMap}s.</p>,      */,     private static SectionIDMap defaultMap;, , , ,     /**,      * <p>Returns the singleton instance of the default {@link,      * SectionIDMap}.</p>,      *,      * @return The instance value,      */,     public static SectionIDMap getInstance(),     {,         if (defaultMap == null),         {,             final SectionIDMap m = new SectionIDMap();,             m.put(SUMMARY_INFORMATION_ID,,                   PropertyIDMap.getSummaryInformationProperties());,             m.put(DOCUMENT_SUMMARY_INFORMATION_ID[0],,                   PropertyIDMap.getDocumentSummaryInformationProperties());,             defaultMap = m;,         },         return defaultMap;,     }, , , ,     /**,      * <p>Returns the property ID string that is associated with a,      * given property ID in a section format ID's namespace.</p>,      *,      * @param sectionFormatID Each section format ID has its own name,      * space of property ID strings and thus must be specified.,      * @param  pid The property ID,      * @return The well-known property ID string associated with the,      * property ID <var>pid</var> in the name space spanned by <var>,      * sectionFormatID</var> . If the <var>pid</var>,      * /<var>sectionFormatID </var> combination is not well-known, the,      * string "[undefined]" is returned.,      */,     public static String getPIDString(final byte[] sectionFormatID,,                                       final long pid),     {,         final PropertyIDMap m = getInstance().get(sectionFormatID);,         if (m == null) {,             return UNDEFINED;,         },         final String s = (String) m.get(pid);,         if (s == null),             return UNDEFINED;,         return s;,     }, , , ,     /**,      * <p>Returns the {@link PropertyIDMap} for a given section format,      * ID.</p>,      *,      * @param sectionFormatID the section format ID,      * @return the property ID map,      */,     public PropertyIDMap get(final byte[] sectionFormatID),     {,         return (PropertyIDMap) super.get(new String(sectionFormatID));,     }, , , ,     /**,      * <p>Returns the {@link PropertyIDMap} for a given section format,      * ID.</p>,      *,      * @param sectionFormatID A section format ID as a <tt>byte[]</tt> .,      * @deprecated Use {@link #get(byte[])} instead!,      * @return the property ID map,      */,     public Object get(final Object sectionFormatID),     {,         return get((byte[]) sectionFormatID);,     }, , , ,     /**,      * <p>Associates a section format ID with a {@link,      * PropertyIDMap}.</p>,      *,      * @param sectionFormatID the section format ID,      * @param propertyIDMap the property ID map,      * @return as defined by {@link java.util.Map#put},      */,     public Object put(final byte[] sectionFormatID,,                       final PropertyIDMap propertyIDMap),     {,         return super.put(new String(sectionFormatID), propertyIDMap);,     }, , , ,     /**,      * @deprecated Use {@link #put(byte[], PropertyIDMap)} instead!,      *,      * @see #put(byte[], PropertyIDMap),      *,      * @param key This parameter remains undocumented since the method is,      * deprecated.,      * @param value This parameter remains undocumented since the method is,      * deprecated.,      * @return The return value remains undocumented since the method is,      * deprecated.,      */,     public Object put(final Object key, final Object value),     {,         return put((byte[]) key, (PropertyIDMap) value);],,
BAD_PRACTICE,RR_NOT_CHECKED,org/apache/poi/hslf/HSLFSlideShow.java,readPictures,336-336,[			is.read(pictstream);],,
BAD_PRACTICE,RR_NOT_CHECKED,org/apache/poi/hslf/HSLFSlideShow.java,readPowerPointStream,222-222,[		directory.createDocumentInputStream("PowerPoint Document").read(_docstream);],,
STYLE,UC_USELESS_CONDITION,org/apache/poi/hslf/HSLFSlideShow.java,readPictures,372-372,[				logger.log(POILogger.ERROR, "Problem reading picture: Invalid image type 0, on picture with length " + imgsize + ".\nYou document will probably become corrupted if you save it!");],,readPictures,371-371,[			if(type == 0) {],,
PERFORMANCE,WMI_WRONG_MAP_ITERATOR,org/apache/poi/hslf/HSLFSlideShow.java,read,279-279,[                Integer offset = entries.get(id);],,
BAD_PRACTICE,RR_NOT_CHECKED,org/apache/poi/hslf/TestReWrite.java,assertSlideShowWritesOutTheSame,155-155,[		pfs.createDocumentInputStream("PowerPoint Document").read(_oData);],,assertSlideShowWritesOutTheSame,156-156,[		npfs.createDocumentInputStream("PowerPoint Document").read(_nData);],,
BAD_PRACTICE,RR_NOT_CHECKED,org/apache/poi/hslf/TestReWrite.java,assertWritesOutTheSame,84-84,[		pfs.createDocumentInputStream("PowerPoint Document").read(_oData);],,assertWritesOutTheSame,85-85,[		npfs.createDocumentInputStream("PowerPoint Document").read(_nData);],,
STYLE,RV_RETURN_VALUE_IGNORED_NO_SIDE_EFFECT,org/apache/poi/hslf/TestReWrite.java,assertSlideShowWritesOutTheSame,135-135,[    	ss.getNotes();],,
STYLE,RV_RETURN_VALUE_IGNORED_NO_SIDE_EFFECT,org/apache/poi/hslf/TestReWrite.java,assertSlideShowWritesOutTheSame,134-134,[    	ss.getSlides();],,
BAD_PRACTICE,SR_NOT_CHECKED,org/apache/poi/hslf/blip/EMF.java,getData,48-48,[            is.skip(header.getSize() + CHECKSUM_SIZE);],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/poi/hslf/blip/Metafile.java,,89-89,[            compression = LittleEndian.getUnsignedByte(data, pos); pos++;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/poi/hslf/blip/Metafile.java,write,98-98,[            LittleEndian.putInt(header, pos, bounds.x); pos += LittleEndian.INT_SIZE; //left],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/poi/hslf/blip/WMF.java,getData,50-50,[            aldus.left = header.bounds.x;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/poi/hslf/blip/Metafile.java,write,102-102,[            LittleEndian.putInt(header, pos, size.width); pos += LittleEndian.INT_SIZE; //inch],,
BAD_PRACTICE,SR_NOT_CHECKED,org/apache/poi/hslf/blip/WMF.java,getData,47-47,[            is.skip(header.getSize() + CHECKSUM_SIZE);],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/poi/hslf/blip/WMF.java,,137-137,[            handle = LittleEndian.getUShort(data, pos); pos += LittleEndian.SHORT_SIZE;],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/poi/hslf/blip/WMF.java,,144-144,[            reserved = LittleEndian.getInt(data, pos); pos += LittleEndian.INT_SIZE;],,
I18N,DM_DEFAULT_ENCODING,org/apache/poi/hslf/dev/PPTXMLDump.java,main,194-194,[                    FileWriter out = new FileWriter(ppt.getName() + ".xml");],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/poi/hslf/dev/PPTXMLDump.java,,36-36,[    public static String CR = System.getProperty("line.separator");],,
BAD_PRACTICE,RR_NOT_CHECKED,org/apache/poi/hslf/dev/PPTXMLDump.java,<init>,52-52,[        is.read(docstream);],,<init>,58-58,[            is.read(pictstream);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/poi/hslf/dev/PPTXMLDump.java,dump,115-115,[                out.write(" header=\"");],,dump,119-119,[            out.write(">" + CR);],,
I18N,DM_CONVERT_CASE,org/apache/poi/hslf/dev/SlideShowDumper.java,makeHex,202-202,[	String hex = Integer.toHexString(i).toUpperCase();],,
I18N,DM_CONVERT_CASE,org/apache/poi/hslf/dev/SlideShowDumper.java,makeHex,197-197,[	String hex = Integer.toHexString(s).toUpperCase();],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/poi/hslf/dev/SlideShowDumper.java,walkEscherBasic,362-362,[	if(typeName != null) {],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/poi/hslf/dev/SlideShowDumper.java,walkTree,229-229,[		if(recordName != null) {],,
BAD_PRACTICE,RR_NOT_CHECKED,org/apache/poi/hslf/dev/SlideShowDumper.java,<init>,129-129,[	filesystem.createDocumentInputStream("PowerPoint Document").read(_docstream);],,
PERFORMANCE,SBSC_USE_STRINGBUFFER_CONCATENATION,org/apache/poi/hslf/dev/SlideShowDumper.java,walkEscherBasic,352-352,[	for(int i=0; i<indent; i++) { ind += " "; }],,
PERFORMANCE,SBSC_USE_STRINGBUFFER_CONCATENATION,org/apache/poi/hslf/dev/SlideShowDumper.java,walkEscherDDF,273-273,[	for(int i=0; i<indent; i++) { ind += " "; }],,
PERFORMANCE,SBSC_USE_STRINGBUFFER_CONCATENATION,org/apache/poi/hslf/dev/SlideShowDumper.java,walkTree,219-219,[		for(int i=0; i<indent; i++) { ind += " "; }],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/poi/hslf/dev/SlideShowDumper.java,,121-121,[	this.filesystem = filesystem;],,
I18N,DM_CONVERT_CASE,org/apache/poi/hslf/dev/SlideShowRecordDumper.java,makeHex,116-116,[	String hex = Integer.toHexString(number).toUpperCase();],,
PERFORMANCE,SBSC_USE_STRINGBUFFER_CONCATENATION,org/apache/poi/hslf/dev/SlideShowRecordDumper.java,walkTree,232-232,[	for(int i=0; i<indent; i++) { ind += " "; }],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/poi/hslf/examples/ApacheconEU08.java,slide10,413-413,[        Object[] def = new Object[]{],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/poi/hslf/examples/ApacheconEU08.java,slide10,413-446,[        Object[] def = new Object[]{,             Color.yellow, new Integer(100),,             Color.green, new Integer(150),,             Color.gray, new Integer(75),,             Color.red, new Integer(200),,         };, ,         Slide slide = ppt.createSlide();, ,         ShapeGroup group = new ShapeGroup();,         //define position of the drawing in the slide,         Rectangle bounds = new java.awt.Rectangle(200, 100, 350, 300);,         group.setAnchor(bounds);,         slide.addShape(group);,         Graphics2D graphics = new PPGraphics2D(group);, ,         //draw a simple bar graph,         int x = bounds.x + 50, y = bounds.y + 50;,         graphics.setFont(new Font("Arial", Font.BOLD, 10));,         for (int i = 0, idx = 1; i < def.length; i+=2, idx++) {,             graphics.setColor(Color.black);,             int width = ((Integer)def[i+1]).intValue();,             graphics.drawString("Q" + idx, x-20, y+20);,             graphics.drawString(width + "%", x + width + 10, y + 20);,             graphics.setColor((Color)def[i]);,             graphics.fill(new Rectangle(x, y, width, 30));,             y += 40;,         },         graphics.setColor(Color.black);,         graphics.setFont(new Font("Arial", Font.BOLD, 14));,         graphics.draw(bounds);,         graphics.drawString("Performance", x + 70, y + 40);, ,     }],,<init>,849-851,[],,valueOf,830-832,[],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/poi/hslf/examples/Graphics2DDemo.java,main,41-41,[        Object[] def = new Object[]{],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/poi/hslf/extractor/PowerPointExtractor.java,getText,256-256,[				if (hf != null && hf.isFooterVisible() && hf.getFooterText() != null) {],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/poi/hslf/extractor/PowerPointExtractor.java,getText,300-300,[				if (hf != null && hf.isFooterVisible() && hf.getFooterText() != null) {],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/poi/hslf/extractor/PowerPointExtractor.java,getText,248-248,[				if (hf != null && hf.isHeaderVisible() && hf.getHeaderText() != null) {],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/poi/hslf/extractor/PowerPointExtractor.java,getText,292-292,[				if (hf != null && hf.isHeaderVisible() && hf.getHeaderText() != null) {],,
BAD_PRACTICE,RR_NOT_CHECKED,org/apache/poi/hslf/extractor/QuickButCruddyTextExtractor.java,<init>,108-108,[		fs.createDocumentInputStream("PowerPoint Document").read(pptContents);],,
I18N,DM_CONVERT_CASE,org/apache/poi/hslf/extractor/TestExtractor.java,testMasterText,313-313,[       assertContains(text.toLowerCase(), "master");],,
MALICIOUS_CODE,MS_FINAL_PKGPROTECT,org/apache/poi/hslf/model/AutoShapes.java,,63-63,[        shapes = new ShapeOutline[255];],,
STYLE,ICAST_IDIV_CAST_TO_DOUBLE,org/apache/poi/hslf/model/AutoShapes.java,getOutline,301-301,[                path.moveTo(0, adjval/2);],,getOutline,309-309,[                path.lineTo(21600, adjval/2);],,getOutline,311-311,[                path.moveTo(0, adjval/2);],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/poi/hslf/model/Freeform.java,,54-54,[    public static final byte[] SEGMENTINFO_CLOSE    = new byte[]{0x01, (byte)0x60};],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/poi/hslf/model/Freeform.java,,52-52,[    public static final byte[] SEGMENTINFO_CUBICTO  = new byte[]{0x00, (byte)0xAD};],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/poi/hslf/model/Freeform.java,,53-53,[    public static final byte[] SEGMENTINFO_CUBICTO2 = new byte[]{0x00, (byte)0xB3}; //OpenOffice inserts 0xB3 instead of 0xAD.],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/poi/hslf/model/Freeform.java,,50-50,[    public static final byte[] SEGMENTINFO_ESCAPE   = new byte[]{0x01, 0x00};],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/poi/hslf/model/Freeform.java,,51-51,[    public static final byte[] SEGMENTINFO_ESCAPE2  = new byte[]{0x01, 0x20};],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/poi/hslf/model/Freeform.java,,49-49,[    public static final byte[] SEGMENTINFO_LINETO   = new byte[]{0x00, (byte)0xAC};],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/poi/hslf/model/Freeform.java,,48-48,[    public static final byte[] SEGMENTINFO_MOVETO   = new byte[]{0x00, 0x40};],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/poi/hslf/model/Freeform.java,,55-55,[    public static final byte[] SEGMENTINFO_END      = new byte[]{0x00, (byte)0x80};],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/poi/hslf/model/Freeform.java,setPath,103-130,[            switch (type) {,                 case PathIterator.SEG_MOVETO:,                     pntInfo.add(new Point2D.Double(vals[0], vals[1]));,                     segInfo.add(SEGMENTINFO_MOVETO);,                     break;,                 case PathIterator.SEG_LINETO:,                     pntInfo.add(new Point2D.Double(vals[0], vals[1]));,                     segInfo.add(SEGMENTINFO_LINETO);,                     segInfo.add(SEGMENTINFO_ESCAPE);,                     break;,                 case PathIterator.SEG_CUBICTO:,                     pntInfo.add(new Point2D.Double(vals[0], vals[1]));,                     pntInfo.add(new Point2D.Double(vals[2], vals[3]));,                     pntInfo.add(new Point2D.Double(vals[4], vals[5]));,                     segInfo.add(SEGMENTINFO_CUBICTO);,                     segInfo.add(SEGMENTINFO_ESCAPE2);,                     break;,                 case PathIterator.SEG_QUADTO:,                     //TODO: figure out how to convert SEG_QUADTO into SEG_CUBICTO,                     logger.log(POILogger.WARN, "SEG_QUADTO is not supported");,                     break;,                 case PathIterator.SEG_CLOSE:,                     pntInfo.add(pntInfo.get(0));,                     segInfo.add(SEGMENTINFO_LINETO);,                     segInfo.add(SEGMENTINFO_ESCAPE);,                     segInfo.add(SEGMENTINFO_LINETO);,                     segInfo.add(SEGMENTINFO_CLOSE);,                     isClosed = true;],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/poi/hslf/model/Hyperlink.java,find,150-150,[            return null;],,
BAD_PRACTICE,NM_CONFUSING,org/apache/poi/hslf/model/OLEShape.java,getObjectID,73-73,[        return getEscherProperty(EscherProperties.BLIP__PICTUREID);],,getObjectId,109-109,[        return LittleEndian.getInt(_recdata, 0);],,
BAD_PRACTICE,NM_CONFUSING,org/apache/poi/hslf/model/OLEShape.java,getProgID,167-167,[        return getExEmbed().getProgId();],,getProgId,163-163,[        return progId == null ? null : progId.getText();],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/poi/hslf/model/ShapeFactory.java,,35-35,[    protected static POILogger logger = POILogFactory.getLogger(ShapeFactory.class);],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/poi/hslf/model/ShapePainter.java,,33-33,[    protected static POILogger logger = POILogFactory.getLogger(ShapePainter.class);],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/poi/hslf/model/ShapeTypes.java,,43-43,[        types = new HashMap();],,
BAD_PRACTICE,NM_SAME_SIMPLE_NAME_AS_INTERFACE,org/apache/poi/hslf/model/ShapeTypes.java,,30-55,[public final class ShapeTypes implements org.apache.poi.sl.usermodel.ShapeTypes {,     /**,      * Return name of the shape by id,      * @param type  - the id of the shape, one of the static constants defined in this class,      * @return  the name of the shape,      */,     public static String typeName(int type) {,         String name = (String)types.get(Integer.valueOf(type));,         return name;,     }, ,     public static HashMap types;,     static {,         types = new HashMap();,         try {,             Field[] f = org.apache.poi.sl.usermodel.ShapeTypes.class.getFields();,             for (int i = 0; i < f.length; i++){,                 Object val = f[i].get(null);,                 if (val instanceof Integer) {,                     types.put(val, f[i].getName());,                 },             },         } catch (IllegalAccessException e){,             throw new HSLFException("Failed to initialize shape types");,         },     }],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/poi/hslf/model/SimpleShape.java,setLineColor,131-131,[            setEscherProperty(opt, EscherProperties.LINESTYLE__NOLINEDRAWDASH, color == null ? 0x180010 : 0x180018);],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/poi/hslf/model/SimpleShape.java,setHyperlink,379-403,[        switch(link.getType()){,             case Hyperlink.LINK_FIRSTSLIDE:,                 infoAtom.setAction(InteractiveInfoAtom.ACTION_JUMP);,                 infoAtom.setJump(InteractiveInfoAtom.JUMP_FIRSTSLIDE);,                 infoAtom.setHyperlinkType(InteractiveInfoAtom.LINK_FirstSlide);,                 break;,             case Hyperlink.LINK_LASTSLIDE:,                 infoAtom.setAction(InteractiveInfoAtom.ACTION_JUMP);,                 infoAtom.setJump(InteractiveInfoAtom.JUMP_LASTSLIDE);,                 infoAtom.setHyperlinkType(InteractiveInfoAtom.LINK_LastSlide);,                 break;,             case Hyperlink.LINK_NEXTSLIDE:,                 infoAtom.setAction(InteractiveInfoAtom.ACTION_JUMP);,                 infoAtom.setJump(InteractiveInfoAtom.JUMP_NEXTSLIDE);,                 infoAtom.setHyperlinkType(InteractiveInfoAtom.LINK_NextSlide);,                 break;,             case Hyperlink.LINK_PREVIOUSSLIDE:,                 infoAtom.setAction(InteractiveInfoAtom.ACTION_JUMP);,                 infoAtom.setJump(InteractiveInfoAtom.JUMP_PREVIOUSSLIDE);,                 infoAtom.setHyperlinkType(InteractiveInfoAtom.LINK_PreviousSlide);,                 break;,             case Hyperlink.LINK_URL:,                 infoAtom.setAction(InteractiveInfoAtom.ACTION_HYPERLINK);,                 infoAtom.setJump(InteractiveInfoAtom.JUMP_NONE);,                 infoAtom.setHyperlinkType(InteractiveInfoAtom.LINK_Url);],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/poi/hslf/model/Slide.java,onCreate,155-161,[            switch(c.getRecordId()){,                 case EscherContainerRecord.SPGR_CONTAINER:,                     EscherContainerRecord dc = (EscherContainerRecord)c.getChild(0);,                     spr = dc.getChildById(EscherSpRecord.RECORD_ID);,                     break;,                 case EscherContainerRecord.SP_CONTAINER:,                     spr = c.getChildById(EscherSpRecord.RECORD_ID);],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/poi/hslf/model/Table.java,,153-159,[        Arrays.sort(sh, new Comparator(){,             public int compare( Object o1, Object o2 ) {,                 Rectangle anchor1 = ((Shape)o1).getAnchor();,                 Rectangle anchor2 = ((Shape)o2).getAnchor();,                 int delta = anchor1.y - anchor2.y;,                 if(delta == 0) delta = anchor1.x - anchor2.x;,                 return delta;],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/poi/hslf/model/TestSlideMaster.java,testIndentation,234-242,[                    switch (indent){,                         case 0:,                             assertEquals(32, rt[j].getFontSize());,                             break;,                         case 1:,                             assertEquals(28, rt[j].getFontSize());,                             break;,                         case 2:,                             assertEquals(24, rt[j].getFontSize());],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/poi/hslf/model/TestSlideMaster.java,testTitleMaster,115-126,[            switch(txt[i].getRunType()){,                 case TextHeaderAtom.CENTER_TITLE_TYPE:,                     assertEquals("Arial", rt.getFontName());,                     assertEquals(32, rt.getFontSize());,                     assertEquals(true, rt.isBold());,                     assertEquals(true, rt.isUnderlined());,                     break;,                 case TextHeaderAtom.CENTRE_BODY_TYPE:,                     assertEquals("Courier New", rt.getFontName());,                     assertEquals(20, rt.getFontSize());,                     assertEquals(true, rt.isBold());,                     assertEquals(false, rt.isUnderlined());],,
BAD_PRACTICE,RR_NOT_CHECKED,org/apache/poi/hslf/model/TestTextRunReWrite.java,testWritesOutTheSameNonRich,105-105,[		pfs.createDocumentInputStream("PowerPoint Document").read(_oData);],,testWritesOutTheSameNonRich,106-106,[		npfs.createDocumentInputStream("PowerPoint Document").read(_nData);],,
BAD_PRACTICE,RR_NOT_CHECKED,org/apache/poi/hslf/model/TestTextRunReWrite.java,testWritesOutTheSameRich,163-163,[		npfs.createDocumentInputStream("PowerPoint Document").read(_nData);],,
BAD_PRACTICE,RR_NOT_CHECKED,org/apache/poi/hslf/model/TestTextRunReWrite.java,testWritesOutTheSameRich,162-162,[		pfs.createDocumentInputStream("PowerPoint Document").read(_oData);],,
PERFORMANCE,DM_FP_NUMBER_CTOR,org/apache/poi/hslf/model/TextPainter.java,getAttributedString,80-80,[            at.addAttribute(TextAttribute.SIZE, new Float(rt[i].getFontSize()), start, end);],,
PERFORMANCE,DM_FP_NUMBER_CTOR,org/apache/poi/hslf/model/TextPainter.java,getTextElements,284-284,[                bat.addAttribute(TextAttribute.SIZE, new Float(fontSize));],,
STYLE,ICAST_IDIV_CAST_TO_DOUBLE,org/apache/poi/hslf/model/TextPainter.java,getTextElements,229-229,[                el.ascent = -linespacing*Shape.POINT_DPI/Shape.MASTER_DPI;],,getTextElements,245-245,[                    spaceBefore = -sp*Shape.POINT_DPI/Shape.MASTER_DPI;],,getTextElements,254-254,[                descent = -linespacing*Shape.POINT_DPI/Shape.MASTER_DPI;],,getTextElements,262-262,[                    spaceAfter = -sp*Shape.POINT_DPI/Shape.MASTER_DPI;],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/poi/hslf/model/TextPainter.java,getTextElements,156-156,[        if (run == null) return null;],,getTextElements,159-159,[        if (text == null || text.equals("")) return null;],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/poi/hslf/model/TextPainter.java,getTextElements,273-273,[                if (clr != null) bat.addAttribute(TextAttribute.FOREGROUND, clr);],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/poi/hslf/model/TextPainter.java,getTextElements,159-159,[        if (text == null || text.equals("")) return null;],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/poi/hslf/model/TextPainter.java,,237-237,[            el.textEndIndex = endIndex;],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/poi/hslf/model/TextPainter.java,,236-236,[            el.textStartIndex = startIndex;],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/poi/hslf/model/textproperties/BitMaskTextProp.java,,33-101,[	public String[] getSubPropNames() { return subPropNames; }, 	/** Fetch the list of if the sub properties match or not */, 	public boolean[] getSubPropMatches() { return subPropMatches; }, , 	public BitMaskTextProp(int sizeOfDataBlock, int maskInHeader, String overallName, String[] subPropNames) {, 		super(sizeOfDataBlock,maskInHeader,"bitmask");, 		this.subPropNames = subPropNames;, 		this.propName = overallName;, 		subPropMasks = new int[subPropNames.length];, 		subPropMatches = new boolean[subPropNames.length];, 		, 		// Initialise the masks list, 		for(int i=0; i<subPropMasks.length; i++) {, 			subPropMasks[i] = (1 << i);, 		}, 	}, 	, 	/**, 	 * As we're purely mask based, just set flags for stuff, 	 *  that is set, 	 */, 	public int getWriteMask() {, 		return dataValue;, 	}, 	, 	/**, 	 * Set the value of the text property, and recompute the sub, 	 *  properties based on it, 	 */, 	public void setValue(int val) { , 		dataValue = val;, , 		// Figure out the values of the sub properties, 		for(int i=0; i< subPropMatches.length; i++) {, 			subPropMatches[i] = false;, 			if((dataValue & subPropMasks[i]) != 0) {, 				subPropMatches[i] = true;, 			}, 		}, 	}, , 	/**, 	 * Fetch the true/false status of the subproperty with the given index, 	 */, 	public boolean getSubValue(int idx) {, 		return subPropMatches[idx];, 	}, , 	/**, 	 * Set the true/false status of the subproperty with the given index, 	 */, 	public void setSubValue(boolean value, int idx) {, 		if(subPropMatches[idx] == value) { return; }, 		if(value) {, 			dataValue += subPropMasks[idx];, 		} else {, 			dataValue -= subPropMasks[idx];, 		}, 		subPropMatches[idx] = value;, 	}, 	, 	public Object clone(){, 		BitMaskTextProp newObj = (BitMaskTextProp)super.clone();, 		, 		// Don't carry over matches, but keep everything , 		//  else as it was, 		newObj.subPropMatches = new boolean[subPropMatches.length];, 		, 		return newObj;],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/poi/hslf/model/textproperties/CharFlagsTextProp.java,,35-35,[    public static String NAME = "char_flags";],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/poi/hslf/model/textproperties/ParagraphFlagsTextProp.java,,31-31,[    public static String NAME = "paragraph_flags";],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/poi/hslf/record/Comment2000.java,findInterestingChildren,123-126,[                switch(recInstance){,                     case 0: authorRecord = cs; break;,                     case 1: commentRecord = cs; break;,                     case 2: authorInitialsRecord = cs; break;],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/poi/hslf/record/CurrentUserAtom.java,,43-43,[	public static final byte[] atomHeader = new byte[] { 0, 0, -10, 15 };],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/poi/hslf/record/CurrentUserAtom.java,,47-47,[	public static final byte[] encHeaderToken = new byte[] { -33, -60, -47, -13 };],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/poi/hslf/record/CurrentUserAtom.java,,45-45,[	public static final byte[] headerToken = new byte[] { 95, -64, -111, -29 };],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/poi/hslf/record/CurrentUserAtom.java,,49-49,[	public static final byte[] ppt97FileVer = new byte[] { 8, 00, -13, 03, 03, 00 };],,
BAD_PRACTICE,RR_NOT_CHECKED,org/apache/poi/hslf/record/CurrentUserAtom.java,<init>,123-123,[		in.read(_contents);],,
BAD_PRACTICE,NM_CONFUSING,org/apache/poi/hslf/record/ExControlAtom.java,getSlideId,79-79,[        return _id;],,getSlideID,43-43,[	public int getSlideID() { return slideID; }],,
BAD_PRACTICE,NM_CONFUSING,org/apache/poi/hslf/record/ExControlAtom.java,setSlideId,92-93,[        _id = id;,     }],,setSlideID,44-44,[	public void setSlideID(int id) { slideID = id; }],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/poi/hslf/record/ExEmbed.java,findInterestingChildren,112-115,[                switch(opts){,                     case 0x1: menuName = cs; break;,                     case 0x2: progId = cs; break;,                     case 0x3: clipboardName = cs; break;],,
BAD_PRACTICE,NM_CONFUSING,org/apache/poi/hslf/record/ExMediaAtom.java,setObjectId,118-119,[         LittleEndian.putInt(_recdata, 0, id);,     }],,setObjectID,85-86,[        field_cbo_id = cboID;,     }],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/poi/hslf/record/PPDrawing.java,getChildRecords,191-191,[	public Record[] getChildRecords() { return null; }],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/poi/hslf/record/PPDrawingGroup.java,getChildRecords,69-69,[        return null;],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/poi/hslf/record/RecordAtom.java,getChildRecords,36-36,[	public Record[] getChildRecords() { return null; }],,
MT_CORRECTNESS,DL_SYNCHRONIZATION_ON_BOOLEAN,org/apache/poi/hslf/record/RecordContainer.java,addChildAfter,176-176,[		synchronized(changingChildRecordsLock) {],,
MT_CORRECTNESS,DL_SYNCHRONIZATION_ON_BOOLEAN,org/apache/poi/hslf/record/RecordContainer.java,addChildAt,95-95,[		synchronized(changingChildRecordsLock) {],,
MT_CORRECTNESS,DL_SYNCHRONIZATION_ON_BOOLEAN,org/apache/poi/hslf/record/RecordContainer.java,addChildBefore,194-194,[		synchronized(changingChildRecordsLock) {],,
MT_CORRECTNESS,DL_SYNCHRONIZATION_ON_BOOLEAN,org/apache/poi/hslf/record/RecordContainer.java,appendChild,78-78,[		synchronized(changingChildRecordsLock) {],,
MT_CORRECTNESS,DL_SYNCHRONIZATION_ON_BOOLEAN,org/apache/poi/hslf/record/RecordContainer.java,appendChildRecord,165-165,[		synchronized(changingChildRecordsLock) {],,
MT_CORRECTNESS,DL_SYNCHRONIZATION_ON_BOOLEAN,org/apache/poi/hslf/record/RecordContainer.java,findChildLocation,63-63,[		synchronized(changingChildRecordsLock) {],,
MT_CORRECTNESS,DL_SYNCHRONIZATION_ON_BOOLEAN,org/apache/poi/hslf/record/RecordContainer.java,moveChildrenAfter,243-243,[		synchronized(changingChildRecordsLock) {],,
MT_CORRECTNESS,DL_SYNCHRONIZATION_ON_BOOLEAN,org/apache/poi/hslf/record/RecordContainer.java,moveChildrenBefore,219-219,[		synchronized(changingChildRecordsLock) {],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/poi/hslf/record/RecordTypes.java,,241-241,[		typeToClass = new HashMap<Integer,Class<? extends Record>>();],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/poi/hslf/record/RecordTypes.java,,240-240,[		typeToName = new HashMap<Integer,String>();],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/poi/hslf/record/SlideAtom.java,,204-231,[		public int getGeometryType() { return geometry; }, 		/** Set the geometry type */, 		public void setGeometryType(int geom) { geometry = geom; }, , 		/**, 		 * Create a new Embeded SSlideLayoutAtom, from 12 bytes of data, 		 */, 		public SSlideLayoutAtom(byte[] data) {, 			if(data.length != 12) {, 				throw new RuntimeException("SSlideLayoutAtom created with byte array not 12 bytes long - was " + data.length + " bytes in size");, 			}, , 			// Grab out our data, 			geometry = LittleEndian.getInt(data,0);, 			placeholderIDs = new byte[8];, 			System.arraycopy(data,4,placeholderIDs,0,8);, 		}, , 		/**, 		 * Write the contents of the record back, so it can be written, 		 *  to disk. Skips the record header, 		 */, 		public void writeOut(OutputStream out) throws IOException {, 			// Write the geometry, 			writeLittleEndian(geometry,out);, 			// Write the placeholder IDs, 			out.write(placeholderIDs);, 		}],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/poi/hslf/record/SlideListWithText.java,,189-197,[		public SlidePersistAtom getSlidePersistAtom() { return slidePersistAtom; }, 		/** Get the Text related records for this slide */, 		public Record[] getSlideRecords() { return slideRecords; }, , 		/** Create one to hold the Records for one Slide's text */, 		public SlideAtomsSet(SlidePersistAtom s, Record[] r) {, 			slidePersistAtom = s;, 			slideRecords = r;, 		}],,
MALICIOUS_CODE,MS_MUTABLE_ARRAY,org/apache/poi/hslf/record/StyleTextPropAtom.java,,144-144,[	public static TextProp[] characterTextPropTypes = new TextProp[] {],,
MALICIOUS_CODE,MS_MUTABLE_ARRAY,org/apache/poi/hslf/record/StyleTextPropAtom.java,,121-121,[	public static TextProp[] paragraphTextPropTypes = new TextProp[] {],,
BAD_PRACTICE,RR_NOT_CHECKED,org/apache/poi/hslf/record/TestCurrentUserAtom.java,testWriteNormal,90-90,[		in.read(contents);],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/poi/hslf/record/TextRulerAtom.java,read,117-150,[                switch (bits[i]){,                     case 0:,                         //defaultTabSize,                         defaultTabSize = LittleEndian.getShort(_data, pos); pos += 2;,                         break;,                     case 1:,                         //numLevels,                         numLevels = LittleEndian.getShort(_data, pos); pos += 2;,                         break;,                     case 2:,                         //tabStops,                         val = LittleEndian.getShort(_data, pos); pos += 2;,                         tabStops = new int[val*2];,                         for (int j = 0; j < tabStops.length; j++) {,                             tabStops[j] = LittleEndian.getUShort(_data, pos); pos += 2;,                         },                         break;,                     case 3:,                     case 4:,                     case 5:,                     case 6:,                     case 7:,                         //bullet.offset,                         val = LittleEndian.getShort(_data, pos); pos += 2;,                         bulletOffsets[bits[i]-3] = val;,                         break;,                     case 8:,                     case 9:,                     case 10:,                     case 11:,                     case 12:,                         //text.offset,                         val = LittleEndian.getShort(_data, pos); pos += 2;,                         textOffsets[bits[i]-8] = val;],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/poi/hslf/record/TextSpecInfoAtom.java,getTextSpecInfoRuns,127-135,[                    switch (bits[i]){,                         case 0:,                             run.spellInfo = LittleEndian.getShort(_data, pos); pos += 2;,                             break;,                         case 1:,                             run.langId = LittleEndian.getShort(_data, pos); pos += 2;,                             break;,                         case 2:,                             run.altLangId = LittleEndian.getShort(_data, pos); pos += 2;],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/poi/hslf/record/TextSpecInfoAtom.java,,155-155,[        protected short langId = -1;],,
MALICIOUS_CODE,MS_FINAL_PKGPROTECT,org/apache/poi/hslf/usermodel/PictureData.java,,80-80,[    protected static ImagePainter[] painters = new ImagePainter[8];],,
BAD_PRACTICE,NM_CONFUSING,org/apache/poi/hslf/usermodel/RichTextRun.java,isStrikethrough,424-424,[		return isCharFlagsTextPropVal(CharFlagsTextProp.STRIKETHROUGH_IDX);],,isStrikeThrough,186-186,[    return isFStrike();],,
CORRECTNESS,NP_NULL_PARAM_DEREF,org/apache/poi/hslf/usermodel/RichTextRun.java,fetchOrAddTextProp,343-343,[		TextProp tp = fetchOrAddTextProp(characterStyle, propName);],,fetchOrAddTextProp,338-338,[		if(characterStyle == null) {],,fetchOrAddTextProp,339-339,[			parentRun.ensureStyleAtomPresent();],,
CORRECTNESS,NP_NULL_PARAM_DEREF,org/apache/poi/hslf/usermodel/RichTextRun.java,fetchOrAddTextProp,328-328,[		TextProp tp = fetchOrAddTextProp(paragraphStyle, propName);],,fetchOrAddTextProp,323-323,[		if(paragraphStyle == null) {],,fetchOrAddTextProp,324-324,[			parentRun.ensureStyleAtomPresent();],,
BAD_PRACTICE,RR_NOT_CHECKED,org/apache/poi/hslf/usermodel/SlideShow.java,addPicture,858-858,[			is.read(data);],,
BAD_PRACTICE,DE_MIGHT_IGNORE,org/apache/poi/hslf/usermodel/TestAddingSlides.java,testRemoving,244-244,[        } catch (Exception e){],,
CORRECTNESS,RV_RETURN_VALUE_IGNORED,org/apache/poi/hslf/usermodel/TestBugs.java,test49648,404-404,[             text.replace("{txtTot}", "With \u0123\u1234\u5678 unicode");],,
STYLE,ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD,org/apache/poi/hslf/usermodel/TestRichTextRun.java,setUp,70-70,[		filenameC = "ParagraphStylesShorterThanCharStyles.ppt";],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/poi/hsmf/MAPIMessage.java,getHeaders,479-479,[         return null;],,
STYLE,UCF_USELESS_CONTROL_FLOW,org/apache/poi/hsmf/datatypes/AttachmentChunks.java,record,131-131,[      else if(chunk.getChunkId() == ATTACH_SIZE.id) {],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/poi/hsmf/datatypes/AttachmentChunks.java,,129-129,[         attachRenderingWMF = (ByteChunk)chunk;],,
BAD_PRACTICE,SE_COMPARATOR_SHOULD_BE_SERIALIZABLE,org/apache/poi/hsmf/datatypes/AttachmentChunks.java,,142-144,[   public static class AttachmentChunksSorter implements Comparator<AttachmentChunks> {,       public int compare(AttachmentChunks a, AttachmentChunks b) {,          return a.poifsName.compareTo(b.poifsName);],,
I18N,DM_CONVERT_CASE,org/apache/poi/hsmf/datatypes/Chunk.java,getEntryName,64-64,[		return this.namePrefix + chunkId.toUpperCase() + type.toUpperCase();],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/poi/hsmf/datatypes/Chunks.java,,117-117,[         emailFromChunk = (StringChunk)chunk;],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/poi/hsmf/datatypes/Chunks.java,,83-83,[         messageId = (StringChunk)chunk;],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/poi/hsmf/datatypes/Chunks.java,,90-90,[         sentByServerType = (StringChunk)chunk;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/poi/hsmf/datatypes/MessageSubmissionChunk.java,writeValue,98-98,[         byte[] data = rawId.getBytes("ASCII"); ],,
BAD_PRACTICE,SE_COMPARATOR_SHOULD_BE_SERIALIZABLE,org/apache/poi/hsmf/datatypes/RecipientChunks.java,,197-203,[   public static class RecipientChunksSorter implements Comparator<RecipientChunks> {,       public int compare(RecipientChunks a, RecipientChunks b) {,          if(a.recipientNumber < b.recipientNumber),             return -1;,          if(a.recipientNumber > b.recipientNumber),             return +1;,          return 0;],,
I18N,DM_CONVERT_CASE,org/apache/poi/hsmf/datatypes/Types.java,asFileEnding,72-72,[      String str = Integer.toHexString(type).toUpperCase();],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/poi/hsmf/dev/TypesLister.java,,36-38,[      Collections.sort(all, new Comparator<MAPIProperty>() {,          public int compare(MAPIProperty a, MAPIProperty b) {,             return a.name.compareTo(b.name);],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/poi/hsmf/dev/TypesLister.java,,45-49,[      Collections.sort(all, new Comparator<MAPIProperty>() {,          public int compare(MAPIProperty a, MAPIProperty b) {,             if(a.id < b.id) return -1;,             if(a.id > b.id) return +1;,             return 0;],,
I18N,DM_DEFAULT_ENCODING,org/apache/poi/hsmf/examples/Msg2txt.java,processMessage,68-68,[			txtOut = new PrintWriter(txtFileName);],,
I18N,DM_CONVERT_CASE,org/apache/poi/hsmf/extractor/OutlookTextExtactor.java,getText,126-126,[               if(header.toLowerCase().startsWith("date:")) {],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/poi/hsmf/parsers/POIFSChunkParser.java,process,155-166,[            switch(type) {,             case Types.BINARY:,                chunk = new ByteChunk(namePrefix, chunkId, type);,                break;,             case Types.DIRECTORY:,                if(entry instanceof DirectoryNode) {,                    chunk = new DirectoryChunk((DirectoryNode)entry, namePrefix, chunkId, type);,                },                break;,             case Types.ASCII_STRING:,             case Types.UNICODE_STRING:,                chunk = new StringChunk(namePrefix, chunkId, type);],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/poi/hssf/converter/AbstractExcelConverter.java,isTextEmpty,142-142,[                if ( style == null )],,
I18N,DM_DEFAULT_ENCODING,org/apache/poi/hssf/converter/ExcelToFoConverter.java,main,95-95,[            FileWriter out = new FileWriter( args[1] );],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/poi/hssf/converter/ExcelToFoConverter.java,processCell,240-240,[                if ( style == null )],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/poi/hssf/converter/ExcelToFoConverter.java,processCellStyleFont,423-429,[        switch ( font.getBoldweight() ),         {,         case HSSFFont.BOLDWEIGHT_BOLD:,             triplet.bold = true;,             break;,         case HSSFFont.BOLDWEIGHT_NORMAL:,             triplet.bold = false;],,
I18N,DM_DEFAULT_ENCODING,org/apache/poi/hssf/converter/ExcelToHtmlConverter.java,main,88-88,[            FileWriter out = new FileWriter( args[1] );],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/poi/hssf/converter/ExcelToHtmlConverter.java,processCell,320-320,[                if ( style == null )],,
BAD_PRACTICE,DE_MIGHT_IGNORE,org/apache/poi/hssf/converter/TestExcelConverterSuite.java,testFo,90-90,[        catch ( Exception exc )],,
BAD_PRACTICE,DE_MIGHT_IGNORE,org/apache/poi/hssf/converter/TestExcelConverterSuite.java,testHtml,120-120,[        catch ( Exception exc )],,
STYLE,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,org/apache/poi/hssf/converter/TestExcelConverterSuite.java,suite,55-55,[        for ( final File child : directory.listFiles( new FilenameFilter()],,
I18N,DM_DEFAULT_ENCODING,org/apache/poi/hssf/dev/BiffViewer.java,main,415-415,[				BiffRecordListener recListener = new BiffRecordListener(dumpHex ? new OutputStreamWriter(ps) : null, zeroAlignHexDump, cmdArgs.suppressHeader());],,
I18N,DM_DEFAULT_ENCODING,org/apache/poi/hssf/dev/BiffViewer.java,main,397-397,[				ps = new PrintStream(os);],,
STYLE,REC_CATCH_EXCEPTION,org/apache/poi/hssf/dev/BiffViewer.java,main,420-420,[		} catch (Exception e) {],,
BAD_PRACTICE,RR_NOT_CHECKED,org/apache/poi/hssf/dev/BiffViewer.java,main,409-409,[				is.read(data);],,
STYLE,UC_USELESS_CONDITION,org/apache/poi/hssf/dev/BiffViewer.java,createRecords,92-92,[				if (dumpInterpretedRecords) {],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/poi/hssf/dev/EFBiffViewer.java,,55-59,[        {,             public void processRecord(Record rec),             {,                 System.out.println(rec.toString());,             }],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/poi/hssf/dev/FormulaViewer.java,formulaString,165-173,[            switch (token.getPtgClass()) {,                 case Ptg.CLASS_REF :,                     buf.append("(R)");,                     break;,                 case Ptg.CLASS_VALUE :,                     buf.append("(V)");,                     break;,                 case Ptg.CLASS_ARRAY :,                     buf.append("(A)");],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/poi/hssf/dev/FormulaViewer.java,listFormula,102-110,[            switch (token.getPtgClass()) {,                 case Ptg.CLASS_REF :,                     buf.append("REF");,                     break;,                 case Ptg.CLASS_VALUE :,                     buf.append("VALUE");,                     break;,                 case Ptg.CLASS_ARRAY :,                     buf.append("ARRAY");],,listFormula,117-125,[                switch (token.getPtgClass()) {,                     case Ptg.CLASS_REF :,                         buf.append("REF");,                         break;,                     case Ptg.CLASS_VALUE :,                         buf.append("VALUE");,                         break;,                     case Ptg.CLASS_ARRAY :,                         buf.append("ARRAY");],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/poi/hssf/eventmodel/TestEventRecordFactory.java,,48-53,[        ERFListener listener = new ERFListener() {,             public boolean processRecord(Record rec) {,                 wascalled[0] = true;,                 assertTrue("must be BOFRecord got SID="+rec.getSid(),,                            (rec.getSid() == BOFRecord.sid));                  ,                 return true;              ],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/poi/hssf/eventmodel/TestEventRecordFactory.java,,149-172,[        ERFListener listener = new ERFListener() {,               private String[] expectedRecordTypes = {,                   UnknownRecord.class.getName(),,                   ContinueRecord.class.getName(),,                   ContinueRecord.class.getName(),               };,               public boolean processRecord(Record rec),               {,                   // System.out.println(rec.toString());,                   assertEquals(,                     "Record type",,                     expectedRecordTypes[recCnt[0]],,                     rec.getClass().getName(),                   );,                   compareData(rec, "Record " + recCnt[0] + ": ");,                   recCnt[0]++;,                   return true;,               },               private void compareData(Record record, String message) {,                   byte[] recData = record.serialize();,                   for (int i = 0; i < recData.length; i++) {,                       assertEquals(message + " data byte " + i, data[offset[0]++], recData[i]);,                   },               }],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/poi/hssf/eventusermodel/MissingRecordAwareHSSFListener.java,processRecord,78-127,[			switch (record.getSid()) {, 				// the BOFRecord can represent either the beginning of a sheet or, 				// the workbook, 				case BOFRecord.sid:, 					BOFRecord bof = (BOFRecord) record;, 					if (bof.getType() == bof.TYPE_WORKBOOK || bof.getType() == bof.TYPE_WORKSHEET) {, 						// Reset the row and column counts - new workbook / worksheet, 						resetCounts();, 					}, 					break;, 				case RowRecord.sid:, 					RowRecord rowrec = (RowRecord) record;, 					//System.out.println("Row " + rowrec.getRowNumber() + " found, first column at ", 					//        + rowrec.getFirstCol() + " last column at " + rowrec.getLastCol());, , 					// If there's a jump in rows, fire off missing row records, 					if (lastRowRow + 1 < rowrec.getRowNumber()) {, 						for (int i = (lastRowRow + 1); i < rowrec.getRowNumber(); i++) {, 							MissingRowDummyRecord dr = new MissingRowDummyRecord(i);, 							childListener.processRecord(dr);, 						}, 					}, , 					// Record this as the last row we saw, 					lastRowRow = rowrec.getRowNumber();, 					break;, , 				case SharedFormulaRecord.sid:, 					// SharedFormulaRecord occurs after the first FormulaRecord of the cell range., 					// There are probably (but not always) more cell records after this, 					// - so don't fire off the LastCellOfRowDummyRecord yet, 					childListener.processRecord(record);, 					return;, 				case MulBlankRecord.sid:, 					// These appear in the middle of the cell records, to, 					//  specify that the next bunch are empty but styled, 					// Expand this out into multiple blank cells, 					MulBlankRecord mbr = (MulBlankRecord)record;, 					expandedRecords = RecordFactory.convertBlankRecords(mbr);, 					break;, 				case MulRKRecord.sid:, 					// This is multiple consecutive number cells in one record, 					// Exand this out into multiple regular number cells, 					MulRKRecord mrk = (MulRKRecord)record;, 					expandedRecords = RecordFactory.convertRKRecords(mrk);, 					break;, 				case NoteRecord.sid:, 					NoteRecord nrec = (NoteRecord) record;, 					thisRow = nrec.getRow();, 					thisColumn = nrec.getColumn();],,
BAD_PRACTICE,NM_SAME_SIMPLE_NAME_AS_INTERFACE,org/apache/poi/hssf/extractor/ExcelExtractor.java,,57-435,[	private boolean _includeSheetNames = true;, 	private boolean _shouldEvaluateFormulas = true;, 	private boolean _includeCellComments = false;, 	private boolean _includeBlankCells = false;, 	private boolean _includeHeadersFooters = true;, , 	public ExcelExtractor(HSSFWorkbook wb) {, 		super(wb);, 		_wb = wb;, 		_formatter = new HSSFDataFormatter();, 	}, 	public ExcelExtractor(POIFSFileSystem fs) throws IOException {, 		this(fs.getRoot());, 	}, 	/**,      * @deprecated Use {@link #ExcelExtractor(DirectoryNode)} instead,      */,     @Deprecated,     @SuppressWarnings( "unused" ),     public ExcelExtractor(DirectoryNode dir, POIFSFileSystem fs) throws IOException {,         this( dir );,     },     public ExcelExtractor(DirectoryNode dir) throws IOException {, 		this(new HSSFWorkbook(dir, true));, 	}, , 	private static final class CommandParseException extends Exception {, 		public CommandParseException(String msg) {, 			super(msg);, 		}, 	}, 	private static final class CommandArgs {, 		private final boolean _requestHelp;, 		private final File _inputFile;, 		private final boolean _showSheetNames;, 		private final boolean _evaluateFormulas;, 		private final boolean _showCellComments;, 		private final boolean _showBlankCells;, 		private final boolean _headersFooters;, 		public CommandArgs(String[] args) throws CommandParseException {, 			int nArgs = args.length;, 			File inputFile = null;, 			boolean requestHelp = false;, 			boolean showSheetNames = true;, 			boolean evaluateFormulas = true;, 			boolean showCellComments = false;, 			boolean showBlankCells = false;, 			boolean headersFooters = true;, 			for (int i=0; i<nArgs; i++) {, 				String arg = args[i];, 				if ("-help".equalsIgnoreCase(arg)) {, 					requestHelp = true;, 					break;, 				}, 				if ("-i".equals(arg)) {, 					 // step to next arg, 					if (++i >= nArgs) {, 						throw new CommandParseException("Expected filename after '-i'");, 					}, 					arg = args[i];, 					if (inputFile != null) {, 						throw new CommandParseException("Only one input file can be supplied");, 					}, 					inputFile = new File(arg);, 					if (!inputFile.exists()) {, 						throw new CommandParseException("Specified input file '" + arg + "' does not exist");, 					}, 					if (inputFile.isDirectory()) {, 						throw new CommandParseException("Specified input file '" + arg + "' is a directory");, 					}, 					continue;, 				}, 				if ("--show-sheet-names".equals(arg)) {, 					showSheetNames = parseBoolArg(args, ++i);, 					continue;, 				}, 				if ("--evaluate-formulas".equals(arg)) {, 					evaluateFormulas = parseBoolArg(args, ++i);, 					continue;, 				}, 				if ("--show-comments".equals(arg)) {, 					showCellComments = parseBoolArg(args, ++i);, 					continue;, 				}, 				if ("--show-blanks".equals(arg)) {, 					showBlankCells = parseBoolArg(args, ++i);, 					continue;, 				}, 				if ("--headers-footers".equals(arg)) {, 					headersFooters = parseBoolArg(args, ++i);, 					continue;, 				}, 				throw new CommandParseException("Invalid argument '" + arg + "'");, 			}, 			_requestHelp = requestHelp;, 			_inputFile = inputFile;, 			_showSheetNames = showSheetNames;, 			_evaluateFormulas = evaluateFormulas;, 			_showCellComments = showCellComments;, 			_showBlankCells = showBlankCells;, 			_headersFooters = headersFooters;, 		}, 		private static boolean parseBoolArg(String[] args, int i) throws CommandParseException {, 			if (i >= args.length) {, 				throw new CommandParseException("Expected value after '" + args[i-1] + "'");, 			}, 			String value = args[i].toUpperCase();, 			if ("Y".equals(value) || "YES".equals(value) || "ON".equals(value) || "TRUE".equals(value)) {, 				return true;, 			}, 			if ("N".equals(value) || "NO".equals(value) || "OFF".equals(value) || "FALSE".equals(value)) {, 				return false;, 			}, 			throw new CommandParseException("Invalid value '" + args[i] + "' for '" + args[i-1] + "'. Expected 'Y' or 'N'");, 		}, 		public boolean isRequestHelp() {, 			return _requestHelp;, 		}, 		public File getInputFile() {, 			return _inputFile;, 		}, 		public boolean shouldShowSheetNames() {, 			return _showSheetNames;, 		}, 		public boolean shouldEvaluateFormulas() {, 			return _evaluateFormulas;, 		}, 		public boolean shouldShowCellComments() {, 			return _showCellComments;, 		}, 		public boolean shouldShowBlankCells() {, 			return _showBlankCells;, 		}, 		public boolean shouldIncludeHeadersFooters() {, 			return _headersFooters;, 		}, 	}, , 	private static void printUsageMessage(PrintStream ps) {, 		ps.println("Use:");, 		ps.println("    " + ExcelExtractor.class.getName() + " [<flag> <value> [<flag> <value> [...]]] [-i <filename.xls>]");, 		ps.println("       -i <filename.xls> specifies input file (default is to use stdin)");, 		ps.println("       Flags can be set on or off by using the values 'Y' or 'N'.");, 		ps.println("       Following are available flags and their default values:");, 		ps.println("       --show-sheet-names  Y");, 		ps.println("       --evaluate-formulas Y");, 		ps.println("       --show-comments     N");, 		ps.println("       --show-blanks       Y");, 		ps.println("       --headers-footers   Y");, 	}, , 	/**, 	 * Command line extractor., 	 */, 	public static void main(String[] args) {, , 		CommandArgs cmdArgs;, 		try {, 			cmdArgs = new CommandArgs(args);, 		} catch (CommandParseException e) {, 			System.err.println(e.getMessage());, 			printUsageMessage(System.err);, 			System.exit(1);, 			return; // suppress compiler error, 		}, , 		if (cmdArgs.isRequestHelp()) {, 			printUsageMessage(System.out);, 			return;, 		}, , 		try {, 			InputStream is;, 			if(cmdArgs.getInputFile() == null) {, 				is = System.in;, 			} else {, 				is = new FileInputStream(cmdArgs.getInputFile());, 			}, 			HSSFWorkbook wb = new HSSFWorkbook(is);, , 			ExcelExtractor extractor = new ExcelExtractor(wb);, 			extractor.setIncludeSheetNames(cmdArgs.shouldShowSheetNames());, 			extractor.setFormulasNotResults(!cmdArgs.shouldEvaluateFormulas());, 			extractor.setIncludeCellComments(cmdArgs.shouldShowCellComments());, 			extractor.setIncludeBlankCells(cmdArgs.shouldShowBlankCells());, 			extractor.setIncludeHeadersFooters(cmdArgs.shouldIncludeHeadersFooters());, 			System.out.println(extractor.getText());, 		} catch (Exception e) {, 			e.printStackTrace();, 			System.exit(1);, 		}, 	}, 	/**, 	 * Should sheet names be included? Default is true, 	 */, 	public void setIncludeSheetNames(boolean includeSheetNames) {, 		_includeSheetNames = includeSheetNames;, 	}, 	/**, 	 * Should we return the formula itself, and not, 	 *  the result it produces? Default is false, 	 */, 	public void setFormulasNotResults(boolean formulasNotResults) {, 		_shouldEvaluateFormulas = !formulasNotResults;, 	}, 	/**, 	 * Should cell comments be included? Default is false, 	 */, 	public void setIncludeCellComments(boolean includeCellComments) {, 		_includeCellComments = includeCellComments;, 	}, 	/**, 	 * Should blank cells be output? Default is to only, 	 *  output cells that are present in the file and are, 	 *  non-blank., 	 */, 	public void setIncludeBlankCells(boolean includeBlankCells) {, 		_includeBlankCells = includeBlankCells;, 	}, 	/**, 	 * Should headers and footers be included in the output?, 	 * Default is to include them., 	 */, 	public void setIncludeHeadersFooters(boolean includeHeadersFooters) {, 		_includeHeadersFooters = includeHeadersFooters;, 	}, , 	/**, 	 * Retrieves the text contents of the file, 	 */, 	public String getText() {, 		StringBuffer text = new StringBuffer();, , 		// We don't care about the difference between, 		//  null (missing) and blank cells, 		_wb.setMissingCellPolicy(HSSFRow.RETURN_BLANK_AS_NULL);, , 		// Process each sheet in turn, 		for(int i=0;i<_wb.getNumberOfSheets();i++) {, 			HSSFSheet sheet = _wb.getSheetAt(i);, 			if(sheet == null) { continue; }, , 			if(_includeSheetNames) {, 				String name = _wb.getSheetName(i);, 				if(name != null) {, 					text.append(name);, 					text.append("\n");, 				}, 			}, , 			// Header text, if there is any, 			if(_includeHeadersFooters) {, 				text.append(_extractHeaderFooter(sheet.getHeader()));, 			}, , 			int firstRow = sheet.getFirstRowNum();, 			int lastRow = sheet.getLastRowNum();, 			for(int j=firstRow;j<=lastRow;j++) {, 				HSSFRow row = sheet.getRow(j);, 				if(row == null) { continue; }, , 				// Check each cell in turn, 				int firstCell = row.getFirstCellNum();, 				int lastCell = row.getLastCellNum();, 				if(_includeBlankCells) {, 					firstCell = 0;, 				}, , 				for(int k=firstCell;k<lastCell;k++) {, 					HSSFCell cell = row.getCell(k);, 					boolean outputContents = true;, , 					if(cell == null) {, 						// Only output if requested, 						outputContents = _includeBlankCells;, 					} else {, 						switch(cell.getCellType()) {, 							case HSSFCell.CELL_TYPE_STRING:, 								text.append(cell.getRichStringCellValue().getString());, 								break;, 							case HSSFCell.CELL_TYPE_NUMERIC:, 								text.append(, 								      _formatter.formatCellValue(cell), 								);, 								break;, 							case HSSFCell.CELL_TYPE_BOOLEAN:, 								text.append(cell.getBooleanCellValue());, 								break;, 							case HSSFCell.CELL_TYPE_ERROR:, 								text.append(ErrorEval.getText(cell.getErrorCellValue()));, 								break;, 							case HSSFCell.CELL_TYPE_FORMULA:, 								if(!_shouldEvaluateFormulas) {, 									text.append(cell.getCellFormula());, 								} else {, 									switch(cell.getCachedFormulaResultType()) {, 										case HSSFCell.CELL_TYPE_STRING:, 											HSSFRichTextString str = cell.getRichStringCellValue();, 											if(str != null && str.length() > 0) {, 												text.append(str.toString());, 											}, 											break;, 										case HSSFCell.CELL_TYPE_NUMERIC:, 										   HSSFCellStyle style = cell.getCellStyle();, 										   if(style == null) {, 										      text.append( cell.getNumericCellValue() );, 										   } else {, 	                                 text.append(, 	                                       _formatter.formatRawCellContents(, 	                                             cell.getNumericCellValue(),, 	                                             style.getDataFormat(),, 	                                             style.getDataFormatString(), 	                                       ), 	                                 );, 										   }, 											break;, 										case HSSFCell.CELL_TYPE_BOOLEAN:, 											text.append(cell.getBooleanCellValue());, 											break;, 										case HSSFCell.CELL_TYPE_ERROR:, 											text.append(ErrorEval.getText(cell.getErrorCellValue()));, 											break;, , 									}, 								}, 								break;, 							default:, 								throw new RuntimeException("Unexpected cell type (" + cell.getCellType() + ")");, 						}, , 						// Output the comment, if requested and exists, 						HSSFComment comment = cell.getCellComment();, 						if(_includeCellComments && comment != null) {, 							// Replace any newlines with spaces, otherwise it, 							//  breaks the output, 							String commentText = comment.getString().getString().replace('\n', ' ');, 							text.append(" Comment by "+comment.getAuthor()+": "+commentText);, 						}, 					}, , 					// Output a tab if we're not on the last cell, 					if(outputContents && k < (lastCell-1)) {, 						text.append("\t");, 					}, 				}, , 				// Finish off the row, 				text.append("\n");, 			}, , 			// Finally Footer text, if there is any, 			if(_includeHeadersFooters) {, 				text.append(_extractHeaderFooter(sheet.getFooter()));, 			}, 		}, , 		return text.toString();, 	}, , 	public static String _extractHeaderFooter(HeaderFooter hf) {, 		StringBuffer text = new StringBuffer();, , 		if(hf.getLeft() != null) {, 			text.append(hf.getLeft());, 		}, 		if(hf.getCenter() != null) {, 			if(text.length() > 0), 				text.append("\t");, 			text.append(hf.getCenter());, 		}, 		if(hf.getRight() != null) {, 			if(text.length() > 0), 				text.append("\t");, 			text.append(hf.getRight());, 		}, 		if(text.length() > 0), 			text.append("\n");, , 		return text.toString();],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/poi/hssf/extractor/ExcelExtractor.java,getText,361-361,[										   if(style == null) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/poi/hssf/extractor/ExcelExtractor.java,main,244-244,[		} catch (Exception e) {],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/poi/hssf/extractor/ExcelExtractor.java,getText,352-377,[									switch(cell.getCachedFormulaResultType()) {, 										case HSSFCell.CELL_TYPE_STRING:, 											HSSFRichTextString str = cell.getRichStringCellValue();, 											if(str != null && str.length() > 0) {, 												text.append(str.toString());, 											}, 											break;, 										case HSSFCell.CELL_TYPE_NUMERIC:, 										   HSSFCellStyle style = cell.getCellStyle();, 										   if(style == null) {, 										      text.append( cell.getNumericCellValue() );, 										   } else {, 	                                 text.append(, 	                                       _formatter.formatRawCellContents(, 	                                             cell.getNumericCellValue(),, 	                                             style.getDataFormat(),, 	                                             style.getDataFormatString(), 	                                       ), 	                                 );, 										   }, 											break;, 										case HSSFCell.CELL_TYPE_BOOLEAN:, 											text.append(cell.getBooleanCellValue());, 											break;, 										case HSSFCell.CELL_TYPE_ERROR:, 											text.append(ErrorEval.getText(cell.getErrorCellValue()));],,
I18N,DM_CONVERT_CASE,org/apache/poi/hssf/extractor/ExcelExtractor.java,parseBoolArg,163-163,[			String value = args[i].toUpperCase();],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/poi/hssf/model/CommentShape.java,addStandardOptions,109-117,[            switch (prop.getId()){,                 case EscherProperties.TEXT__TEXTLEFT:,                 case EscherProperties.TEXT__TEXTRIGHT:,                 case EscherProperties.TEXT__TEXTTOP:,                 case EscherProperties.TEXT__TEXTBOTTOM:,                 case EscherProperties.GROUPSHAPE__PRINT:,                 case EscherProperties.FILL__FILLBACKCOLOR:,                 case EscherProperties.LINESTYLE__COLOR:,                     iterator.remove();],,
STYLE,UCF_USELESS_CONTROL_FLOW,org/apache/poi/hssf/model/InternalSheet.java,<init>,177-177,[        if (bof.getType() != BOFRecord.TYPE_WORKSHEET) {],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/poi/hssf/model/InternalWorkbook.java,createExtendedFormat,1307-1621,[        switch (id) {, ,             case 0 :,                 retval.setFontIndex(( short ) 0);,                 retval.setFormatIndex(( short ) 0);,                 retval.setCellOptions(( short ) 0xfffffff5);,                 retval.setAlignmentOptions(( short ) 0x20);,                 retval.setIndentionOptions(( short ) 0);,                 retval.setBorderOptions(( short ) 0);,                 retval.setPaletteOptions(( short ) 0);,                 retval.setAdtlPaletteOptions(( short ) 0);,                 retval.setFillPaletteOptions(( short ) 0x20c0);,                 break;, ,             case 1 :,                 retval.setFontIndex(( short ) 1);,                 retval.setFormatIndex(( short ) 0);,                 retval.setCellOptions(( short ) 0xfffffff5);,                 retval.setAlignmentOptions(( short ) 0x20);,                 retval.setIndentionOptions(( short ) 0xfffff400);,                 retval.setBorderOptions(( short ) 0);,                 retval.setPaletteOptions(( short ) 0);,                 retval.setAdtlPaletteOptions(( short ) 0);,                 retval.setFillPaletteOptions(( short ) 0x20c0);,                 break;, ,             case 2 :,                 retval.setFontIndex(( short ) 1);,                 retval.setFormatIndex(( short ) 0);,                 retval.setCellOptions(( short ) 0xfffffff5);,                 retval.setAlignmentOptions(( short ) 0x20);,                 retval.setIndentionOptions(( short ) 0xfffff400);,                 retval.setBorderOptions(( short ) 0);,                 retval.setPaletteOptions(( short ) 0);,                 retval.setAdtlPaletteOptions(( short ) 0);,                 retval.setFillPaletteOptions(( short ) 0x20c0);,                 break;, ,             case 3 :,                 retval.setFontIndex(( short ) 2);,                 retval.setFormatIndex(( short ) 0);,                 retval.setCellOptions(( short ) 0xfffffff5);,                 retval.setAlignmentOptions(( short ) 0x20);,                 retval.setIndentionOptions(( short ) 0xfffff400);,                 retval.setBorderOptions(( short ) 0);,                 retval.setPaletteOptions(( short ) 0);,                 retval.setAdtlPaletteOptions(( short ) 0);,                 retval.setFillPaletteOptions(( short ) 0x20c0);,                 break;, ,             case 4 :,                 retval.setFontIndex(( short ) 2);,                 retval.setFormatIndex(( short ) 0);,                 retval.setCellOptions(( short ) 0xfffffff5);,                 retval.setAlignmentOptions(( short ) 0x20);,                 retval.setIndentionOptions(( short ) 0xfffff400);,                 retval.setBorderOptions(( short ) 0);,                 retval.setPaletteOptions(( short ) 0);,                 retval.setAdtlPaletteOptions(( short ) 0);,                 retval.setFillPaletteOptions(( short ) 0x20c0);,                 break;, ,             case 5 :,                 retval.setFontIndex(( short ) 0);,                 retval.setFormatIndex(( short ) 0);,                 retval.setCellOptions(( short ) 0xfffffff5);,                 retval.setAlignmentOptions(( short ) 0x20);,                 retval.setIndentionOptions(( short ) 0xfffff400);,                 retval.setBorderOptions(( short ) 0);,                 retval.setPaletteOptions(( short ) 0);,                 retval.setAdtlPaletteOptions(( short ) 0);,                 retval.setFillPaletteOptions(( short ) 0x20c0);,                 break;, ,             case 6 :,                 retval.setFontIndex(( short ) 0);,                 retval.setFormatIndex(( short ) 0);,                 retval.setCellOptions(( short ) 0xfffffff5);,                 retval.setAlignmentOptions(( short ) 0x20);,                 retval.setIndentionOptions(( short ) 0xfffff400);,                 retval.setBorderOptions(( short ) 0);,                 retval.setPaletteOptions(( short ) 0);,                 retval.setAdtlPaletteOptions(( short ) 0);,                 retval.setFillPaletteOptions(( short ) 0x20c0);,                 break;, ,             case 7 :,                 retval.setFontIndex(( short ) 0);,                 retval.setFormatIndex(( short ) 0);,                 retval.setCellOptions(( short ) 0xfffffff5);,                 retval.setAlignmentOptions(( short ) 0x20);,                 retval.setIndentionOptions(( short ) 0xfffff400);,                 retval.setBorderOptions(( short ) 0);,                 retval.setPaletteOptions(( short ) 0);,                 retval.setAdtlPaletteOptions(( short ) 0);,                 retval.setFillPaletteOptions(( short ) 0x20c0);,                 break;, ,             case 8 :,                 retval.setFontIndex(( short ) 0);,                 retval.setFormatIndex(( short ) 0);,                 retval.setCellOptions(( short ) 0xfffffff5);,                 retval.setAlignmentOptions(( short ) 0x20);,                 retval.setIndentionOptions(( short ) 0xfffff400);,                 retval.setBorderOptions(( short ) 0);,                 retval.setPaletteOptions(( short ) 0);,                 retval.setAdtlPaletteOptions(( short ) 0);,                 retval.setFillPaletteOptions(( short ) 0x20c0);,                 break;, ,             case 9 :,                 retval.setFontIndex(( short ) 0);,                 retval.setFormatIndex(( short ) 0);,                 retval.setCellOptions(( short ) 0xfffffff5);,                 retval.setAlignmentOptions(( short ) 0x20);,                 retval.setIndentionOptions(( short ) 0xfffff400);,                 retval.setBorderOptions(( short ) 0);,                 retval.setPaletteOptions(( short ) 0);,                 retval.setAdtlPaletteOptions(( short ) 0);,                 retval.setFillPaletteOptions(( short ) 0x20c0);,                 break;, ,             case 10 :,                 retval.setFontIndex(( short ) 0);,                 retval.setFormatIndex(( short ) 0);,                 retval.setCellOptions(( short ) 0xfffffff5);,                 retval.setAlignmentOptions(( short ) 0x20);,                 retval.setIndentionOptions(( short ) 0xfffff400);,                 retval.setBorderOptions(( short ) 0);,                 retval.setPaletteOptions(( short ) 0);,                 retval.setAdtlPaletteOptions(( short ) 0);,                 retval.setFillPaletteOptions(( short ) 0x20c0);,                 break;, ,             case 11 :,                 retval.setFontIndex(( short ) 0);,                 retval.setFormatIndex(( short ) 0);,                 retval.setCellOptions(( short ) 0xfffffff5);,                 retval.setAlignmentOptions(( short ) 0x20);,                 retval.setIndentionOptions(( short ) 0xfffff400);,                 retval.setBorderOptions(( short ) 0);,                 retval.setPaletteOptions(( short ) 0);,                 retval.setAdtlPaletteOptions(( short ) 0);,                 retval.setFillPaletteOptions(( short ) 0x20c0);,                 break;, ,             case 12 :,                 retval.setFontIndex(( short ) 0);,                 retval.setFormatIndex(( short ) 0);,                 retval.setCellOptions(( short ) 0xfffffff5);,                 retval.setAlignmentOptions(( short ) 0x20);,                 retval.setIndentionOptions(( short ) 0xfffff400);,                 retval.setBorderOptions(( short ) 0);,                 retval.setPaletteOptions(( short ) 0);,                 retval.setAdtlPaletteOptions(( short ) 0);,                 retval.setFillPaletteOptions(( short ) 0x20c0);,                 break;, ,             case 13 :,                 retval.setFontIndex(( short ) 0);,                 retval.setFormatIndex(( short ) 0);,                 retval.setCellOptions(( short ) 0xfffffff5);,                 retval.setAlignmentOptions(( short ) 0x20);,                 retval.setIndentionOptions(( short ) 0xfffff400);,                 retval.setBorderOptions(( short ) 0);,                 retval.setPaletteOptions(( short ) 0);,                 retval.setAdtlPaletteOptions(( short ) 0);,                 retval.setFillPaletteOptions(( short ) 0x20c0);,                 break;, ,             case 14 :,                 retval.setFontIndex(( short ) 0);,                 retval.setFormatIndex(( short ) 0);,                 retval.setCellOptions(( short ) 0xfffffff5);,                 retval.setAlignmentOptions(( short ) 0x20);,                 retval.setIndentionOptions(( short ) 0xfffff400);,                 retval.setBorderOptions(( short ) 0);,                 retval.setPaletteOptions(( short ) 0);,                 retval.setAdtlPaletteOptions(( short ) 0);,                 retval.setFillPaletteOptions(( short ) 0x20c0);,                 break;, ,                 // cell records,             case 15 :,                 retval.setFontIndex(( short ) 0);,                 retval.setFormatIndex(( short ) 0);,                 retval.setCellOptions(( short ) 0x1);,                 retval.setAlignmentOptions(( short ) 0x20);,                 retval.setIndentionOptions(( short ) 0x0);,                 retval.setBorderOptions(( short ) 0);,                 retval.setPaletteOptions(( short ) 0);,                 retval.setAdtlPaletteOptions(( short ) 0);,                 retval.setFillPaletteOptions(( short ) 0x20c0);,                 break;, ,                 // style,             case 16 :,                 retval.setFontIndex(( short ) 1);,                 retval.setFormatIndex(( short ) 0x2b);,                 retval.setCellOptions(( short ) 0xfffffff5);,                 retval.setAlignmentOptions(( short ) 0x20);,                 retval.setIndentionOptions(( short ) 0xfffff800);,                 retval.setBorderOptions(( short ) 0);,                 retval.setPaletteOptions(( short ) 0);,                 retval.setAdtlPaletteOptions(( short ) 0);,                 retval.setFillPaletteOptions(( short ) 0x20c0);,                 break;, ,             case 17 :,                 retval.setFontIndex(( short ) 1);,                 retval.setFormatIndex(( short ) 0x29);,                 retval.setCellOptions(( short ) 0xfffffff5);,                 retval.setAlignmentOptions(( short ) 0x20);,                 retval.setIndentionOptions(( short ) 0xfffff800);,                 retval.setBorderOptions(( short ) 0);,                 retval.setPaletteOptions(( short ) 0);,                 retval.setAdtlPaletteOptions(( short ) 0);,                 retval.setFillPaletteOptions(( short ) 0x20c0);,                 break;, ,             case 18 :,                 retval.setFontIndex(( short ) 1);,                 retval.setFormatIndex(( short ) 0x2c);,                 retval.setCellOptions(( short ) 0xfffffff5);,                 retval.setAlignmentOptions(( short ) 0x20);,                 retval.setIndentionOptions(( short ) 0xfffff800);,                 retval.setBorderOptions(( short ) 0);,                 retval.setPaletteOptions(( short ) 0);,                 retval.setAdtlPaletteOptions(( short ) 0);,                 retval.setFillPaletteOptions(( short ) 0x20c0);,                 break;, ,             case 19 :,                 retval.setFontIndex(( short ) 1);,                 retval.setFormatIndex(( short ) 0x2a);,                 retval.setCellOptions(( short ) 0xfffffff5);,                 retval.setAlignmentOptions(( short ) 0x20);,                 retval.setIndentionOptions(( short ) 0xfffff800);,                 retval.setBorderOptions(( short ) 0);,                 retval.setPaletteOptions(( short ) 0);,                 retval.setAdtlPaletteOptions(( short ) 0);,                 retval.setFillPaletteOptions(( short ) 0x20c0);,                 break;, ,             case 20 :,                 retval.setFontIndex(( short ) 1);,                 retval.setFormatIndex(( short ) 0x9);,                 retval.setCellOptions(( short ) 0xfffffff5);,                 retval.setAlignmentOptions(( short ) 0x20);,                 retval.setIndentionOptions(( short ) 0xfffff800);,                 retval.setBorderOptions(( short ) 0);,                 retval.setPaletteOptions(( short ) 0);,                 retval.setAdtlPaletteOptions(( short ) 0);,                 retval.setFillPaletteOptions(( short ) 0x20c0);,                 break;, ,                 // unused from this point down,             case 21 :,                 retval.setFontIndex(( short ) 5);,                 retval.setFormatIndex(( short ) 0x0);,                 retval.setCellOptions(( short ) 0x1);,                 retval.setAlignmentOptions(( short ) 0x20);,                 retval.setIndentionOptions(( short ) 0x800);,                 retval.setBorderOptions(( short ) 0);,                 retval.setPaletteOptions(( short ) 0);,                 retval.setAdtlPaletteOptions(( short ) 0);,                 retval.setFillPaletteOptions(( short ) 0x20c0);,                 break;, ,             case 22 :,                 retval.setFontIndex(( short ) 6);,                 retval.setFormatIndex(( short ) 0x0);,                 retval.setCellOptions(( short ) 0x1);,                 retval.setAlignmentOptions(( short ) 0x20);,                 retval.setIndentionOptions(( short ) 0x5c00);,                 retval.setBorderOptions(( short ) 0);,                 retval.setPaletteOptions(( short ) 0);,                 retval.setAdtlPaletteOptions(( short ) 0);,                 retval.setFillPaletteOptions(( short ) 0x20c0);,                 break;, ,             case 23 :,                 retval.setFontIndex(( short ) 0);,                 retval.setFormatIndex(( short ) 0x31);,                 retval.setCellOptions(( short ) 0x1);,                 retval.setAlignmentOptions(( short ) 0x20);,                 retval.setIndentionOptions(( short ) 0x5c00);,                 retval.setBorderOptions(( short ) 0);,                 retval.setPaletteOptions(( short ) 0);,                 retval.setAdtlPaletteOptions(( short ) 0);,                 retval.setFillPaletteOptions(( short ) 0x20c0);,                 break;, ,             case 24 :,                 retval.setFontIndex(( short ) 0);,                 retval.setFormatIndex(( short ) 0x8);,                 retval.setCellOptions(( short ) 0x1);,                 retval.setAlignmentOptions(( short ) 0x20);,                 retval.setIndentionOptions(( short ) 0x5c00);,                 retval.setBorderOptions(( short ) 0);,                 retval.setPaletteOptions(( short ) 0);,                 retval.setAdtlPaletteOptions(( short ) 0);,                 retval.setFillPaletteOptions(( short ) 0x20c0);,                 break;, ,             case 25 :,                 retval.setFontIndex(( short ) 6);,                 retval.setFormatIndex(( short ) 0x8);,                 retval.setCellOptions(( short ) 0x1);,                 retval.setAlignmentOptions(( short ) 0x20);,                 retval.setIndentionOptions(( short ) 0x5c00);,                 retval.setBorderOptions(( short ) 0);,                 retval.setPaletteOptions(( short ) 0);,                 retval.setAdtlPaletteOptions(( short ) 0);,                 retval.setFillPaletteOptions(( short ) 0x20c0);],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/poi/hssf/model/InternalWorkbook.java,createStyle,1658-1693,[        switch (id) {, ,             case 0 :,                 retval.setXFIndex(0x010);,                 retval.setBuiltinStyle(3);,                 retval.setOutlineStyleLevel(( byte ) 0xffffffff);,                 break;, ,             case 1 :,                 retval.setXFIndex(0x011);,                 retval.setBuiltinStyle(6);,                 retval.setOutlineStyleLevel(( byte ) 0xffffffff);,                 break;, ,             case 2 :,                 retval.setXFIndex(0x012);,                 retval.setBuiltinStyle(4);,                 retval.setOutlineStyleLevel(( byte ) 0xffffffff);,                 break;, ,             case 3 :,                 retval.setXFIndex(0x013);,                 retval.setBuiltinStyle(7);,                 retval.setOutlineStyleLevel(( byte ) 0xffffffff);,                 break;, ,             case 4 :,                 retval.setXFIndex(0x000);,                 retval.setBuiltinStyle(0);,                 retval.setOutlineStyleLevel(( byte ) 0xffffffff);,                 break;, ,             case 5 :,                 retval.setXFIndex(0x014);,                 retval.setBuiltinStyle(5);,                 retval.setOutlineStyleLevel(( byte ) 0xffffffff);],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/poi/hssf/model/InternalWorkbook.java,createWorkbook,336-338,[            switch (rec.getSid()) {,                 case HyperlinkRecord.sid:,                     retval.hyperlinks.add((HyperlinkRecord)rec);],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/poi/hssf/model/LinkTable.java,getExternalBookAndSheetName,360-360,[			return null;],,
I18N,DM_DEFAULT_ENCODING,org/apache/poi/hssf/model/TestRowBlocksReader.java,testAbnormalPivotTableRecords_bug46280,44-44,[			new UnknownRecord(SXVIEW_SID, "dummydata (SXVIEW: View Definition)".getBytes()),],,
STYLE,RV_RETURN_VALUE_IGNORED_NO_SIDE_EFFECT,org/apache/poi/hssf/model/TestSheet.java,testGutsRecord_bug45640,536-536,[		sheet.toString();],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/poi/hssf/model/TestWorkbook.java,,100-102,[        FreeRefFunction NotImplemented = new FreeRefFunction() {,             public ValueEval evaluate(ValueEval[] args, OperationEvaluationContext ec) {,                 throw new RuntimeException("not implemented");],,
BAD_PRACTICE,NM_CONFUSING,org/apache/poi/hssf/record/BoundSheetRecord.java,getSheetname,117-117,[		return field_5_sheetname;],,getSheetName,69-71,[        int indexToExternSheet = _definedNameRec.getExternSheetNumber();, ,         return _book.getWorkbook().findSheetNameFromExternSheet(indexToExternSheet);],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/poi/hssf/record/CFRuleRecord.java,parseFormula,522-522,[            return null;],,
CORRECTNESS,UR_UNINIT_READ,org/apache/poi/hssf/record/CFRuleRecord.java,<init>,114-114,[		field_5_options = modificationBits.setValue(field_5_options, -1);],,
BAD_PRACTICE,NM_CONFUSING,org/apache/poi/hssf/record/DVRecord.java,getSuppressDropdownArrow,171-171,[	   return (opt_suppress_dropdown_arrow.isSet(_option_flags));],,getSuppressDropDownArrow,114-117,[		if (_constraint.getValidationType()==ValidationType.LIST) {, 			return _suppress_dropdown_arrow;, 		}, 		return false;],,
STYLE,SF_SWITCH_FALLTHROUGH,org/apache/poi/hssf/record/EmbeddedObjectRefSubRecord.java,serialize,271-273,[				pos ++;, 			case 0:, 				break;],,
STYLE,UCF_USELESS_CONTROL_FLOW,org/apache/poi/hssf/record/EscherAggregate.java,convertRecordsToUserModel,784-784,[			else if(r instanceof EscherOptRecord) {],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/poi/hssf/record/EscherAggregate.java,,434-446,[			{, 				public void beforeRecordSerialize( int offset, short recordId, EscherRecord record ), 				{, 				}, , 				public void afterRecordSerialize( int offset, short recordId, int size, EscherRecord record ), 				{, 					if ( recordId == EscherClientDataRecord.RECORD_ID || recordId == EscherTextboxRecord.RECORD_ID ), 					{, 						spEndingOffsets.add( Integer.valueOf( offset ) );, 						shapes.add( record );, 					}, 				}],,
I18N,DM_DEFAULT_ENCODING,org/apache/poi/hssf/record/FileSharingRecord.java,hashPassword,58-58,[        byte[] passwordCharacters = password.getBytes();],,
BAD_PRACTICE,NM_CONFUSING,org/apache/poi/hssf/record/FileSharingRecord.java,getUsername,111-111,[        return field_3_username_value;],,getUserName,42-42,[    return userName;],,
BAD_PRACTICE,HE_HASHCODE_USE_OBJECT_EQUALS,org/apache/poi/hssf/record/FontRecord.java,hashCode,440-455,[		final int prime = 31;, 		int result = 1;, 		result = prime, 				* result, 				+ ((field_11_font_name == null) ? 0 : field_11_font_name, 						.hashCode());, 		result = prime * result + field_1_font_height;, 		result = prime * result + field_2_attributes;, 		result = prime * result + field_3_color_palette_index;, 		result = prime * result + field_4_bold_weight;, 		result = prime * result + field_5_super_sub_script;, 		result = prime * result + field_6_underline;, 		result = prime * result + field_7_family;, 		result = prime * result + field_8_charset;, 		result = prime * result + field_9_zero;, 		return result;],,
BAD_PRACTICE,NM_CONFUSING,org/apache/poi/hssf/record/FontRecord.java,getBoldWeight,305-305,[		return field_4_bold_weight;],,getBoldweight,226-226,[        return font.getBoldWeight();],,
BAD_PRACTICE,NM_CONFUSING,org/apache/poi/hssf/record/FontRecord.java,setBoldWeight,171-172,[		field_4_bold_weight = bw;, 	}],,setBoldweight,214-215,[        font.setBoldWeight(boldweight);,     }],,
BAD_PRACTICE,NM_CONFUSING,org/apache/poi/hssf/record/FontRecord.java,setCharset,216-217,[		field_8_charset = charset;, 	}],,setCharSet,326-327,[        font.setCharset(charset);,     }],,
I18N,DM_CONVERT_CASE,org/apache/poi/hssf/record/HeaderFooterRecord.java,toString,92-92,[        sb.append(Integer.toHexString(sid).toUpperCase() + ")\n");],,
BAD_PRACTICE,BIT_SIGNED_CHECK,org/apache/poi/hssf/record/HyperlinkRecord.java,isDocumentLink,700-700,[       return (_linkOpts & HLINK_PLACE) > 0; ],,
BAD_PRACTICE,BIT_SIGNED_CHECK,org/apache/poi/hssf/record/HyperlinkRecord.java,isFileLink,693-693,[       return (_linkOpts & HLINK_URL) > 0 ],,
BAD_PRACTICE,BIT_SIGNED_CHECK,org/apache/poi/hssf/record/HyperlinkRecord.java,isUrlLink,686-686,[       return (_linkOpts & HLINK_URL) > 0 ],,
I18N,DM_DEFAULT_ENCODING,org/apache/poi/hssf/record/HyperlinkRecord.java,<init>,519-519,[                _address = new String(path_bytes);],,
BAD_PRACTICE,BC_EQUALS_METHOD_SHOULD_WORK_FOR_ALL_OBJECTS,org/apache/poi/hssf/record/HyperlinkRecord.java,equals,86-86,[			GUID other = (GUID) obj;],,
BAD_PRACTICE,HE_EQUALS_USE_HASHCODE,org/apache/poi/hssf/record/HyperlinkRecord.java,equals,86-89,[			GUID other = (GUID) obj;,             if (obj == null || !(obj instanceof GUID)),                 return false;, 			return _d1 == other._d1 && _d2 == other._d2],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/poi/hssf/record/LbsDataSubRecord.java,,309-309,[        public static int STYLE_COMBO_SIMPLE_DROPDOWN = 2;],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/poi/hssf/record/LbsDataSubRecord.java,,301-301,[        public static int STYLE_COMBO_DROPDOWN = 0;],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/poi/hssf/record/LbsDataSubRecord.java,,305-305,[        public static int STYLE_COMBO_EDIT_DROPDOWN = 1;],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/poi/hssf/record/LbsDataSubRecord.java,,301-301,[        public static int STYLE_COMBO_DROPDOWN = 0;],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/poi/hssf/record/LbsDataSubRecord.java,,305-305,[        public static int STYLE_COMBO_EDIT_DROPDOWN = 1;],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/poi/hssf/record/PaletteRecord.java,getColor,95-95,[            return null;],,
I18N,DM_DEFAULT_ENCODING,org/apache/poi/hssf/record/PasswordRecord.java,hashPassword,45-45,[        byte[] passwordCharacters = password.getBytes();],,
I18N,DM_CONVERT_CASE,org/apache/poi/hssf/record/RecordFactory.java,recordsToMap,402-402,[				throw new RuntimeException("duplicate record sid 0x" + Integer.toHexString(sid).toUpperCase()],,
MT_CORRECTNESS,LI_LAZY_INIT_STATIC,org/apache/poi/hssf/record/RecordFactory.java,getAllKnownRecordSIDs,354-364,[		if (_allKnownRecordSIDs == null) {, 			short[] results = new short[ _recordCreatorsById.size() ];, 			int i = 0;, , 			for (Iterator<Integer> iterator = _recordCreatorsById.keySet().iterator(); iterator.hasNext(); ) {, 				Integer sid = iterator.next();, , 				results[i++] = sid.shortValue();, 			}, 			Arrays.sort(results);,  			_allKnownRecordSIDs = results;],,
STYLE,REC_CATCH_EXCEPTION,org/apache/poi/hssf/record/RecordFactory.java,recordsToMap,395-395,[			} catch (Exception illegalArgumentException) {],,
BAD_PRACTICE,NM_SAME_SIMPLE_NAME_AS_SUPERCLASS,org/apache/poi/hssf/record/RecordFormatException.java,,32-41,[        super(exception);,     },     ,     public RecordFormatException(String exception, Throwable thr) {,       super(exception, thr);,     },     ,     public RecordFormatException(Throwable thr) {,       super(thr);,     }],,
STYLE,UCF_USELESS_CONTROL_FLOW,org/apache/poi/hssf/record/RecordInputStream.java,readDouble,275-275,[		if (Double.isNaN(result)) {],,
STYLE,UCF_USELESS_CONTROL_FLOW,org/apache/poi/hssf/record/RecordInputStream.java,readNextSid,170-170,[			if (nAvailable > 0) {],,
I18N,DM_CONVERT_CASE,org/apache/poi/hssf/record/RecordInputStream.java,<init>,54-54,[			super("Initialisation of record 0x" + Integer.toHexString(sid).toUpperCase()],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/poi/hssf/record/SSTRecord.java,createExtSSTRecord,295-295,[        if (bucketAbsoluteOffsets == null || bucketAbsoluteOffsets == null)],,
CORRECTNESS,RpC_REPEATED_CONDITIONAL_TEST,org/apache/poi/hssf/record/SSTRecord.java,createExtSSTRecord,295-295,[        if (bucketAbsoluteOffsets == null || bucketAbsoluteOffsets == null)],,
CORRECTNESS,UR_UNINIT_READ,org/apache/poi/hssf/record/StyleRecord.java,<init>,54-54,[		field_1_xf_index = isBuiltinFlag.set(field_1_xf_index);],,
PERFORMANCE,WMI_WRONG_MAP_ITERATOR,org/apache/poi/hssf/record/TestPaletteRecord.java,testDefaultPalette,44-44,[            HSSFColor c = (HSSFColor) colors.get(index);],,
I18N,DM_DEFAULT_ENCODING,org/apache/poi/hssf/record/TestSSTRecord.java,concatHexDumps,55-55,[            BufferedReader br = new BufferedReader(new InputStreamReader(is));],,
I18N,DM_DEFAULT_ENCODING,org/apache/poi/hssf/record/TestSSTRecord.java,testHugeStrings,163-163,[            strings[k] = new UnicodeString( new String(bstrings[k]) );],,testHugeStrings,200-200,[                strings[k] = new UnicodeString( new String(bstrings[k]) );],,
BAD_PRACTICE,OS_OPEN_STREAM,org/apache/poi/hssf/record/TestSSTRecord.java,concatHexDumps,55-55,[            BufferedReader br = new BufferedReader(new InputStreamReader(is));],,
BAD_PRACTICE,NM_SAME_SIMPLE_NAME_AS_SUPERCLASS,org/apache/poi/hssf/record/UnicodeString.java,,27-34,[      super(in);,    },    /**,     * @deprecated Use {@link org.apache.poi.hssf.record.common.UnicodeString} instead,     */,    public UnicodeString(String str) {,       super(str);,    }],,
I18N,DM_CONVERT_CASE,org/apache/poi/hssf/record/UnknownRecord.java,getBiffName,203-203,[			return "UNKNOWN-" + Integer.toHexString(sid).toUpperCase();],,
I18N,DM_CONVERT_CASE,org/apache/poi/hssf/record/UnknownRecord.java,toString,113-113,[		sb.append(Integer.toHexString(_sid).toUpperCase() + ")\n");],,
I18N,DM_CONVERT_CASE,org/apache/poi/hssf/record/UserSViewBegin.java,toString,81-81,[        sb.append(Integer.toHexString(sid).toUpperCase() + ")\n");],,
I18N,DM_CONVERT_CASE,org/apache/poi/hssf/record/UserSViewEnd.java,toString,69-69,[        sb.append(Integer.toHexString(sid).toUpperCase() + ")\n");],,
I18N,DM_DEFAULT_ENCODING,org/apache/poi/hssf/record/WriteAccessRecord.java,<init>,71-71,[			String rawValue = new String(data);],,
PERFORMANCE,DM_STRING_TOSTRING,org/apache/poi/hssf/record/WriteAccessRecord.java,toString,125-125,[		buffer.append("    .name = ").append(field_1_username.toString()).append("\n");],,
BAD_PRACTICE,SE_COMPARATOR_SHOULD_BE_SERIALIZABLE,org/apache/poi/hssf/record/aggregates/ColumnInfoRecordsAggregate.java,,39-47,[		public static final Comparator instance = new CIRComparator();, 		private CIRComparator() {, 			// enforce singleton, 		}, 		public int compare(Object a, Object b) {, 			return compareColInfos((ColumnInfoRecord)a, (ColumnInfoRecord)b);, 		}, 		public static int compareColInfos(ColumnInfoRecord a, ColumnInfoRecord b) {, 			return a.getFirstColumn()-b.getFirstColumn();],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/poi/hssf/record/aggregates/SharedValueManager.java,getKeyForCache,182-182,[        return new Integer((cellRef.getCol()+1)<<16 | cellRef.getRow());],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/poi/hssf/record/aggregates/SharedValueManager.java,findFormulaGroupForCell,216-216,[            if(null != sfg) {],,
STYLE,RV_RETURN_VALUE_IGNORED_NO_SIDE_EFFECT,org/apache/poi/hssf/record/aggregates/TestPageSettingsBlock.java,testPrintSetup_bug46548,51-51,[			ps.getCopies();],,
I18N,DM_DEFAULT_ENCODING,org/apache/poi/hssf/record/aggregates/TestRowRecordsAggregate.java,testUnknownContinue_bug46280,137-137,[			new UnknownRecord(0x5555, "dummydata".getBytes()),],,testUnknownContinue_bug46280,138-138,[			new ContinueRecord("moredummydata".getBytes()),],,
MALICIOUS_CODE,DP_DO_INSIDE_DO_PRIVILEGED,org/apache/poi/hssf/record/aggregates/TestSharedValueManager.java,extractFromRRA,186-186,[		f.setAccessible(true);],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/poi/hssf/record/aggregates/TestValueRecordsAggregate.java,,383-394,[		RecordVisitor rv = new RecordVisitor() {, , 			public void visitRecord(Record r) {, 				if (r instanceof MulBlankRecord) {, 					MulBlankRecord mbr = (MulBlankRecord) r;, 					bs.countMulBlankRecords++;, 					bs.countBlankCells += mbr.getNumColumns();, 				} else if (r instanceof BlankRecord) {, 					bs.countSingleBlankRecords++;, 					bs.countBlankCells++;, 				}, 			}],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/poi/hssf/record/aggregates/TestValueRecordsAggregate.java,,376-376,[		final class BlankStats {],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/poi/hssf/record/cf/CellRangeUtil.java,mergeRanges,156-156,[				return null;],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/poi/hssf/record/cf/CellRangeUtil.java,resolveRangeOverlap,175-175,[				return null;],,resolveRangeOverlap,182-182,[				return null;],,
I18N,DM_CONVERT_CASE,org/apache/poi/hssf/record/cf/FontFormatting.java,toString,538-538,[		buffer.append("	.color index = ").append("0x"+Integer.toHexString(getFontColorIndex()).toUpperCase()).append("\n");],,
CORRECTNESS,DMI_INVOKING_TOSTRING_ON_ARRAY,org/apache/poi/hssf/record/chart/SeriesListRecord.java,getSeriesNumbers,56-56,[        buffer.append("    .seriesNumbers= ").append(" (").append( getSeriesNumbers() ).append(" )");],,
STYLE,RV_RETURN_VALUE_IGNORED_NO_SIDE_EFFECT,org/apache/poi/hssf/record/common/FeatFormulaErr2.java,setCheckCalculationErrors,98-98,[		FeatFormulaErr2.checkCalculationErrors.setBoolean(],,
STYLE,RV_RETURN_VALUE_IGNORED_NO_SIDE_EFFECT,org/apache/poi/hssf/record/common/FeatFormulaErr2.java,setCheckDateTimeFormats,139-139,[		FeatFormulaErr2.checkDateTimeFormats.setBoolean(],,
STYLE,RV_RETURN_VALUE_IGNORED_NO_SIDE_EFFECT,org/apache/poi/hssf/record/common/FeatFormulaErr2.java,setCheckEmptyCellRef,106-106,[		FeatFormulaErr2.checkEmptyCellRef.setBoolean(],,
STYLE,RV_RETURN_VALUE_IGNORED_NO_SIDE_EFFECT,org/apache/poi/hssf/record/common/FeatFormulaErr2.java,setCheckInconsistentFormulas,131-131,[		FeatFormulaErr2.checkInconsistentFormulas.setBoolean(],,
STYLE,RV_RETURN_VALUE_IGNORED_NO_SIDE_EFFECT,org/apache/poi/hssf/record/common/FeatFormulaErr2.java,setCheckInconsistentRanges,122-122,[		FeatFormulaErr2.checkInconsistentRanges.setBoolean(],,
STYLE,RV_RETURN_VALUE_IGNORED_NO_SIDE_EFFECT,org/apache/poi/hssf/record/common/FeatFormulaErr2.java,setCheckNumbersAsText,114-114,[		FeatFormulaErr2.checkNumbersAsText.setBoolean(],,
STYLE,RV_RETURN_VALUE_IGNORED_NO_SIDE_EFFECT,org/apache/poi/hssf/record/common/FeatFormulaErr2.java,setCheckUnprotectedFormulas,147-147,[		FeatFormulaErr2.checkUnprotectedFormulas.setBoolean(],,
STYLE,RV_RETURN_VALUE_IGNORED_NO_SIDE_EFFECT,org/apache/poi/hssf/record/common/FeatFormulaErr2.java,setPerformDataValidation,155-155,[		FeatFormulaErr2.performDataValidation.setBoolean(],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/poi/hssf/record/common/FeatProtection.java,,38-38,[	public static long HAS_SELF_RELATIVE_SECURITY_FEATURE = 1;],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/poi/hssf/record/common/FeatProtection.java,,37-37,[	public static long NO_SELF_RELATIVE_SECURITY_FEATURE = 0;],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/poi/hssf/record/common/FeatProtection.java,,38-38,[	public static long HAS_SELF_RELATIVE_SECURITY_FEATURE = 1;],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/poi/hssf/record/common/FeatProtection.java,,37-37,[	public static long NO_SELF_RELATIVE_SECURITY_FEATURE = 0;],,
STYLE,NP_NULL_ON_SOME_PATH_MIGHT_BE_INFEASIBLE,org/apache/poi/hssf/record/common/UnicodeString.java,compareTo,741-741,[        int size = field_4_format_runs.size();],,compareTo,733-733,[        if ((field_4_format_runs == null) && (str.field_4_format_runs != null))],,compareTo,736-736,[        if ((field_4_format_runs != null) && (str.field_4_format_runs == null))],,
STYLE,NP_NULL_ON_SOME_PATH_MIGHT_BE_INFEASIBLE,org/apache/poi/hssf/record/common/UnicodeString.java,compareTo,762-762,[        result = field_5_ext_rst.compareTo(str.field_5_ext_rst); ],,compareTo,757-757,[        if ((field_5_ext_rst == null) && (str.field_5_ext_rst != null))],,compareTo,759-759,[        if ((field_5_ext_rst != null) && (str.field_5_ext_rst == null))],,
STYLE,NP_NULL_ON_SOME_PATH_MIGHT_BE_INFEASIBLE,org/apache/poi/hssf/record/common/UnicodeString.java,equals,370-370,[        int size = field_4_format_runs.size();],,equals,364-364,[        if (((field_4_format_runs == null) && (other.field_4_format_runs != null)) ||],,
BAD_PRACTICE,HE_EQUALS_USE_HASHCODE,org/apache/poi/hssf/record/common/UnicodeString.java,equals,224-228,[          if(! (obj instanceof ExtRst)) {,              return false;,           },           ExtRst other = (ExtRst)obj;,           return (compareTo(other) == 0);],,
BAD_PRACTICE,HE_EQUALS_USE_HASHCODE,org/apache/poi/hssf/record/common/UnicodeString.java,equals,74-79,[            if (!(o instanceof FormatRun)) {,                 return false;,             },             FormatRun other = ( FormatRun ) o;, ,             return _character == other._character && _fontIndex == other._fontIndex;],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/poi/hssf/record/crypto/Biff8EncryptionKey.java,xor,118-122,[		byte[] c = new byte[a.length];, 		for (int i = 0; i < c.length; i++) {, 			c[i] = (byte) (a[i] ^ b[i]);, 		}, 		return c;],,
I18N,DM_DEFAULT_ENCODING,org/apache/poi/hssf/record/crypto/TestRC4.java,confirmRC4,47-47,[		byte[] actEncr = origText.getBytes();],,confirmRC4,48-48,[		new RC4(k.getBytes()).encrypt(actEncr);],,confirmRC4,63-63,[		SecretKeySpec skeySpec = new SecretKeySpec(k2.getBytes(), "RC4");],,confirmRC4,70-70,[		byte[] origData = origText.getBytes();],,
PERFORMANCE,DM_FP_NUMBER_CTOR,org/apache/poi/hssf/usermodel/DVConstraint.java,convertDate,262-262,[		return new Double(HSSFDateUtil.getExcelDate(dateVal));],,
PERFORMANCE,DM_FP_NUMBER_CTOR,org/apache/poi/hssf/usermodel/DVConstraint.java,convertNumber,227-227,[			return new Double(numberStr);],,
PERFORMANCE,DM_FP_NUMBER_CTOR,org/apache/poi/hssf/usermodel/DVConstraint.java,convertTime,241-241,[		return new Double(HSSFDateUtil.convertTime(timeStr));],,
PERFORMANCE,DM_FP_NUMBER_CTOR,org/apache/poi/hssf/usermodel/DVConstraint.java,setValue1,362-362,[		_value1 = new Double(value1);],,
PERFORMANCE,DM_FP_NUMBER_CTOR,org/apache/poi/hssf/usermodel/DVConstraint.java,setValue2,376-376,[		_value2 = new Double(value2);],,
CORRECTNESS,DMI_INVOKING_TOSTRING_ON_ARRAY,org/apache/poi/hssf/usermodel/DummyGraphics2d.java,drawBytes,405-405,[        System.out.println( "data = " + data );],,
CORRECTNESS,DMI_INVOKING_TOSTRING_ON_ARRAY,org/apache/poi/hssf/usermodel/DummyGraphics2d.java,drawChars,415-415,[        System.out.println( "data = " + data.toString() );],,
CORRECTNESS,DMI_INVOKING_TOSTRING_ON_ARRAY,org/apache/poi/hssf/usermodel/DummyGraphics2d.java,drawPolygon,547-547,[        System.out.println( "xPoints = " + xPoints );],,
CORRECTNESS,DMI_INVOKING_TOSTRING_ON_ARRAY,org/apache/poi/hssf/usermodel/DummyGraphics2d.java,drawPolygon,548-548,[        System.out.println( "yPoints = " + yPoints );],,
CORRECTNESS,DMI_INVOKING_TOSTRING_ON_ARRAY,org/apache/poi/hssf/usermodel/DummyGraphics2d.java,drawPolyline,557-557,[        System.out.println( "xPoints = " + xPoints );],,
CORRECTNESS,DMI_INVOKING_TOSTRING_ON_ARRAY,org/apache/poi/hssf/usermodel/DummyGraphics2d.java,drawPolyline,558-558,[        System.out.println( "yPoints = " + yPoints );],,
CORRECTNESS,DMI_INVOKING_TOSTRING_ON_ARRAY,org/apache/poi/hssf/usermodel/DummyGraphics2d.java,fillPolygon,648-648,[        System.out.println( "xPoints = " + xPoints );],,
CORRECTNESS,DMI_INVOKING_TOSTRING_ON_ARRAY,org/apache/poi/hssf/usermodel/DummyGraphics2d.java,fillPolygon,649-649,[        System.out.println( "yPoints = " + yPoints );],,
BAD_PRACTICE,FI_EXPLICIT_INVOCATION,org/apache/poi/hssf/usermodel/DummyGraphics2d.java,finalize,677-677,[        g2D.finalize();],,
BAD_PRACTICE,FI_MISSING_SUPER_CALL,org/apache/poi/hssf/usermodel/DummyGraphics2d.java,finalize,676-678,[        System.out.println( "finalize():" );,         g2D.finalize();,     }],,
MALICIOUS_CODE,FI_PUBLIC_SHOULD_BE_PROTECTED,org/apache/poi/hssf/usermodel/DummyGraphics2d.java,finalize,676-678,[        System.out.println( "finalize():" );,         g2D.finalize();,     }],,
CORRECTNESS,NP_NULL_ON_SOME_PATH,org/apache/poi/hssf/usermodel/FontDetails.java,getCharWidth,74-74,[        return widthInteger.intValue();],,getCharWidth,71-71,[        if (widthInteger == null && c != 'W') {],,
STYLE,SF_SWITCH_FALLTHROUGH,org/apache/poi/hssf/usermodel/HSSFCell.java,setCellErrorValue,775-777,[                setCellType(CELL_TYPE_ERROR, false, row, col, styleIndex);,             case CELL_TYPE_ERROR:,                 (( BoolErrRecord ) _record).setValue(errorCode);],,
STYLE,SF_SWITCH_FALLTHROUGH,org/apache/poi/hssf/usermodel/HSSFCell.java,setCellValue,474-476,[                    setCellType(CELL_TYPE_NUMERIC, false, row, col, styleIndex);,                 case CELL_TYPE_NUMERIC:,                     (( NumberRecord ) _record).setValue(value);],,
STYLE,SF_SWITCH_FALLTHROUGH,org/apache/poi/hssf/usermodel/HSSFCell.java,setCellValue,751-753,[                setCellType(CELL_TYPE_BOOLEAN, false, row, col, styleIndex);,             case CELL_TYPE_BOOLEAN:,                 (( BoolErrRecord ) _record).setValue(value);],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/poi/hssf/usermodel/HSSFCell.java,<init>,184-194,[        switch (_cellType),         {,             case CELL_TYPE_STRING :,                 _stringValue = new HSSFRichTextString(book.getWorkbook(), (LabelSSTRecord ) cval);,                 break;, ,             case CELL_TYPE_BLANK :,                 break;, ,             case CELL_TYPE_FORMULA :,                 _stringValue=new HSSFRichTextString(((FormulaRecordAggregate) cval).getStringValue());],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/poi/hssf/usermodel/HSSFCell.java,setCellType,304-426,[        switch (cellType),         {, ,             case CELL_TYPE_FORMULA :,                 FormulaRecordAggregate frec;, ,                 if (cellType != _cellType) {,                     frec = _sheet.getSheet().getRowsAggregate().createFormula(row, col);,                 } else {,                     frec = (FormulaRecordAggregate) _record;,                     frec.setRow(row);,                     frec.setColumn(col);,                 },                 if (setValue),                 {,                     frec.getFormulaRecord().setValue(getNumericCellValue());,                 },                 frec.setXFIndex(styleIndex);,                 _record = frec;,                 break;, ,             case CELL_TYPE_NUMERIC :,                 NumberRecord nrec = null;, ,                 if (cellType != _cellType),                 {,                     nrec = new NumberRecord();,                 },                 else,                 {,                     nrec = ( NumberRecord ) _record;,                 },                 nrec.setColumn(col);,                 if (setValue),                 {,                     nrec.setValue(getNumericCellValue());,                 },                 nrec.setXFIndex(styleIndex);,                 nrec.setRow(row);,                 _record = nrec;,                 break;, ,             case CELL_TYPE_STRING :,                 LabelSSTRecord lrec;, ,                 if (cellType == _cellType) {,                     lrec = (LabelSSTRecord) _record;,                 } else {,                     lrec = new LabelSSTRecord();,                     lrec.setColumn(col);,                     lrec.setRow(row);,                     lrec.setXFIndex(styleIndex);,                 },                 if (setValue) {,                     String str = convertCellValueToString();,                     int sstIndex = _book.getWorkbook().addSSTString(new UnicodeString(str));,                     lrec.setSSTIndex(sstIndex);,                     UnicodeString us = _book.getWorkbook().getSSTString(sstIndex);,                     _stringValue = new HSSFRichTextString();,                     _stringValue.setUnicodeString(us);,                 },                 _record = lrec;,                 break;, ,             case CELL_TYPE_BLANK :,                 BlankRecord brec = null;, ,                 if (cellType != _cellType),                 {,                     brec = new BlankRecord();,                 },                 else,                 {,                     brec = ( BlankRecord ) _record;,                 },                 brec.setColumn(col);, ,                 // During construction the cellStyle may be null for a Blank cell.,                 brec.setXFIndex(styleIndex);,                 brec.setRow(row);,                 _record = brec;,                 break;, ,             case CELL_TYPE_BOOLEAN :,                 BoolErrRecord boolRec = null;, ,                 if (cellType != _cellType),                 {,                     boolRec = new BoolErrRecord();,                 },                 else,                 {,                     boolRec = ( BoolErrRecord ) _record;,                 },                 boolRec.setColumn(col);,                 if (setValue),                 {,                     boolRec.setValue(convertCellValueToBoolean());,                 },                 boolRec.setXFIndex(styleIndex);,                 boolRec.setRow(row);,                 _record = boolRec;,                 break;, ,             case CELL_TYPE_ERROR :,                 BoolErrRecord errRec = null;, ,                 if (cellType != _cellType),                 {,                     errRec = new BoolErrRecord();,                 },                 else,                 {,                     errRec = ( BoolErrRecord ) _record;,                 },                 errRec.setColumn(col);,                 if (setValue),                 {,                     errRec.setValue((byte)HSSFErrorConstants.ERROR_VALUE);,                 },                 errRec.setXFIndex(styleIndex);,                 errRec.setRow(row);,                 _record = errRec;],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/poi/hssf/usermodel/HSSFCell.java,setHyperlink,1159-1168,[        switch(link.getType()){,             case HSSFHyperlink.LINK_EMAIL:,             case HSSFHyperlink.LINK_URL:,                 link.setLabel("url");,                 break;,             case HSSFHyperlink.LINK_FILE:,                 link.setLabel("file");,                 break;,             case HSSFHyperlink.LINK_DOCUMENT:,                 link.setLabel("place");],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/poi/hssf/usermodel/HSSFChart.java,,208-208,[				lastChart.chartTitleFormat =],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/poi/hssf/usermodel/HSSFChart.java,insertData,978-985,[			switch(data.getLinkType()){, 				case 0: dataName = data;, 				break;, 				case 1: dataValues = data;, 				break;, 				case 2: dataCategoryLabels = data;, 				break;, 				case 3: dataSecondaryCategoryLabels = data;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/poi/hssf/usermodel/HSSFChart.java,,965-1146,[	public class HSSFSeries {, 		private SeriesRecord series;, 		private SeriesTextRecord seriesTitleText;, 		private LinkedDataRecord dataName;, 		private LinkedDataRecord dataValues;, 		private LinkedDataRecord dataCategoryLabels;, 		private LinkedDataRecord dataSecondaryCategoryLabels;, , 		/* package */ HSSFSeries(SeriesRecord series) {, 			this.series = series;, 		}, , 		/* package */ void insertData(LinkedDataRecord data){, 			switch(data.getLinkType()){, 				case 0: dataName = data;, 				break;, 				case 1: dataValues = data;, 				break;, 				case 2: dataCategoryLabels = data;, 				break;, 				case 3: dataSecondaryCategoryLabels = data;, 				break;, 			}, 		}, 		, 		/* package */ void setSeriesTitleText(SeriesTextRecord seriesTitleText), 		{, 			this.seriesTitleText = seriesTitleText;, 		}, 		, 		public short getNumValues() {, 			return series.getNumValues();, 		}, 		/**, 		 * See {@link SeriesRecord}, 		 */, 		public short getValueType() {, 			return series.getValuesDataType();, 		}, , 		/**, 		 * Returns the series' title, if there is one,, 		 *  or null if not, 		 */, 		public String getSeriesTitle() {, 			if(seriesTitleText != null) {, 				return seriesTitleText.getText();, 			}, 			return null;, 		}, , 		/**, 		 * Changes the series' title, but only if there, 		 *  was one already., 		 * TODO - add in the records if not, 		 */, 		public void setSeriesTitle(String title) {, 			if(seriesTitleText != null) {, 				seriesTitleText.setText(title);, 			} else {, 				throw new IllegalStateException("No series title found to change");, 			}, 		}, , 		/**, 		 * @return record with data names, 		 */, 		public LinkedDataRecord getDataName(){, 			return dataName;, 		}, 		, 		/**, 		 * @return record with data values, 		 */, 		public LinkedDataRecord getDataValues(){, 			return dataValues;, 		}, 		, 		/**, 		 * @return record with data category labels, 		 */, 		public LinkedDataRecord getDataCategoryLabels(){, 			return dataCategoryLabels;, 		}, 		, 		/**, 		 * @return record with data secondary category labels, 		 */, 		public LinkedDataRecord getDataSecondaryCategoryLabels() {, 			return dataSecondaryCategoryLabels;, 		}, 		, 		/**, 		 * @return record with series, 		 */, 		public SeriesRecord getSeries() {, 			return series;, 		}, 		, 		private CellRangeAddressBase getCellRange(LinkedDataRecord linkedDataRecord) {, 			if (linkedDataRecord == null), 			{, 				return null ;, 			}, 			, 			int firstRow = 0;, 			int lastRow = 0;, 			int firstCol = 0;, 			int lastCol = 0;, 			, 			for (Ptg ptg : linkedDataRecord.getFormulaOfLink()) {, 				if (ptg instanceof AreaPtgBase) {, 					AreaPtgBase areaPtg = (AreaPtgBase) ptg;, 					, 					firstRow = areaPtg.getFirstRow();, 					lastRow = areaPtg.getLastRow();, 					, 					firstCol = areaPtg.getFirstColumn();, 					lastCol = areaPtg.getLastColumn();, 				}, 			}, 			, 			return new CellRangeAddress(firstRow, lastRow, firstCol, lastCol);, 		}, 		, 		public CellRangeAddressBase getValuesCellRange() {, 			return getCellRange(dataValues);, 		}, 	, 		public CellRangeAddressBase getCategoryLabelsCellRange() {, 			return getCellRange(dataCategoryLabels);, 		}, 	, 		private Integer setVerticalCellRange(LinkedDataRecord linkedDataRecord,, 				                             CellRangeAddressBase range) {, 			if (linkedDataRecord == null), 			{, 				return null;, 			}, 			, 			List<Ptg> ptgList = new ArrayList<Ptg>();, 			, 			int rowCount = (range.getLastRow() - range.getFirstRow()) + 1;, 			int colCount = (range.getLastColumn() - range.getFirstColumn()) + 1;, 			, 			for (Ptg ptg : linkedDataRecord.getFormulaOfLink()) {, 				if (ptg instanceof AreaPtgBase) {, 					AreaPtgBase areaPtg = (AreaPtgBase) ptg;, 					, 					areaPtg.setFirstRow(range.getFirstRow());, 					areaPtg.setLastRow(range.getLastRow());, 					, 					areaPtg.setFirstColumn(range.getFirstColumn());, 					areaPtg.setLastColumn(range.getLastColumn());, 					ptgList.add(areaPtg);, 				}, 			}, 			, 			linkedDataRecord.setFormulaOfLink(ptgList.toArray(new Ptg[ptgList.size()]));, 			, 			return rowCount * colCount;, 		}, 		, 		public void setValuesCellRange(CellRangeAddressBase range) {, 			Integer count = setVerticalCellRange(dataValues, range);, 			if (count == null), 			{, 				return;, 			}, 			, 			series.setNumValues((short)(int)count);, 		}, 		, 		public void setCategoryLabelsCellRange(CellRangeAddressBase range) {, 			Integer count = setVerticalCellRange(dataCategoryLabels, range);, 			if (count == null), 			{, 				return;, 			}, 			, 			series.setNumCategories((short)(int)count);, 		}],,
I18N,DM_CONVERT_CASE,org/apache/poi/hssf/usermodel/HSSFDataFormat.java,getFormat,103-103,[		if (pFormat.toUpperCase().equals("TEXT")) {],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/poi/hssf/usermodel/HSSFDataValidationHelper.java,,36-36,[		this.sheet = sheet;],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/poi/hssf/usermodel/HSSFHyperlink.java,<init>,68-77,[        switch(type){,             case LINK_URL:,             case LINK_EMAIL:,                 record.newUrlLink();,                 break;,             case LINK_FILE:,                 record.newFileLink();,                 break;,             case LINK_DOCUMENT:,                 record.newDocumentLink();],,
I18N,DM_CONVERT_CASE,org/apache/poi/hssf/usermodel/HSSFPalette.java,getGnumericPart,236-236,[                s = Integer.toHexString(c).toUpperCase();],,
BAD_PRACTICE,HE_EQUALS_USE_HASHCODE,org/apache/poi/hssf/usermodel/HSSFRichTextString.java,equals,309-312,[      if (o instanceof HSSFRichTextString) {,         return _string.equals(((HSSFRichTextString)o)._string);,       },       return false;],,
BAD_PRACTICE,HE_EQUALS_USE_HASHCODE,org/apache/poi/hssf/usermodel/HSSFRow.java,equals,688-698,[        if (!(obj instanceof HSSFRow)),         {,             return false;,         },         HSSFRow loc = (HSSFRow) obj;, ,         if (this.getRowNum() == loc.getRowNum()),         {,             return true;,         },         return false;],,
I18N,DM_DEFAULT_ENCODING,org/apache/poi/hssf/usermodel/HSSFSheet.java,dumpDrawingRecords,1641-1641,[        PrintWriter w = new PrintWriter(System.out);],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NULL_VALUE,org/apache/poi/hssf/usermodel/HSSFSheet.java,createDrawingPatriarch,1665-1665,[            if(_patriarch == null){],,
I18N,DM_DEFAULT_ENCODING,org/apache/poi/hssf/usermodel/HSSFWorkbook.java,dumpDrawingGroupRecords,1547-1547,[        PrintWriter w = new PrintWriter(System.out);],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/poi/hssf/usermodel/HSSFWorkbook.java,addPicture,1585-1603,[        switch (format),         {,             case PICTURE_TYPE_EMF:,                 blipRecord.setOptions(HSSFPictureData.MSOBI_EMF);,                 break;,             case PICTURE_TYPE_WMF:,                 blipRecord.setOptions(HSSFPictureData.MSOBI_WMF);,                 break;,             case PICTURE_TYPE_PICT:,                 blipRecord.setOptions(HSSFPictureData.MSOBI_PICT);,                 break;,             case PICTURE_TYPE_PNG:,                 blipRecord.setOptions(HSSFPictureData.MSOBI_PNG);,                 break;,             case HSSFWorkbook.PICTURE_TYPE_JPEG:,                 blipRecord.setOptions(HSSFPictureData.MSOBI_JPEG);,                 break;,             case HSSFWorkbook.PICTURE_TYPE_DIB:,                 blipRecord.setOptions(HSSFPictureData.MSOBI_DIB);],,
BAD_PRACTICE,NM_SAME_SIMPLE_NAME_AS_INTERFACE,org/apache/poi/hssf/usermodel/HeaderFooter.java,,26-302,[	protected HeaderFooter() {, 		//, 	}, 	, 	/**, 	 * @return the internal text representation (combining center, left and right parts)., 	 * Possibly empty string if no header or footer is set.  Never <code>null</code>., 	 */, 	protected abstract String getRawText(); , 	, 	private String[] splitParts() {, 		String text = getRawText();, 		// default values, 		String _left = "";, 		String _center = "";, 		String _right = "";, , outer:, 		while (text.length() > 1) {, 			if (text.charAt(0) != '&') {, 				// Mimics the behaviour of Excel, which would put it in the center., 				_center = text;, 				break;, 			}, 			int pos = text.length();, 			switch (text.charAt(1)) {, 			case 'L':, 				if (text.indexOf("&C") >= 0) {, 					pos = Math.min(pos, text.indexOf("&C"));, 				}, 				if (text.indexOf("&R") >= 0) {, 					pos = Math.min(pos, text.indexOf("&R"));, 				}, 				_left = text.substring(2, pos);, 				text = text.substring(pos);, 				break;, 			case 'C':, 				if (text.indexOf("&L") >= 0) {, 					pos = Math.min(pos, text.indexOf("&L"));, 				}, 				if (text.indexOf("&R") >= 0) {, 					pos = Math.min(pos, text.indexOf("&R"));, 				}, 				_center = text.substring(2, pos);, 				text = text.substring(pos);, 				break;, 			case 'R':, 				if (text.indexOf("&C") >= 0) {, 					pos = Math.min(pos, text.indexOf("&C"));, 				}, 				if (text.indexOf("&L") >= 0) {, 					pos = Math.min(pos, text.indexOf("&L"));, 				}, 				_right = text.substring(2, pos);, 				text = text.substring(pos);, 				break;, 			default:, 				// Mimics the behaviour of Excel, which would put it in the center., 				_center = text;, 				break outer;, 			}, 		}, 		return new String[] { _left, _center, _right, };, 	}, , 	/**, 	 * @return the left side of the header or footer., 	 */, 	public final String getLeft() {, 		return splitParts()[0];, 	}, , 	/**, 	 * @param newLeft The string to set as the left side., 	 */, 	public final void setLeft(String newLeft) {, 		updatePart(0, newLeft); , 	}, , 	/**, 	 * @return the center of the header or footer., 	 */, 	public final String getCenter() {, 		return splitParts()[1];, 	}, , 	/**, 	 * @param newCenter The string to set as the center., 	 */, 	public final void setCenter(String newCenter) {, 		updatePart(1, newCenter); , 	}, , 	/**, 	 * @return The right side of the header or footer., 	 */, 	public final String getRight() {, 		return splitParts()[2];, 	}, , 	/**, 	 * @param newRight The string to set as the right side., 	 */, 	public final void setRight(String newRight) {, 		updatePart(2, newRight); , 	}, 	, 	private void updatePart(int partIndex, String newValue) {, 		String[] parts = splitParts();, 		parts[partIndex] = newValue == null ? "" : newValue;, 		updateHeaderFooterText(parts);, 	}, 	/**, 	 * Creates the complete footer string based on the left, center, and middle, 	 * strings., 	 */, 	private void updateHeaderFooterText(String[] parts) {, 		String _left = parts[0];, 		String _center = parts[1];, 		String _right = parts[2];, 		, 		if (_center.length() < 1 && _left.length() < 1 && _right.length() < 1) {, 			setHeaderFooterText("");, 			return;, 		}, 		StringBuilder sb = new StringBuilder(64);, 		sb.append("&C");, 		sb.append(_center);, 		sb.append("&L");, 		sb.append(_left);, 		sb.append("&R");, 		sb.append(_right);, 		String text = sb.toString();, 		setHeaderFooterText(text);, 	}, , 	/**, 	 * @param text the new header footer text (contains mark-up tags). Possibly, 	 *            empty string never <code>null</code>, 	 */, 	protected abstract void setHeaderFooterText(String text);, , 	/**, 	 * @param size, 	 *            the new font size, 	 * @return The mark-up tag representing a new font size, 	 */, 	public static String fontSize(short size) {, 		return "&" + size;, 	}, , 	/**, 	 * @param font, 	 *            the new font, 	 * @param style, 	 *            the fonts style, one of regular, italic, bold, italic bold or, 	 *            bold italic, 	 * @return The mark-up tag representing a new font size, 	 */, 	public static String font(String font, String style) {, 		return "&\"" + font + "," + style + "\"";, 	}, , 	/**, 	 * @return The mark-up tag representing the current page number, 	 */, 	public static String page() {, 		return MarkupTag.PAGE_FIELD.getRepresentation();, 	}, , 	/**, 	 * @return The mark-up tag representing the number of pages, 	 */, 	public static String numPages() {, 		return MarkupTag.NUM_PAGES_FIELD.getRepresentation();, 	}, , 	/**, 	 * @return The mark-up tag representing the current date date, 	 */, 	public static String date() {, 		return MarkupTag.DATE_FIELD.getRepresentation();, 	}, , 	/**, 	 * @return The mark-up tag representing current time, 	 */, 	public static String time() {, 		return MarkupTag.TIME_FIELD.getRepresentation();, 	}, , 	/**, 	 * @return The mark-up tag representing the current file name, 	 */, 	public static String file() {, 		return MarkupTag.FILE_FIELD.getRepresentation();, 	}, , 	/**, 	 * @return The mark-up tag representing the current tab (sheet) name, 	 */, 	public static String tab() {, 		return MarkupTag.SHEET_NAME_FIELD.getRepresentation();, 	}, , 	/**, 	 * @return The mark-up tag for start bold, 	 */, 	public static String startBold() {, 		return MarkupTag.BOLD_FIELD.getRepresentation();, 	}, , 	/**, 	 * @return The mark-up tag for end bold, 	 */, 	public static String endBold() {, 		return MarkupTag.BOLD_FIELD.getRepresentation();, 	}, , 	/**, 	 * @return The mark-up tag for start underline, 	 */, 	public static String startUnderline() {, 		return MarkupTag.UNDERLINE_FIELD.getRepresentation();, 	}, , 	/**, 	 * @return The mark-up tag for end underline, 	 */, 	public static String endUnderline() {, 		return MarkupTag.UNDERLINE_FIELD.getRepresentation();, 	}, , 	/**, 	 * @return The mark-up tag for start double underline, 	 */, 	public static String startDoubleUnderline() {, 		return MarkupTag.DOUBLE_UNDERLINE_FIELD.getRepresentation();, 	}, , 	/**, 	 * @return The mark-up tag for end double underline, 	 */, 	public static String endDoubleUnderline() {, 		return MarkupTag.DOUBLE_UNDERLINE_FIELD.getRepresentation();, 	}, , 	/**, 	 * Removes any fields (eg macros, page markers etc) from the string., 	 * Normally used to make some text suitable for showing to humans, and the, 	 * resultant text should not normally be saved back into the document!, 	 */, 	public static String stripFields(String pText) {, 		int pos;, , 		// Check we really got something to work on, 		if (pText == null || pText.length() == 0) {, 			return pText;, 		}, , 		String text = pText;, , 		// Firstly, do the easy ones which are static, 		for (MarkupTag mt : MarkupTag.values()) {, 			String seq = mt.getRepresentation();, 			while ((pos = text.indexOf(seq)) > -1) {, 				text = text.substring(0, pos) + text.substring(pos + seq.length());, 			}, 		}, , 		// Now do the tricky, dynamic ones, 		// These are things like font sizes and font names, 		text = text.replaceAll("\\&\\d+", "");, 		text = text.replaceAll("\\&\".*?,.*?\"", "");, , 		// All done, 		return text;],,
MT_CORRECTNESS,LI_LAZY_INIT_UPDATE_STATIC,org/apache/poi/hssf/usermodel/StaticFontMetrics.java,getFontDetails,55-58,[		if (fontMetricsProps == null) {, 			InputStream metricsIn = null;, 			try {, 				fontMetricsProps = new Properties();],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/poi/hssf/usermodel/StreamUtility.java,toPrimitiveIntArray,120-120,[			return null;],,
PERFORMANCE,DM_STRING_TOSTRING,org/apache/poi/hssf/usermodel/TestBugs.java,test48180,1520-1520,[        assertEquals("test ", cell1.getStringCellValue().toString());],,
STYLE,RV_CHECK_FOR_POSITIVE_INDEXOF,org/apache/poi/hssf/usermodel/TestBugs.java,test42618,627-627,[                    && e.getMessage().indexOf("ConcatPtg") > 0) {],,
STYLE,RV_RETURN_VALUE_IGNORED_NO_SIDE_EFFECT,org/apache/poi/hssf/usermodel/TestBugs.java,test27852,322-322,[          name.getNameName();],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/poi/hssf/usermodel/TestBugs.java,unicodeString,298-304,[        String ss = cell.getRichStringCellValue().getString();,         char s[] = ss.toCharArray();,         StringBuffer sb = new StringBuffer();,         for (int x=0;x<s.length;x++) {,             sb.append("\\u").append(Integer.toHexString(s[x]));,         },         return sb.toString();],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/poi/hssf/usermodel/TestCellStyle.java,testDataStyle,95-95,[        FileOutputStream out  = new FileOutputStream(file);],,testDataStyle,96-96,[        HSSFWorkbook     wb   = new HSSFWorkbook();],,testDataStyle,97-97,[        HSSFSheet        s    = wb.createSheet();],,testDataStyle,98-98,[        HSSFCellStyle    cs   = wb.createCellStyle();],,testDataStyle,99-99,[        HSSFRow row = s.createRow(0);],,testDataStyle,102-102,[        HSSFCell cell = row.createCell(1);],,testDataStyle,103-103,[        cs.setDataFormat(HSSFDataFormat.getBuiltinFormat("m/d/yy"));],,testDataStyle,104-104,[        cell.setCellStyle(cs);],,testDataStyle,105-105,[        cell.setCellValue(new Date());],,testDataStyle,108-108,[        cell = row.createCell(2);],,testDataStyle,109-109,[        cs.setDataFormat(HSSFDataFormat.getBuiltinFormat("m/d/yy"));],,testDataStyle,110-110,[        cell.setCellStyle(cs);],,testDataStyle,111-111,[        Calendar cal = Calendar.getInstance();],,testDataStyle,112-112,[        cal.setTime(new Date());],,testDataStyle,113-113,[        cell.setCellValue(cal);],,testDataStyle,115-115,[        wb.write(out);],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/poi/hssf/usermodel/TestCellStyle.java,testWriteSheetFont,55-55,[        FileOutputStream out  = new FileOutputStream(file);],,testWriteSheetFont,56-56,[        HSSFWorkbook     wb   = new HSSFWorkbook();],,testWriteSheetFont,57-57,[        HSSFSheet        s    = wb.createSheet();],,testWriteSheetFont,58-58,[        HSSFRow          r    = null;],,testWriteSheetFont,59-59,[        HSSFCell         c    = null;],,testWriteSheetFont,60-60,[        HSSFFont         fnt  = wb.createFont();],,testWriteSheetFont,61-61,[        HSSFCellStyle    cs   = wb.createCellStyle();],,testWriteSheetFont,63-63,[        fnt.setColor(HSSFFont.COLOR_RED);],,testWriteSheetFont,64-64,[        fnt.setBoldweight(HSSFFont.BOLDWEIGHT_BOLD);],,testWriteSheetFont,65-65,[        cs.setFont(fnt);],,testWriteSheetFont,66-66,[        for (int rownum = 0; rownum < 100; rownum++) {],,testWriteSheetFont,79-79,[        wb.write(out);],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/poi/hssf/usermodel/TestCellStyle.java,testWriteSheetStyle,166-166,[        FileOutputStream out  = new FileOutputStream(file);],,testWriteSheetStyle,167-167,[        HSSFWorkbook     wb   = new HSSFWorkbook();],,testWriteSheetStyle,168-168,[        HSSFSheet        s    = wb.createSheet();],,testWriteSheetStyle,169-169,[        HSSFRow          r    = null;],,testWriteSheetStyle,170-170,[        HSSFCell         c    = null;],,testWriteSheetStyle,171-171,[        HSSFFont         fnt  = wb.createFont();],,testWriteSheetStyle,172-172,[        HSSFCellStyle    cs   = wb.createCellStyle();],,testWriteSheetStyle,173-173,[        HSSFCellStyle    cs2  = wb.createCellStyle();],,testWriteSheetStyle,175-175,[        cs.setBorderBottom(HSSFCellStyle.BORDER_THIN);],,testWriteSheetStyle,176-176,[        cs.setBorderLeft(HSSFCellStyle.BORDER_THIN);],,testWriteSheetStyle,177-177,[        cs.setBorderRight(HSSFCellStyle.BORDER_THIN);],,testWriteSheetStyle,178-178,[        cs.setBorderTop(HSSFCellStyle.BORDER_THIN);],,testWriteSheetStyle,179-179,[        cs.setFillForegroundColor(( short ) 0xA);],,testWriteSheetStyle,180-180,[        cs.setFillPattern(( short ) 1);],,testWriteSheetStyle,181-181,[        fnt.setColor(( short ) 0xf);],,testWriteSheetStyle,182-182,[        fnt.setItalic(true);],,testWriteSheetStyle,183-183,[        cs2.setFillForegroundColor(( short ) 0x0);],,testWriteSheetStyle,184-184,[        cs2.setFillPattern(( short ) 1);],,testWriteSheetStyle,185-185,[        cs2.setFont(fnt);],,testWriteSheetStyle,186-186,[        for (int rownum = 0; rownum < 100; rownum++) {],,testWriteSheetStyle,200-200,[        wb.write(out);],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/poi/hssf/usermodel/TestDataValidation.java,compareStreams,107-123,[		InputStream isB = new ByteArrayInputStream(generatedContent);, , 		// The allowable regions where the generated file can differ from the , 		// proof should be small (i.e. much less than 1K), 		int[] allowableDifferenceRegions = { , 				0x0228, 16,  // a region of the file containing the OS username, 				0x506C, 8,   // See RootProperty (super fields _seconds_2 and _days_2), 		};, 		int[] diffs = StreamUtility.diffStreams(isA, isB, allowableDifferenceRegions);, 		if (diffs == null) {, 			return true;, 		}, 		System.err.println("Diff from proof: ");, 		for (int i = 0; i < diffs.length; i++) {, 			System.err.println("diff at offset: 0x" + Integer.toHexString(diffs[i]));, 		}, 		return false;],,
PERFORMANCE,DM_STRING_TOSTRING,org/apache/poi/hssf/usermodel/TestEscherGraphics.java,testDrawString,94-94,[        assertEquals("This is a test", t.getString().getString().toString());],,
PERFORMANCE,DM_STRING_TOSTRING,org/apache/poi/hssf/usermodel/TestEscherGraphics2d.java,testDrawString,47-47,[		assertEquals("This is a test", t.getString().getString().toString());],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION,org/apache/poi/hssf/usermodel/TestFormulas.java,test27272_1,867-867,[        wb.write(new FileOutputStream(outF));],,test27272_1,868-868,[        System.out.println("Open "+outF.getAbsolutePath()+" in Excel");],,test27272_1,869-869,[    }],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION,org/apache/poi/hssf/usermodel/TestFormulas.java,test27272_2,875-875,[        wb.write(new FileOutputStream(outF));],,test27272_2,876-876,[        System.out.println("Open "+outF.getAbsolutePath()+" in Excel");],,test27272_2,877-877,[    }],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION,org/apache/poi/hssf/usermodel/TestFormulas.java,testComplexSheetRefs,858-858,[         sb.write(new FileOutputStream(file));],,testComplexSheetRefs,859-859,[    }],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/poi/hssf/usermodel/TestFormulas.java,testRVAoperands,603-603,[        FileOutputStream out    = new FileOutputStream(file);],,testRVAoperands,604-604,[        HSSFWorkbook     wb     = new HSSFWorkbook();],,testRVAoperands,605-605,[        HSSFSheet        s      = wb.createSheet();],,testRVAoperands,606-606,[        HSSFRow          r      = null;],,testRVAoperands,607-607,[        HSSFCell         c      = null;],,testRVAoperands,610-610,[        r = s.createRow(0);],,testRVAoperands,612-612,[        c = r.createCell(0);],,testRVAoperands,613-613,[        c.setCellFormula("A3+A2");],,testRVAoperands,614-614,[        c=r.createCell(1);],,testRVAoperands,615-615,[        c.setCellFormula("AVERAGE(A3,A2)");],,testRVAoperands,616-616,[        c=r.createCell(2);],,testRVAoperands,617-617,[        c.setCellFormula("ROW(A3)");],,testRVAoperands,618-618,[        c=r.createCell(3);],,testRVAoperands,619-619,[        c.setCellFormula("AVERAGE(A2:A3)");],,testRVAoperands,620-620,[        c=r.createCell(4);],,testRVAoperands,621-621,[        c.setCellFormula("POWER(A2,A3)");],,testRVAoperands,622-622,[        c=r.createCell(5);],,testRVAoperands,623-623,[        c.setCellFormula("SIN(A2)");],,testRVAoperands,625-625,[        c=r.createCell(6);],,testRVAoperands,626-626,[        c.setCellFormula("SUM(A2:A3)");],,testRVAoperands,628-628,[        c=r.createCell(7);],,testRVAoperands,629-629,[        c.setCellFormula("SUM(A2,A3)");],,testRVAoperands,631-631,[        r = s.createRow(1);c=r.createCell(0); c.setCellValue(2.0);],,testRVAoperands,632-632,[         r = s.createRow(2);c=r.createCell(0); c.setCellValue(3.0);],,testRVAoperands,634-634,[        wb.write(out);],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/poi/hssf/usermodel/TestHSSFDataFormat.java,test51378,68-68,[                        _logger.log(POILogger.WARN, cell + ": " + fmt);],,
MALICIOUS_CODE,DP_DO_INSIDE_DO_PRIVILEGED,org/apache/poi/hssf/usermodel/TestHSSFName.java,getNameRecord,58-58,[        f.setAccessible(true);],,
PERFORMANCE,WMI_WRONG_MAP_ITERATOR,org/apache/poi/hssf/usermodel/TestHSSFPalette.java,compareToDefaults,276-276,[            HSSFColor expectedColor = (HSSFColor) colors.get(index);],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/poi/hssf/usermodel/TestHSSFPalette.java,,240-244,[        compareToDefaults(new ColorComparator() {,             public void compare(HSSFColor expected, HSSFColor palette),             {,                 assertEquals(expected.getHexString(), palette.getHexString());,             }],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/poi/hssf/usermodel/TestHSSFPalette.java,,258-266,[        compareToDefaults(new ColorComparator() {,             public void compare(HSSFColor expected, HSSFColor palette),             {,                 short[] s1 = expected.getTriplet();,                 short[] s2 = palette.getTriplet();,                 assertEquals(s1[0], s2[0]);,                 assertEquals(s1[1], s2[1]);,                 assertEquals(s1[2], s2[2]);,             }],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/poi/hssf/usermodel/TestHSSFSheet.java,testForceRecalculation,627-627,[        FileOutputStream fout = new FileOutputStream( tempFile );],,testForceRecalculation,628-628,[        workbook.write( fout );],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/poi/hssf/usermodel/TestHSSFSheet.java,testForceRecalculation,635-635,[        tempFile.delete();],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/poi/hssf/usermodel/TestWorkbook.java,testRepeatingColsRows,541-541,[        FileOutputStream fileOut = new FileOutputStream(file);],,testRepeatingColsRows,542-542,[        workbook.write(fileOut);],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/poi/hssf/usermodel/TestWorkbook.java,testWriteDataFormat,200-200,[        FileOutputStream out  = new FileOutputStream(file);],,testWriteDataFormat,201-201,[        HSSFWorkbook     wb   = new HSSFWorkbook();],,testWriteDataFormat,202-202,[        HSSFSheet        s    = wb.createSheet();],,testWriteDataFormat,203-203,[        HSSFRow          r    = null;],,testWriteDataFormat,204-204,[        HSSFCell         c    = null;],,testWriteDataFormat,205-205,[    HSSFDataFormat format = wb.createDataFormat();],,testWriteDataFormat,206-206,[    HSSFCellStyle    cs   = wb.createCellStyle();],,testWriteDataFormat,208-208,[    short df = format.getFormat("0.0");],,testWriteDataFormat,209-209,[    cs.setDataFormat(df);],,testWriteDataFormat,211-211,[    r = s.createRow(0);],,testWriteDataFormat,212-212,[    c = r.createCell(0);],,testWriteDataFormat,213-213,[    c.setCellStyle(cs);],,testWriteDataFormat,214-214,[    c.setCellValue(1.25);],,testWriteDataFormat,216-216,[        wb.write(out);],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/poi/hssf/usermodel/TestWorkbook.java,testWriteModifySheetSimple,115-115,[        FileOutputStream out  = new FileOutputStream(file);],,testWriteModifySheetSimple,116-116,[        HSSFWorkbook     wb   = new HSSFWorkbook();],,testWriteModifySheetSimple,117-117,[        HSSFSheet        s    = wb.createSheet();],,testWriteModifySheetSimple,118-118,[        HSSFRow          r    = null;],,testWriteModifySheetSimple,119-119,[        HSSFCell         c    = null;],,testWriteModifySheetSimple,121-121,[        for (int rownum = 0; rownum < 100; rownum++) {],,testWriteModifySheetSimple,133-133,[        for (int rownum = 0; rownum < 25; rownum++) {],,testWriteModifySheetSimple,137-137,[        for (int rownum = 75; rownum < 100; rownum++) {],,testWriteModifySheetSimple,141-141,[        wb.write(out);],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/poi/hssf/usermodel/TestWorkbook.java,testWriteSheetSimple,74-74,[        FileOutputStream out  = new FileOutputStream(file);],,testWriteSheetSimple,75-75,[        HSSFWorkbook     wb   = new HSSFWorkbook();],,testWriteSheetSimple,76-76,[        HSSFSheet        s    = wb.createSheet();],,testWriteSheetSimple,77-77,[        HSSFRow          r    = null;],,testWriteSheetSimple,78-78,[        HSSFCell         c    = null;],,testWriteSheetSimple,80-80,[        for (int rownum = 0; rownum < 100; rownum++) {],,testWriteSheetSimple,92-92,[        wb.write(out);],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/poi/hssf/usermodel/examples/AddDimensionedImage.java,,796-851,[        public int fromIndex = 0;,         public int toIndex = 0;,         public int inset = 0;, ,         /**,          * Create a new instance of the ClientAnchorDetail class using the,          * following parameters.,          *,          * @param fromIndex A primitive int that contains one of the,          *                  co-ordinates (row or column index) for the top left,          *                  hand corner of the image.,          * @param toIndex A primitive int that contains one of the,          *                co-ordinates (row or column index) for the bottom,          *                right hand corner of the image.,          * @param inset A primitive int that contains a value which indicates,          *              how far the image should be inset from the top or the,          *              left hand edge of a cell.,          */,         public ClientAnchorDetail(int fromIndex, int toIndex, int inset) {,             this.fromIndex = fromIndex;,             this.toIndex = toIndex;,             this.inset = inset;,         }, ,         /**,          * Get one of the number of the column or row that contains the cell,          * whose top left hand corner will be aligned with the top left hand,          * corner of the image.,          *,          * @return The value - row or column index - for one of the co-ordinates,          *         of the top left hand corner of the image.,          */,         public int getFromIndex() {,             return(this.fromIndex);,         }, ,         /**,          * Get one of the number of the column or row that contains the cell,          * whose top left hand corner will be aligned with the bottom righ hand,          * corner of the image.,          *,          * @return The value - row or column index - for one of the co-ordinates,          *         of the bottom right hand corner of the image.,          */,         public int getToIndex() {,             return(this.toIndex);,         }, ,         /**,          * Get the image's offset from the edge of a cell.,          *,          * @return How far either the right hand or bottom edge of the image is,          *         inset from the left hand or top edge of a cell.,          */,         public int getInset() {,             return(this.inset);],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/poi/hssf/usermodel/examples/AddDimensionedImage.java,,889-889,[        public static final int[] UNIT_OFFSET_MAP = new int[]],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/poi/hssf/usermodel/examples/EventExample.java,processRecord,45-83,[        switch (record.getSid()),         {,             // the BOFRecord can represent either the beginning of a sheet or the workbook,             case BOFRecord.sid:,                 BOFRecord bof = (BOFRecord) record;,                 if (bof.getType() == bof.TYPE_WORKBOOK),                 {,                     System.out.println("Encountered workbook");,                     // assigned to the class level member,                 } else if (bof.getType() == bof.TYPE_WORKSHEET),                 {,                     System.out.println("Encountered sheet reference");,                 },                 break;,             case BoundSheetRecord.sid:,                 BoundSheetRecord bsr = (BoundSheetRecord) record;,                 System.out.println("New sheet named: " + bsr.getSheetname());,                 break;,             case RowRecord.sid:,                 RowRecord rowrec = (RowRecord) record;,                 System.out.println("Row found, first column at ",                         + rowrec.getFirstCol() + " last column at " + rowrec.getLastCol());,                 break;,             case NumberRecord.sid:,                 NumberRecord numrec = (NumberRecord) record;,                 System.out.println("Cell found with value " + numrec.getValue(),                         + " at row " + numrec.getRow() + " and column " + numrec.getColumn());,                 break;,                 // SSTRecords store a array of unique strings used in Excel.,             case SSTRecord.sid:,                 sstrec = (SSTRecord) record;,                 for (int k = 0; k < sstrec.getNumUniqueStrings(); k++),                 {,                     System.out.println("String table value " + k + " = " + sstrec.getString(k));,                 },                 break;,             case LabelSSTRecord.sid:,                 LabelSSTRecord lrec = (LabelSSTRecord) record;,                 System.out.println("String cell found with value "],,
I18N,DM_CONVERT_CASE,org/apache/poi/hssf/usermodel/examples/HSSFReadWrite.java,main,201-201,[				if (args[1].toLowerCase().equals("write")) {],,main,216-216,[			} else if (args.length == 3 && args[2].toLowerCase().equals("modify1")) {],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/poi/hssf/usermodel/examples/HSSFReadWrite.java,testCreateSampleSheet,122-122,[		FileOutputStream out = new FileOutputStream(outputFilename);],,testCreateSampleSheet,123-123,[		wb.write(out);],,
STYLE,REC_CATCH_EXCEPTION,org/apache/poi/hssf/usermodel/examples/HSSFReadWrite.java,main,240-240,[		} catch (Exception e) {],,
STYLE,DMI_HARDCODED_ABSOLUTE_FILENAME,org/apache/poi/hssf/usermodel/examples/InCellLists.java,main,507-507,[        new InCellLists().demonstrateMethodCalls("C:/temp/Latest In Cell List.xls");],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/poi/hssf/usermodel/examples/InCellLists.java,,531-566,[        private String itemText = null;,         private ArrayList<String> lowerLevelItems = null;, ,         /**,          * Create a new instance of the MultiLevelListItem class using the,          * following parameters.,          *,          * @param itemText A String that encapsulates the text for the high,          *                 level list item.,          * @param lowerLevelItems An ArrayList whose elements encapsulate the,          *                        text for the associated lower level list,          *                        items.,          */,         public MultiLevelListItem(String itemText, ArrayList<String> lowerLevelItems) {,             this.itemText = itemText;,             this.lowerLevelItems = lowerLevelItems;,         }, ,         /**,          * Get the text for the high level list item.,          *,          * @return A String that encapsulates the text for the high level list,          *         item.,          */,         public String getItemText() {,             return(this.itemText);,         }, ,         /**,          * Get the text for the associated lower level list items.,          *,          * @return An ArrayList whose elements each encapsulate the text for a,          *         single associated lower level list item.,          */,         public ArrayList<String> getLowerLevelItems() {,             return(this.lowerLevelItems);],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/poi/hssf/usermodel/examples/Outlines.java,createCase1,77-77,[        FileOutputStream fileOut = new FileOutputStream(filename);],,createCase1,78-78,[        wb.write(fileOut);],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/poi/hssf/usermodel/examples/Outlines.java,createCase10,207-207,[        FileOutputStream fileOut = new FileOutputStream(filename);],,createCase10,208-208,[        wb.write(fileOut);],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/poi/hssf/usermodel/examples/Outlines.java,createCase11,223-223,[        FileOutputStream fileOut = new FileOutputStream(filename);],,createCase11,224-224,[        wb.write(fileOut);],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/poi/hssf/usermodel/examples/Outlines.java,createCase12,238-238,[        FileOutputStream fileOut = new FileOutputStream(filename);],,createCase12,239-239,[        wb.write(fileOut);],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/poi/hssf/usermodel/examples/Outlines.java,createCase13,255-255,[        FileOutputStream fileOut = new FileOutputStream(filename);],,createCase13,256-256,[        wb.write(fileOut);],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/poi/hssf/usermodel/examples/Outlines.java,createCase2,90-90,[        FileOutputStream fileOut = new FileOutputStream(filename);],,createCase2,91-91,[        wb.write(fileOut);],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/poi/hssf/usermodel/examples/Outlines.java,createCase3,104-104,[        FileOutputStream fileOut = new FileOutputStream(filename);],,createCase3,105-105,[        wb.write(fileOut);],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/poi/hssf/usermodel/examples/Outlines.java,createCase4,120-120,[        FileOutputStream fileOut = new FileOutputStream(filename);],,createCase4,121-121,[        wb.write(fileOut);],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/poi/hssf/usermodel/examples/Outlines.java,createCase5,137-137,[        FileOutputStream fileOut = new FileOutputStream(filename);],,createCase5,138-138,[        wb.write(fileOut);],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/poi/hssf/usermodel/examples/Outlines.java,createCase6,153-153,[        FileOutputStream fileOut = new FileOutputStream(filename);],,createCase6,154-154,[        wb.write(fileOut);],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/poi/hssf/usermodel/examples/Outlines.java,createCase7,165-165,[        FileOutputStream fileOut = new FileOutputStream(filename);],,createCase7,166-166,[        wb.write(fileOut);],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/poi/hssf/usermodel/examples/Outlines.java,createCase8,178-178,[        FileOutputStream fileOut = new FileOutputStream(filename);],,createCase8,179-179,[        wb.write(fileOut);],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/poi/hssf/usermodel/examples/Outlines.java,createCase9,192-192,[        FileOutputStream fileOut = new FileOutputStream(filename);],,createCase9,193-193,[        wb.write(fileOut);],,
BAD_PRACTICE,NM_SAME_SIMPLE_NAME_AS_SUPERCLASS,org/apache/poi/hssf/util/AreaReference.java,,28-37,[		super(reference);,     },     ,     /**,      * Creates an area ref from a pair of Cell References.,      * Also normalises such that the top-left,      */,     public AreaReference(CellReference topLeft, CellReference botRight) {, 		super(topLeft, botRight);,     }],,
BAD_PRACTICE,NM_SAME_SIMPLE_NAME_AS_SUPERCLASS,org/apache/poi/hssf/util/CellRangeAddress.java,,33-37,[		super(firstRow, lastRow, firstCol, lastCol);, 	}, 	public CellRangeAddress(RecordInputStream in) {, 		super(in);, 	}],,
BAD_PRACTICE,NM_SAME_SIMPLE_NAME_AS_SUPERCLASS,org/apache/poi/hssf/util/CellRangeAddressList.java,,39-55,[		super(firstRow,lastRow,firstCol,lastCol);, 	}, 	public CellRangeAddressList() {, 		super();, 	}, , 	/**, 	 * @param in the RecordInputstream to read the record from, 	 */, 	public CellRangeAddressList(RecordInputStream in) {, 		super();, 		int nItems = in.readUShort();, , 		for (int k = 0; k < nItems; k++) {, 			_list.add(new CellRangeAddress(in));, 		}, 	}],,
BAD_PRACTICE,NM_SAME_SIMPLE_NAME_AS_SUPERCLASS,org/apache/poi/hssf/util/CellReference.java,,33-46,[    	super(cellRef);,     }, ,     public CellReference(int pRow, int pCol) {,     	super(pRow, pCol, true, true);,     },     ,     public CellReference(int pRow, int pCol, boolean pAbsRow, boolean pAbsCol) {,         super(null, pRow, pCol, pAbsRow, pAbsCol);,     }, ,     public CellReference(String pSheetName, int pRow, int pCol, boolean pAbsRow, boolean pAbsCol) {,     	super(pSheetName, pRow, pCol, pAbsRow, pAbsCol);,     }],,
MT_CORRECTNESS,LI_LAZY_INIT_STATIC,org/apache/poi/hssf/util/HSSFColor.java,getIndexHash,56-57,[        if(indexHash == null) {,            indexHash = Collections.unmodifiableMap( createColorsByIndexMap() );],,
STYLE,UCF_USELESS_CONTROL_FLOW,org/apache/poi/hssf/util/HSSFColor.java,createColorsByIndexMap,96-96,[            if (result.containsKey(index2)) {],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/poi/hssf/util/HSSFColor.java,,844-844,[        public final static short[] triplet   =],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/poi/hssf/util/HSSFColor.java,,220-220,[        public final static short[] triplet   =],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/poi/hssf/util/HSSFColor.java,,627-627,[        public final static short[] triplet   =],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/poi/hssf/util/HSSFColor.java,,658-658,[        public final static short[] triplet   =],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/poi/hssf/util/HSSFColor.java,,1065-1065,[        public final static short[] triplet   =],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/poi/hssf/util/HSSFColor.java,,251-251,[        public final static short[] triplet   =],,
MALICIOUS_CODE,MS_MUTABLE_ARRAY,org/apache/poi/hssf/util/HSSFColor.java,,1586-1586,[        public final static short[] triplet   =],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/poi/hssf/util/HSSFColor.java,,1469-1469,[        public final static short[] triplet   =],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/poi/hssf/util/HSSFColor.java,,376-376,[        public final static short[] triplet   =],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/poi/hssf/util/HSSFColor.java,,313-313,[        public final static short[] triplet   =],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/poi/hssf/util/HSSFColor.java,,470-470,[        public final static short[] triplet   =],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/poi/hssf/util/HSSFColor.java,,344-344,[        public final static short[] triplet   =],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/poi/hssf/util/HSSFColor.java,,532-532,[        public final static short[] triplet   =],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/poi/hssf/util/HSSFColor.java,,1001-1001,[        public final static short[] triplet   =],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/poi/hssf/util/HSSFColor.java,,563-563,[        public final static short[] triplet   =],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/poi/hssf/util/HSSFColor.java,,1191-1191,[        public final static short[] triplet   =],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/poi/hssf/util/HSSFColor.java,,938-938,[        public final static short[] triplet   =],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/poi/hssf/util/HSSFColor.java,,689-689,[        public final static short[] triplet   =],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/poi/hssf/util/HSSFColor.java,,438-438,[        public final static short[] triplet   =],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/poi/hssf/util/HSSFColor.java,,407-407,[        public final static short[] triplet   =],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/poi/hssf/util/HSSFColor.java,,1409-1409,[        public final static short[] triplet   =],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/poi/hssf/util/HSSFColor.java,,1499-1499,[        public final static short[] triplet   =],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/poi/hssf/util/HSSFColor.java,,875-875,[        public final static short[] triplet   =],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/poi/hssf/util/HSSFColor.java,,1644-1644,[        public final static short[] triplet   =],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/poi/hssf/util/HSSFColor.java,,1315-1315,[        public final static short[] triplet   =],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/poi/hssf/util/HSSFColor.java,,751-751,[        public final static short[] triplet   =],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/poi/hssf/util/HSSFColor.java,,1347-1347,[        public final static short[] triplet   =],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/poi/hssf/util/HSSFColor.java,,1284-1284,[        public final static short[] triplet   =],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/poi/hssf/util/HSSFColor.java,,782-782,[        public final static short[] triplet   =],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/poi/hssf/util/HSSFColor.java,,1528-1528,[        public final static short[] triplet   =],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/poi/hssf/util/HSSFColor.java,,282-282,[        public final static short[] triplet   =],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/poi/hssf/util/HSSFColor.java,,501-501,[        public final static short[] triplet   =],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/poi/hssf/util/HSSFColor.java,,1557-1557,[        public final static short[] triplet   =],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/poi/hssf/util/HSSFColor.java,,1378-1378,[        public final static short[] triplet   =],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/poi/hssf/util/HSSFColor.java,,970-970,[        public final static short[] triplet   =],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/poi/hssf/util/HSSFColor.java,,1160-1160,[        public final static short[] triplet   =],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/poi/hssf/util/HSSFColor.java,,720-720,[        public final static short[] triplet   =],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/poi/hssf/util/HSSFColor.java,,1222-1222,[        public final static short[] triplet   =],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/poi/hssf/util/HSSFColor.java,,1615-1615,[        public final static short[] triplet   =],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/poi/hssf/util/HSSFColor.java,,813-813,[        public final static short[] triplet   =],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/poi/hssf/util/HSSFColor.java,,1128-1128,[        public final static short[] triplet   =],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/poi/hssf/util/HSSFColor.java,,1253-1253,[        public final static short[] triplet   =],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/poi/hssf/util/HSSFColor.java,,595-595,[        public final static short[] triplet   =],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/poi/hssf/util/HSSFColor.java,,1097-1097,[        public final static short[] triplet   =],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/poi/hssf/util/HSSFColor.java,,907-907,[        public final static short[] triplet   =],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/poi/hssf/util/HSSFColor.java,,1440-1440,[        public final static short[] triplet   =],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/poi/hssf/util/HSSFColor.java,,1033-1033,[        public final static short[] triplet   =],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/poi/hssf/util/LazilyConcatenatedByteArray.java,toArray,62-62,[            return null;],,
BAD_PRACTICE,NM_SAME_SIMPLE_NAME_AS_SUPERCLASS,org/apache/poi/hssf/util/Region.java,,36-46,[		super();,     }, ,     public Region(int rowFrom, short colFrom, int rowTo, short colTo),     {, 		super(rowFrom, colFrom, rowTo, colTo);,     }, ,     public Region(String ref) {, 		super(ref);, 	}],,
STYLE,FE_FLOATING_POINT_EQUALITY,org/apache/poi/hssf/util/TestRKUtil.java,testDecode,45-45,[			if (expectedValue != actualValue) {],,
BAD_PRACTICE,CN_IDIOM_NO_SUPER_CALL,org/apache/poi/hssf/view/SVFractionalFormat.java,clone,216-216,[    return null;],,
BAD_PRACTICE,NP_CLONE_COULD_RETURN_NULL,org/apache/poi/hssf/view/SVFractionalFormat.java,clone,216-216,[    return null;],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/poi/hssf/view/SVFractionalFormat.java,,34-216,[  private short ONE_DIGIT = 1;,   private short TWO_DIGIT = 2;,   private short THREE_DIGIT = 3;,   private short UNITS = 4;,   private int units = 1;,   private short mode = -1;, ,   /** Constructs a new FractionalFormatter,    *,    *  The formatStr defines how the number will be formatted,    *  # ?/? Up to one digit,    *  # ??/?? Up to two digits,    *  # ???/??? Up to three digits,    *  # ?/2 In halves,    *  # ?/4 In quarters,    *  # ?/8 In eighths,    *  # ?/16 In sixteenths,    *  # ?/10 In tenths,    *  # ?/100 In hundredths,    */,   public SVFractionalFormat(String formatStr) {,     if ("# ?/?".equals(formatStr)),       mode = ONE_DIGIT;,     else if ("# ??/??".equals(formatStr)),       mode = TWO_DIGIT;,     else if ("# ???/???".equals(formatStr)),       mode = THREE_DIGIT;,     else if ("# ?/2".equals(formatStr)) {,       mode = UNITS;,       units = 2;,     } else if ("# ?/4".equals(formatStr)) {,       mode = UNITS;,       units = 4;,     } else if ("# ?/8".equals(formatStr)) {,       mode = UNITS;,       units = 8;,     } else if ("# ?/16".equals(formatStr)) {,       mode = UNITS;,       units = 16;,     } else if ("# ?/10".equals(formatStr)) {,       mode = UNITS;,       units = 10;,     } else if ("# ?/100".equals(formatStr)) {,       mode = UNITS;,       units = 100;,     },   }, ,   /**,    *  Returns a fractional string representation of a double to a maximum denominator size,    *,    * This code has been translated to java from the following web page.,    * http://www.codeproject.com/cpp/fraction.asp,    * Originally coded in c++ By Dean Wyant  dwyant@mindspring.com,    * The code on the web page is freely available.,    *,    * @param  f       Description of the Parameter,    * @param  MaxDen  Description of the Parameter,    * @return         Description of the Return Value,    */,   private String format(final double f, final int MaxDen) {,     long Whole = (long)f;,     int sign = 1;,     if (f < 0) {,       sign = -1;,     },     double Precision = 0.00001;,     double AllowedError = Precision;,     double d = Math.abs(f);,     d -= Whole;,     double Frac = d;,     double Diff = Frac;,     long Num = 1;,     long Den = 0;,     long A = 0;,     long B = 0;,     long i = 0;,     if (Frac > Precision) {,       while (true) {,         d = 1.0 / d;,         i = (long) (d + Precision);,         d -= i;,         if (A > 0) {,           Num = i * Num + B;,         },         Den = (long) (Num / Frac + 0.5);,         Diff = Math.abs((double) Num / Den - Frac);,         if (Den > MaxDen) {,           if (A > 0) {,             Num = A;,             Den = (long) (Num / Frac + 0.5);,             Diff = Math.abs((double) Num / Den - Frac);,           } else {,             Den = MaxDen;,             Num = 1;,             Diff = Math.abs((double) Num / Den - Frac);,             if (Diff > Frac) {,               Num = 0;,               Den = 1;,               // Keeps final check below from adding 1 and keeps Den from being 0,               Diff = Frac;,             },           },           break;,         },         if ((Diff <= AllowedError) || (d < Precision)) {,           break;,         },         Precision = AllowedError / Diff;,         // This calcualtion of Precision does not always provide results within,         // Allowed Error. It compensates for loss of significant digits that occurs.,         // It helps to round the inprecise reciprocal values to i.,         B = A;,         A = Num;,       },     },     if (Num == Den) {,       Whole++;,       Num = 0;,       Den = 0;,     } else if (Den == 0) {,       Num = 0;,     },     if (sign < 0) {,       if (Whole == 0) {,         Num = -Num;,       } else {,         Whole = -Whole;,       },     },     return new StringBuffer().append(Whole).append(" ").append(Num).append("/").append(Den).toString();,   }, ,   /** This method formats the double in the units specified.,    *  The usints could be any number but in this current implementation it is,    *  halves (2), quaters (4), eigths (8) etc,    */,   private String formatUnit(double f, int units) {,     long Whole = (long)f;,     f -= Whole;,     long Num = Math.round(f * units);, ,     return new StringBuffer().append(Whole).append(" ").append(Num).append("/").append(units).toString();,   }, ,   public final String format(double val) {,     if (mode == ONE_DIGIT) {,       return format(val, 9);,     } else if (mode == TWO_DIGIT) {,       return format(val, 99);,     } else if (mode == THREE_DIGIT) {,       return format(val, 999);,     } else if (mode == UNITS) {,       return formatUnit(val , units);,     },     throw new RuntimeException("Unexpected Case");,   }, ,   public StringBuffer format(Object obj,,                                       StringBuffer toAppendTo,,                                       FieldPosition pos) {,     if (obj instanceof Number) {,       toAppendTo.append(format(((Number)obj).doubleValue()));,       return toAppendTo;,     },     throw new IllegalArgumentException("Can only handle Numbers");,   }, ,   public Object parseObject(String source,,                                    ParsePosition status) {,     //JMH TBD,     return null;,   }, ,   public Object parseObject(String source),                    throws ParseException {,     //JMH TBD,     return null;,   }, ,   public Object clone() {,     //JMH TBD,     return null;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/poi/hssf/view/SVRowHeader.java,,60-85,[    RowHeaderRenderer(HSSFSheet sheet, JTable table, int extraHeight) {,       this.sheet = sheet;,       this.extraHeight = extraHeight;,       JTableHeader header = table.getTableHeader();,       setOpaque(true);,       setBorder(UIManager.getBorder("TableHeader.cellBorder"));,       setHorizontalAlignment(CENTER);,       setForeground(header.getForeground());,       setBackground(header.getBackground());,       setFont(header.getFont());,     }, ,     public Component getListCellRendererComponent( JList list,,            Object value, int index, boolean isSelected, boolean cellHasFocus) {,       Dimension d = getPreferredSize();,       HSSFRow row = sheet.getRow(index);,       int rowHeight;,       if(row == null) {,     	  rowHeight = (int)sheet.getDefaultRowHeightInPoints();,       } else {,     	  rowHeight = (int)row.getHeightInPoints();,       },       d.height = rowHeight+extraHeight;,       setPreferredSize(d);,       setText((value == null) ? "" : value.toString());,       return this;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/poi/hssf/view/SVRowHeader.java,,43-51,[    public SVRowHeaderModel(HSSFSheet sheet) {,       this.sheet = sheet;,     }, ,     public int getSize() {,     	return sheet.getLastRowNum() + 1;,     },     public Object getElementAt(int index) {,       return Integer.toString(index+1);],,
CORRECTNESS,ICAST_INT_CAST_TO_FLOAT_PASSED_TO_ROUND,org/apache/poi/hssf/view/SVSheetTable.java,<init>,166-166,[        int height = Math.round(Math.max(1, h / (res / 70 * 20) + 3));],,
BAD_PRACTICE,SE_BAD_FIELD,org/apache/poi/hssf/view/SVSheetTable.java,,107-137,[  private class FormulaDisplayListener implements ListSelectionListener {,     private final JTextComponent formulaDisplay;, ,     public FormulaDisplayListener(JTextComponent formulaDisplay) {,       this.formulaDisplay = formulaDisplay;,     }, ,     public void valueChanged(ListSelectionEvent e) {,       int row = getSelectedRow();,       int col = getSelectedColumn();,       if (row < 0 || col < 0) {,         return;,       }, ,       if (e.getValueIsAdjusting()) {,         return;,       }, ,       HSSFCell cell = (HSSFCell) getValueAt(row, col);,       String formula = "";,       if (cell != null) {,         if (cell.getCellType() == Cell.CELL_TYPE_FORMULA) {,           formula = cell.getCellFormula();,         } else {,           formula = cell.toString();,         },         if (formula == null),           formula = "";,       },       formulaDisplay.setText(formula);,     }],,
BAD_PRACTICE,SE_BAD_FIELD,org/apache/poi/hssf/view/brush/PendingPaintings.java,,43-176,[    public static final String PENDING_PAINTINGS =,             PendingPaintings.class.getSimpleName();, ,     private final List<Painting> paintings;, ,     /** A single painting description. */,     public static class Painting {,         final Stroke stroke;,         final Color color;,         final Shape shape;,         final AffineTransform transform;, ,         /**,          * Creates a new painting description.,          *,          * @param stroke    The stroke to paint.,          * @param color     The color of the stroke.,          * @param shape     The shape of the stroke.,          * @param transform The transformation matrix to use.,          */,         public Painting(Stroke stroke, Color color, Shape shape,,                 AffineTransform transform) {, ,             this.color = color;,             this.shape = shape;,             this.stroke = stroke;,             this.transform = transform;,         }, ,         /**,          * Draw the painting.,          *,          * @param g The graphics object to use to draw with.,          */,         public void draw(Graphics2D g) {,             g.setTransform(transform);,             g.setStroke(stroke);,             g.setColor(color);,             g.draw(shape);,         },     }, ,     /**,      * Creates a new object on the given parent.  The created object will be,      * stored as a client property.,      *,      * @param parent,      */,     public PendingPaintings(JComponent parent) {,         paintings = new ArrayList<Painting>();,         parent.putClientProperty(PENDING_PAINTINGS, this);,     }, ,     /** Drops all pending paintings. */,     public void clear() {,         paintings.clear();,     }, ,     /**,      * Paints all pending paintings.  Once they have been painted they are,      * removed from the list of pending paintings (they aren't pending anymore,,      * after all).,      *,      * @param g The graphics object to draw with.,      */,     public void paint(Graphics2D g) {,         g.setBackground(Color.CYAN);,         AffineTransform origTransform = g.getTransform();,         for (Painting c : paintings) {,             c.draw(g);,         },         g.setTransform(origTransform);, ,         clear();,     }, ,     /**,      * Adds a new pending painting to the list on the given component.  This,      * will find the first ancestor that has a {@link PendingPaintings} client,      * property, starting with the component itself.,      *,      * @param c      The component for which the painting is being added.,      * @param g      The graphics object to draw with.,      * @param stroke The stroke to draw.,      * @param color  The color to draw with.,      * @param shape  The shape to stroke.,      */,     public static void add(JComponent c, Graphics2D g, Stroke stroke,,             Color color, Shape shape) {, ,         add(c, new Painting(stroke, color, shape, g.getTransform()));,     }, ,     /**,      * Adds a new pending painting to the list on the given component.  This,      * will find the first ancestor that has a {@link PendingPaintings} client,      * property, starting with the component itself.,      *,      * @param c           The component for which the painting is being added.,      * @param newPainting The new painting.,      */,     public static void add(JComponent c, Painting newPainting) {,         PendingPaintings pending = pendingPaintingsFor(c);,         if (pending != null) {,             pending.paintings.add(newPainting);,         },     }, ,     /**,      * Returns the pending painting object for the given component, if any. This,      * is retrieved from the first object found that has a {@link,      * #PENDING_PAINTINGS} client property, starting with this component and,      * looking up its ancestors (parent, parent's parent, etc.),      * <p/>,      * This allows any descendant of a component that has a {@link,      * PendingPaintings} property to add its own pending paintings.,      *,      * @param c The component for which the painting is being added.,      *,      * @return The pending painting object for that component, or <tt>null</tt>,      *         if there is none.,      */,     public static PendingPaintings pendingPaintingsFor(JComponent c) {,         for (Component parent = c;,              parent != null;,              parent = parent.getParent()) {,             if (parent instanceof JComponent) {,                 JComponent jc = (JComponent) parent;,                 Object pd = jc.getClientProperty(PENDING_PAINTINGS);,                 if (pd != null),                     return (PendingPaintings) pd;,             },         },         return null;],,
BAD_PRACTICE,SE_BAD_FIELD,org/apache/poi/hssf/usermodel/HSSFSheet.java,,65-1986,[public final class HSSFSheet implements org.apache.poi.ss.usermodel.Sheet {,     private static final POILogger log = POILogFactory.getLogger(HSSFSheet.class);,     private static final int DEBUG = POILogger.DEBUG;, ,     /**,      * Used for compile-time optimization.  This is the initial size for the collection of,      * rows.  It is currently set to 20.  If you generate larger sheets you may benefit,      * by setting this to a higher number and recompiling a custom edition of HSSFSheet.,      */,     public final static int INITIAL_CAPACITY = 20;, ,     /**,      * reference to the low level {@link InternalSheet} object,      */,     private final InternalSheet _sheet;,     /** stores rows by zero-based row number */,     private final TreeMap<Integer, HSSFRow> _rows;,     protected final InternalWorkbook _book;,     protected final HSSFWorkbook _workbook;,     private HSSFPatriarch _patriarch;,     private int _firstrow;,     private int _lastrow;, ,     /**,      * Creates new HSSFSheet   - called by HSSFWorkbook to create a sheet from,      * scratch.  You should not be calling this from application code (its protected anyhow).,      *,      * @param workbook - The HSSF Workbook object associated with the sheet.,      * @see org.apache.poi.hssf.usermodel.HSSFWorkbook#createSheet(),      */,     protected HSSFSheet(HSSFWorkbook workbook) {,         _sheet = InternalSheet.createSheet();,         _rows = new TreeMap<Integer, HSSFRow>();,         this._workbook = workbook;,         this._book = workbook.getWorkbook();,     }, ,     /**,      * Creates an HSSFSheet representing the given Sheet object.  Should only be,      * called by HSSFWorkbook when reading in an exisiting file.,      *,      * @param workbook - The HSSF Workbook object associated with the sheet.,      * @param sheet - lowlevel Sheet object this sheet will represent,      * @see org.apache.poi.hssf.usermodel.HSSFWorkbook#createSheet(),      */,     protected HSSFSheet(HSSFWorkbook workbook, InternalSheet sheet) {,         this._sheet = sheet;,         _rows = new TreeMap<Integer, HSSFRow>();,         this._workbook = workbook;,         this._book = workbook.getWorkbook();,         setPropertiesFromSheet(sheet);,     }, ,     HSSFSheet cloneSheet(HSSFWorkbook workbook) {,       return new HSSFSheet(workbook, _sheet.cloneSheet());,     }, ,     /**,      * Return the parent workbook,      *,      * @return the parent workbook,      */,     public HSSFWorkbook getWorkbook(){,         return _workbook;,     }, ,     /**,      * used internally to set the properties given a Sheet object,      */,     private void setPropertiesFromSheet(InternalSheet sheet) {, ,         RowRecord row = sheet.getNextRow();,         boolean rowRecordsAlreadyPresent = row!=null;, ,         while (row != null) {,             createRowFromRecord(row);, ,             row = sheet.getNextRow();,         }, ,         Iterator<CellValueRecordInterface> iter = sheet.getCellValueIterator();,         long timestart = System.currentTimeMillis();, ,         if (log.check( POILogger.DEBUG )),             log.log(DEBUG, "Time at start of cell creating in HSSF sheet = ",,                 Long.valueOf(timestart));,         HSSFRow lastrow = null;, ,         // Add every cell to its row,         while (iter.hasNext()) {,             CellValueRecordInterface cval = iter.next();, ,             long cellstart = System.currentTimeMillis();,             HSSFRow hrow = lastrow;, ,             if (hrow == null || hrow.getRowNum() != cval.getRow()) {,                 hrow = getRow( cval.getRow() );,                 lastrow = hrow;,                 if (hrow == null) {,                     // Some tools (like Perl module Spreadsheet::WriteExcel - bug 41187) skip the RowRecords,                     // Excel, OpenOffice.org and GoogleDocs are all OK with this, so POI should be too.,                     if (rowRecordsAlreadyPresent) {,                         // if at least one row record is present, all should be present.,                         throw new RuntimeException("Unexpected missing row when some rows already present");,                     },                     // create the row record on the fly now.,                     RowRecord rowRec = new RowRecord(cval.getRow());,                     sheet.addRow(rowRec);,                     hrow = createRowFromRecord(rowRec);,                 },             },             if (log.check( POILogger.DEBUG )),                 log.log( DEBUG, "record id = " + Integer.toHexString( ( (Record) cval ).getSid() ) );,             hrow.createCellFromRecord( cval );,             if (log.check( POILogger.DEBUG )),                 log.log( DEBUG, "record took ",,                     Long.valueOf( System.currentTimeMillis() - cellstart ) );, ,         },         if (log.check( POILogger.DEBUG )),             log.log(DEBUG, "total sheet cell creation took ",,                 Long.valueOf(System.currentTimeMillis() - timestart));,     }, ,     /**,      * Create a new row within the sheet and return the high level representation,      *,      * @param rownum  row number,      * @return High level HSSFRow object representing a row in the sheet,      * @see org.apache.poi.hssf.usermodel.HSSFRow,      * @see #removeRow(org.apache.poi.ss.usermodel.Row),      */,     public HSSFRow createRow(int rownum),     {,         HSSFRow row = new HSSFRow(_workbook, this, rownum);, ,         addRow(row, true);,         return row;,     }, ,     /**,      * Used internally to create a high level Row object from a low level row object.,      * USed when reading an existing file,      * @param row  low level record to represent as a high level Row and add to sheet,      * @return HSSFRow high level representation,      */, ,     private HSSFRow createRowFromRecord(RowRecord row),     {,         HSSFRow hrow = new HSSFRow(_workbook, this, row);, ,         addRow(hrow, false);,         return hrow;,     }, ,     /**,      * Remove a row from this sheet.  All cells contained in the row are removed as well,      *,      * @param row   representing a row to remove.,      */,     public void removeRow(Row row) {,         HSSFRow hrow = (HSSFRow) row;,         if (row.getSheet() != this) {,             throw new IllegalArgumentException("Specified row does not belong to this sheet");,         },         for(Cell cell : row) {,             HSSFCell xcell = (HSSFCell)cell;,             if(xcell.isPartOfArrayFormulaGroup()){,                 String msg = "Row[rownum="+row.getRowNum()+"] contains cell(s) included in a multi-cell array formula. You cannot change part of an array.";,                 xcell.notifyArrayFormulaChanging(msg);,             },         }, ,         if (_rows.size() > 0) {,             Integer key = Integer.valueOf(row.getRowNum());,             HSSFRow removedRow = _rows.remove(key);,             if (removedRow != row) {,                 //should not happen if the input argument is valid,                 throw new IllegalArgumentException("Specified row does not belong to this sheet");,             },             if (hrow.getRowNum() == getLastRowNum()),             {,                 _lastrow = findLastRow(_lastrow);,             },             if (hrow.getRowNum() == getFirstRowNum()),             {,                 _firstrow = findFirstRow(_firstrow);,             },             _sheet.removeRow(hrow.getRowRecord());,         },     }, ,     /**,      * used internally to refresh the "last row" when the last row is removed.,      */,     private int findLastRow(int lastrow) {,         if (lastrow < 1) {,             return 0;,         },         int rownum = lastrow - 1;,         HSSFRow r = getRow(rownum);, ,         while (r == null && rownum > 0) {,             r = getRow(--rownum);,         },         if (r == null) {,             return 0;,         },         return rownum;,     }, ,     /**,      * used internally to refresh the "first row" when the first row is removed.,      */, ,     private int findFirstRow(int firstrow),     {,         int rownum = firstrow + 1;,         HSSFRow r = getRow(rownum);, ,         while (r == null && rownum <= getLastRowNum()),         {,             r = getRow(++rownum);,         }, ,         if (rownum > getLastRowNum()),             return 0;, ,         return rownum;,     }, ,     /**,      * add a row to the sheet,      *,      * @param addLow whether to add the row to the low level model - false if its already there,      */, ,     private void addRow(HSSFRow row, boolean addLow),     {,         _rows.put(Integer.valueOf(row.getRowNum()), row);,         if (addLow),         {,             _sheet.addRow(row.getRowRecord());,         },         boolean firstRow = _rows.size() == 1;,         if (row.getRowNum() > getLastRowNum() || firstRow),         {,             _lastrow = row.getRowNum();,         },         if (row.getRowNum() < getFirstRowNum() || firstRow),         {,             _firstrow = row.getRowNum();,         },     }, ,     /**,      * Returns the logical row (not physical) 0-based.  If you ask for a row that is not,      * defined you get a null.  This is to say row 4 represents the fifth row on a sheet.,      * @param rowIndex  row to get,      * @return HSSFRow representing the row number or null if its not defined on the sheet,      */,     public HSSFRow getRow(int rowIndex) {,         return _rows.get(Integer.valueOf(rowIndex));,     }, ,     /**,      * Returns the number of physically defined rows (NOT the number of rows in the sheet),      */,     public int getPhysicalNumberOfRows() {,         return _rows.size();,     }, ,     /**,      * Gets the first row on the sheet,      * @return the number of the first logical row on the sheet, zero based,      */,     public int getFirstRowNum() {,         return _firstrow;,     }, ,     /**,      * Gets the number last row on the sheet.,      * Owing to idiosyncrasies in the excel file,      *  format, if the result of calling this method,      *  is zero, you can't tell if that means there,      *  are zero rows on the sheet, or one at,      *  position zero. For that case, additionally,      *  call {@link #getPhysicalNumberOfRows()} to,      *  tell if there is a row at position zero,      *  or not.,      * @return the number of the last row contained in this sheet, zero based.,      */,     public int getLastRowNum() {,         return _lastrow;,     }, ,     /**,      * Creates a data validation object,      * @param dataValidation The Data validation object settings,      */,     public void addValidationData(DataValidation dataValidation) {,        if (dataValidation == null) {,            throw new IllegalArgumentException("objValidation must not be null");,        },        HSSFDataValidation hssfDataValidation = (HSSFDataValidation)dataValidation;,        DataValidityTable dvt = _sheet.getOrCreateDataValidityTable();, ,        DVRecord dvRecord = hssfDataValidation.createDVRecord(this);,        dvt.addDataValidation(dvRecord);,     }, , ,     /**,      * @deprecated (Sep 2008) use {@link #setColumnHidden(int, boolean)},      */,     public void setColumnHidden(short columnIndex, boolean hidden) {,         setColumnHidden(columnIndex & 0xFFFF, hidden);,     }, ,     /**,      * @deprecated (Sep 2008) use {@link #isColumnHidden(int)},      */,     public boolean isColumnHidden(short columnIndex) {,         return isColumnHidden(columnIndex & 0xFFFF);,     }, ,     /**,      * @deprecated (Sep 2008) use {@link #setColumnWidth(int, int)},      */,     public void setColumnWidth(short columnIndex, short width) {,         setColumnWidth(columnIndex & 0xFFFF, width & 0xFFFF);,     }, ,     /**,      * @deprecated (Sep 2008) use {@link #getColumnWidth(int)},      */,     public short getColumnWidth(short columnIndex) {,         return (short)getColumnWidth(columnIndex & 0xFFFF);,     }, ,     /**,      * @deprecated (Sep 2008) use {@link #setDefaultColumnWidth(int)},      */,     public void setDefaultColumnWidth(short width) {,         setDefaultColumnWidth(width & 0xFFFF);,     }, ,     /**,      * Get the visibility state for a given column.,      * @param columnIndex - the column to get (0-based),      * @param hidden - the visiblity state of the column,      */,     public void setColumnHidden(int columnIndex, boolean hidden) {,         _sheet.setColumnHidden(columnIndex, hidden);,     }, ,     /**,      * Get the hidden state for a given column.,      * @param columnIndex - the column to set (0-based),      * @return hidden - <code>false</code> if the column is visible,      */,     public boolean isColumnHidden(int columnIndex) {,         return _sheet.isColumnHidden(columnIndex);,     }, ,     /**,      * Set the width (in units of 1/256th of a character width),      *,      * <p>,      * The maximum column width for an individual cell is 255 characters.,      * This value represents the number of characters that can be displayed,      * in a cell that is formatted with the standard font (first font in the workbook).,      * </p>,      *,      * <p>,      * Character width is defined as the maximum digit width,      * of the numbers <code>0, 1, 2, ... 9</code> as rendered,      * using the default font (first font in the workbook).,      * <br/>,      * Unless you are using a very special font, the default character is '0' (zero),,      * this is true for Arial (default font font in HSSF) and Calibri (default font in XSSF),      * </p>,      *,      * <p>,      * Please note, that the width set by this method includes 4 pixels of margin padding (two on each side),,      * plus 1 pixel padding for the gridlines (Section 3.3.1.12 of the OOXML spec).,      * This results is a slightly less value of visible characters than passed to this method (approx. 1/2 of a character).,      * </p>,      * <p>,      * To compute the actual number of visible characters,,      *  Excel uses the following formula (Section 3.3.1.12 of the OOXML spec):,      * </p>,      * <code>,      *     width = Truncate([{Number of Visible Characters} *,      *      {Maximum Digit Width} + {5 pixel padding}]/{Maximum Digit Width}*256)/256,      * </code>,      * <p>Using the Calibri font as an example, the maximum digit width of 11 point font size is 7 pixels (at 96 dpi).,      *  If you set a column width to be eight characters wide, e.g. <code>setColumnWidth(columnIndex, 8*256)</code>,,      *  then the actual value of visible characters (the value shown in Excel) is derived from the following equation:,      *  <code>,             Truncate([numChars*7+5]/7*256)/256 = 8;,      *  </code>,      *,      *  which gives <code>7.29</code>.,      *,      * @param columnIndex - the column to set (0-based),      * @param width - the width in units of 1/256th of a character width,      * @throws IllegalArgumentException if width > 255*256 (the maximum column width in Excel is 255 characters),      */,     public void setColumnWidth(int columnIndex, int width) {,         _sheet.setColumnWidth(columnIndex, width);,     }, ,     /**,      * get the width (in units of 1/256th of a character width ),      * @param columnIndex - the column to set (0-based),      * @return width - the width in units of 1/256th of a character width,      */,     public int getColumnWidth(int columnIndex) {,         return _sheet.getColumnWidth(columnIndex);,     }, ,     /**,      * get the default column width for the sheet (if the columns do not define their own width) in,      * characters,      * @return default column width,      */,     public int getDefaultColumnWidth() {,         return _sheet.getDefaultColumnWidth();,     },     /**,      * set the default column width for the sheet (if the columns do not define their own width) in,      * characters,      * @param width default column width,      */,     public void setDefaultColumnWidth(int width) {,         _sheet.setDefaultColumnWidth(width);,     }, , ,     /**,      * get the default row height for the sheet (if the rows do not define their own height) in,      * twips (1/20 of  a point),      * @return  default row height,      */,     public short getDefaultRowHeight() {,         return _sheet.getDefaultRowHeight();,     }, ,     /**,      * get the default row height for the sheet (if the rows do not define their own height) in,      * points.,      * @return  default row height in points,      */, ,     public float getDefaultRowHeightInPoints(),     {,         return ((float)_sheet.getDefaultRowHeight() / 20);,     }, ,     /**,      * set the default row height for the sheet (if the rows do not define their own height) in,      * twips (1/20 of  a point),      * @param  height default row height,      */, ,     public void setDefaultRowHeight(short height),     {,         _sheet.setDefaultRowHeight(height);,     }, ,     /**,      * set the default row height for the sheet (if the rows do not define their own height) in,      * points,      * @param height default row height,      */, ,     public void setDefaultRowHeightInPoints(float height),     {,         _sheet.setDefaultRowHeight((short) (height * 20));,     }, ,     /**,      * Returns the HSSFCellStyle that applies to the given,      *  (0 based) column, or null if no style has been,      *  set for that column,      */,     public HSSFCellStyle getColumnStyle(int column) {,         short styleIndex = _sheet.getXFIndexForColAt((short)column);, ,         if(styleIndex == 0xf) {,             // None set,             return null;,         }, ,         ExtendedFormatRecord xf = _book.getExFormatAt(styleIndex);,         return new HSSFCellStyle(styleIndex, xf, _book);,     }, ,     /**,      * get whether gridlines are printed.,      * @return true if printed,      */, ,     public boolean isGridsPrinted(),     {,         return _sheet.isGridsPrinted();,     }, ,     /**,      * set whether gridlines printed.,      * @param value  false if not printed.,      */, ,     public void setGridsPrinted(boolean value),     {,         _sheet.setGridsPrinted(value);,     }, ,     /**,      * @deprecated (Aug-2008) use <tt>CellRangeAddress</tt> instead of <tt>Region</tt>,      */,     public int addMergedRegion(org.apache.poi.ss.util.Region region),     {,         return _sheet.addMergedRegion( region.getRowFrom(),,                 region.getColumnFrom(),,                 //(short) region.getRowTo(),,                 region.getRowTo(),,                 region.getColumnTo());,     },     /**,      * adds a merged region of cells (hence those cells form one),      * @param region (rowfrom/colfrom-rowto/colto) to merge,      * @return index of this region,      */,     public int addMergedRegion(CellRangeAddress region),     {,         region.validate(SpreadsheetVersion.EXCEL97);, ,         // throw IllegalStateException if the argument CellRangeAddress intersects with,         // a multi-cell array formula defined in this sheet,         validateArrayFormulas(region);, ,         return _sheet.addMergedRegion( region.getFirstRow(),,                 region.getFirstColumn(),,                 region.getLastRow(),,                 region.getLastColumn());,     }, ,     private void validateArrayFormulas(CellRangeAddress region){,         int firstRow = region.getFirstRow();,         int firstColumn = region.getFirstColumn();,         int lastRow = region.getLastRow();,         int lastColumn = region.getLastColumn();,         for (int rowIn = firstRow; rowIn <= lastRow; rowIn++) {,             for (int colIn = firstColumn; colIn <= lastColumn; colIn++) {,                 HSSFRow row = getRow(rowIn);,                 if (row == null) continue;, ,                 HSSFCell cell = row.getCell(colIn);,                 if(cell == null) continue;, ,                 if(cell.isPartOfArrayFormulaGroup()){,                     CellRangeAddress arrayRange = cell.getArrayFormulaRange();,                     if (arrayRange.getNumberOfCells() > 1 &&,                             ( arrayRange.isInRange(region.getFirstRow(), region.getFirstColumn()) ||,                               arrayRange.isInRange(region.getFirstRow(), region.getFirstColumn()))  ){,                         String msg = "The range " + region.formatAsString() + " intersects with a multi-cell array formula. " +,                                 "You cannot merge cells of an array.";,                         throw new IllegalStateException(msg);,                     },                 },             },         }, ,     }, ,     /**,      * Control if Excel should be asked to recalculate all formulas on this sheet,      * when the workbook is opened.,      *,      *  <p>,      *  Calculating the formula values with {@link org.apache.poi.ss.usermodel.FormulaEvaluator} is the,      *  recommended solution, but this may be used for certain cases where,      *  evaluation in POI is not possible.,      *  </p>,      *,      *  <p>,      *  It is recommended to force recalcuation of formulas on workbook level using,      *  {@link org.apache.poi.ss.usermodel.Workbook#setForceFormulaRecalculation(boolean)},      *  to ensure that all cross-worksheet formuals and external dependencies are updated.,      *  </p>,      * @param value true if the application will perform a full recalculation of,      * this worksheet values when the workbook is opened,      *,      * @see org.apache.poi.ss.usermodel.Workbook#setForceFormulaRecalculation(boolean),      */,     public void setForceFormulaRecalculation(boolean value),     {,         _sheet.setUncalced(value);,     },     /**,      * Whether a record must be inserted or not at generation to indicate that,      * formula must be recalculated when workbook is opened.,      * @return true if an uncalced record must be inserted or not at generation,      */,     public boolean getForceFormulaRecalculation(),     {,         return _sheet.getUncalced();,     }, , ,     /**,      * determines whether the output is vertically centered on the page.,      * @param value true to vertically center, false otherwise.,      */, ,     public void setVerticallyCenter(boolean value),     {,         _sheet.getPageSettings().getVCenter().setVCenter(value);,     }, ,     /**,      * TODO: Boolean not needed, remove after next release,      * @deprecated (Mar-2008) use getVerticallyCenter() instead,      */,     public boolean getVerticallyCenter(boolean value) {,         return getVerticallyCenter();,     }, ,     /**,      * Determine whether printed output for this sheet will be vertically centered.,      */,     public boolean getVerticallyCenter(),     {,         return _sheet.getPageSettings().getVCenter().getVCenter();,     }, ,     /**,      * determines whether the output is horizontally centered on the page.,      * @param value true to horizontally center, false otherwise.,      */, ,     public void setHorizontallyCenter(boolean value),     {,         _sheet.getPageSettings().getHCenter().setHCenter(value);,     }, ,     /**,      * Determine whether printed output for this sheet will be horizontally centered.,      */, ,     public boolean getHorizontallyCenter(),     {, ,         return _sheet.getPageSettings().getHCenter().getHCenter();,     }, ,     /**,      * Sets whether the worksheet is displayed from right to left instead of from left to right.,      *,      * @param value true for right to left, false otherwise.,      */,     public void setRightToLeft(boolean value),     {,         _sheet.getWindowTwo().setArabic(value);,     }, ,     /**,      * Whether the text is displayed in right-to-left mode in the window,      *,      * @return whether the text is displayed in right-to-left mode in the window,      */,     public boolean isRightToLeft(),     {,         return _sheet.getWindowTwo().getArabic();,     }, ,     /**,      * removes a merged region of cells (hence letting them free),      * @param index of the region to unmerge,      */, ,     public void removeMergedRegion(int index),     {,         _sheet.removeMergedRegion(index);,     }, ,     /**,      * returns the number of merged regions,      * @return number of merged regions,      */, ,     public int getNumMergedRegions(),     {,         return _sheet.getNumMergedRegions();,     }, ,     /**,      * @deprecated (Aug-2008) use {@link HSSFSheet#getMergedRegion(int)},      */,     public Region getMergedRegionAt(int index) {,         CellRangeAddress cra = getMergedRegion(index);, ,         return new Region(cra.getFirstRow(), (short)cra.getFirstColumn(),,                 cra.getLastRow(), (short)cra.getLastColumn());,     },     /**,      * @return the merged region at the specified index,      */,     public CellRangeAddress getMergedRegion(int index) {,         return _sheet.getMergedRegionAt(index);,     }, ,     /**,      * @return an iterator of the PHYSICAL rows.  Meaning the 3rd element may not,      * be the third row if say for instance the second row is undefined.,      * Call getRowNum() on each row if you care which one it is.,      */,     public Iterator<Row> rowIterator() {,         @SuppressWarnings("unchecked") // can this clumsy generic syntax be improved?,         Iterator<Row> result = (Iterator<Row>)(Iterator<? extends Row>)_rows.values().iterator();,         return result;,     },     /**,      * Alias for {@link #rowIterator()} to allow,      *  foreach loops,      */,     public Iterator<Row> iterator() {,         return rowIterator();,     }, , ,     /**,      * used internally in the API to get the low level Sheet record represented by this,      * Object.,      * @return Sheet - low level representation of this HSSFSheet.,      */,     InternalSheet getSheet() {,         return _sheet;,     }, ,     /**,      * whether alternate expression evaluation is on,      * @param b  alternative expression evaluation or not,      */,     public void setAlternativeExpression(boolean b) {,         WSBoolRecord record =,                 (WSBoolRecord) _sheet.findFirstRecordBySid(WSBoolRecord.sid);, ,         record.setAlternateExpression(b);,     }, ,     /**,      * whether alternative formula entry is on,      * @param b  alternative formulas or not,      */,     public void setAlternativeFormula(boolean b) {,         WSBoolRecord record =,                 (WSBoolRecord) _sheet.findFirstRecordBySid(WSBoolRecord.sid);, ,         record.setAlternateFormula(b);,     }, ,     /**,      * show automatic page breaks or not,      * @param b  whether to show auto page breaks,      */,     public void setAutobreaks(boolean b) {,         WSBoolRecord record =,                 (WSBoolRecord) _sheet.findFirstRecordBySid(WSBoolRecord.sid);, ,         record.setAutobreaks(b);,     }, ,     /**,      * set whether sheet is a dialog sheet or not,      * @param b  isDialog or not,      */,     public void setDialog(boolean b) {,         WSBoolRecord record =,                 (WSBoolRecord) _sheet.findFirstRecordBySid(WSBoolRecord.sid);, ,         record.setDialog(b);,     }, ,     /**,      * set whether to display the guts or not,      *,      * @param b  guts or no guts (or glory),      */,     public void setDisplayGuts(boolean b) {,         WSBoolRecord record =,                 (WSBoolRecord) _sheet.findFirstRecordBySid(WSBoolRecord.sid);, ,         record.setDisplayGuts(b);,     }, ,     /**,      * fit to page option is on,      * @param b  fit or not,      */,     public void setFitToPage(boolean b) {,         WSBoolRecord record =,                 (WSBoolRecord) _sheet.findFirstRecordBySid(WSBoolRecord.sid);, ,         record.setFitToPage(b);,     }, ,     /**,      * set if row summaries appear below detail in the outline,      * @param b  below or not,      */,     public void setRowSumsBelow(boolean b) {,         WSBoolRecord record =,                 (WSBoolRecord) _sheet.findFirstRecordBySid(WSBoolRecord.sid);, ,         record.setRowSumsBelow(b);,         //setAlternateExpression must be set in conjuction with setRowSumsBelow,         record.setAlternateExpression(b);,     }, ,     /**,      * set if col summaries appear right of the detail in the outline,      * @param b  right or not,      */,     public void setRowSumsRight(boolean b) {,         WSBoolRecord record =,                 (WSBoolRecord) _sheet.findFirstRecordBySid(WSBoolRecord.sid);, ,         record.setRowSumsRight(b);,     }, ,     /**,      * whether alternate expression evaluation is on,      * @return alternative expression evaluation or not,      */,     public boolean getAlternateExpression() {,         return ((WSBoolRecord) _sheet.findFirstRecordBySid(WSBoolRecord.sid)),                 .getAlternateExpression();,     }, ,     /**,      * whether alternative formula entry is on,      * @return alternative formulas or not,      */,     public boolean getAlternateFormula() {,         return ((WSBoolRecord) _sheet.findFirstRecordBySid(WSBoolRecord.sid)),                 .getAlternateFormula();,     }, ,     /**,      * show automatic page breaks or not,      * @return whether to show auto page breaks,      */,     public boolean getAutobreaks() {,         return ((WSBoolRecord) _sheet.findFirstRecordBySid(WSBoolRecord.sid)),                 .getAutobreaks();,     }, ,     /**,      * get whether sheet is a dialog sheet or not,      * @return isDialog or not,      */,     public boolean getDialog() {,         return ((WSBoolRecord) _sheet.findFirstRecordBySid(WSBoolRecord.sid)),                 .getDialog();,     }, ,     /**,      * get whether to display the guts or not,      *,      * @return guts or no guts (or glory),      */,     public boolean getDisplayGuts() {,         return ((WSBoolRecord) _sheet.findFirstRecordBySid(WSBoolRecord.sid)),                 .getDisplayGuts();,     }, , ,     /**,      * Gets the flag indicating whether the window should show 0 (zero) in cells containing zero value.,      * When false, cells with zero value appear blank instead of showing the number zero.,      * <p>,      * In Excel 2003 this option can be changed in the Options dialog on the View tab.,      * </p>,      * @return whether all zero values on the worksheet are displayed,      */,     public boolean isDisplayZeros(){,         return _sheet.getWindowTwo().getDisplayZeros();,     }, ,     /**,      * Set whether the window should show 0 (zero) in cells containing zero value.,      * When false, cells with zero value appear blank instead of showing the number zero.,      * <p>,      * In Excel 2003 this option can be set in the Options dialog on the View tab.,      * </p>,      * @param value whether to display or hide all zero values on the worksheet,      */,     public void setDisplayZeros(boolean value){,         _sheet.getWindowTwo().setDisplayZeros(value);,     }, ,     /**,      * fit to page option is on,      * @return fit or not,      */,     public boolean getFitToPage() {,         return ((WSBoolRecord) _sheet.findFirstRecordBySid(WSBoolRecord.sid)),                 .getFitToPage();,     }, ,     /**,      * get if row summaries appear below detail in the outline,      * @return below or not,      */,     public boolean getRowSumsBelow() {,         return ((WSBoolRecord) _sheet.findFirstRecordBySid(WSBoolRecord.sid)),                 .getRowSumsBelow();,     }, ,     /**,      * get if col summaries appear right of the detail in the outline,      * @return right or not,      */,     public boolean getRowSumsRight() {,         return ((WSBoolRecord) _sheet.findFirstRecordBySid(WSBoolRecord.sid)),                 .getRowSumsRight();,     }, ,     /**,      * Returns whether gridlines are printed.,      * @return Gridlines are printed,      */,     public boolean isPrintGridlines() {,         return getSheet().getPrintGridlines().getPrintGridlines();,     }, ,     /**,      * Turns on or off the printing of gridlines.,      * @param newPrintGridlines boolean to turn on or off the printing of,      * gridlines,      */,     public void setPrintGridlines(boolean newPrintGridlines) {,         getSheet().getPrintGridlines().setPrintGridlines(newPrintGridlines);,     }, ,     /**,      * Gets the print setup object.,      * @return The user model for the print setup object.,      */,     public HSSFPrintSetup getPrintSetup() {,         return new HSSFPrintSetup(_sheet.getPageSettings().getPrintSetup());,     }, ,     public HSSFHeader getHeader() {,         return new HSSFHeader(_sheet.getPageSettings());,     }, ,     public HSSFFooter getFooter() {,         return new HSSFFooter(_sheet.getPageSettings());,     }, ,     /**,      * Note - this is not the same as whether the sheet is focused (isActive),      * @return <code>true</code> if this sheet is currently selected,      */,     public boolean isSelected() {,         return getSheet().getWindowTwo().getSelected();,     },     /**,      * Sets whether sheet is selected.,      * @param sel Whether to select the sheet or deselect the sheet.,      */,     public void setSelected(boolean sel) {,         getSheet().getWindowTwo().setSelected(sel);,     },     /**,      * @return <code>true</code> if this sheet is currently focused,      */,     public boolean isActive() {,         return getSheet().getWindowTwo().isActive();,     },     /**,      * Sets whether sheet is selected.,      * @param sel Whether to select the sheet or deselect the sheet.,      */,     public void setActive(boolean sel) {,         getSheet().getWindowTwo().setActive(sel);,     }, ,     /**,      * Gets the size of the margin in inches.,      * @param margin which margin to get,      * @return the size of the margin,      */,     public double getMargin(short margin) {,         return _sheet.getPageSettings().getMargin(margin);,     }, ,     /**,      * Sets the size of the margin in inches.,      * @param margin which margin to get,      * @param size the size of the margin,      */,     public void setMargin(short margin, double size) {,         _sheet.getPageSettings().setMargin(margin, size);,     }, ,     private WorksheetProtectionBlock getProtectionBlock() {,         return _sheet.getProtectionBlock();,     },     /**,      * Answer whether protection is enabled or disabled,      * @return true => protection enabled; false => protection disabled,      */,     public boolean getProtect() {,         return getProtectionBlock().isSheetProtected();,     }, ,     /**,      * @return hashed password,      */,     public short getPassword() {,         return (short)getProtectionBlock().getPasswordHash();,     }, ,     /**,      * Answer whether object protection is enabled or disabled,      * @return true => protection enabled; false => protection disabled,      */,     public boolean getObjectProtect() {,         return getProtectionBlock().isObjectProtected();,     }, ,     /**,      * Answer whether scenario protection is enabled or disabled,      * @return true => protection enabled; false => protection disabled,      */,     public boolean getScenarioProtect() {,         return getProtectionBlock().isScenarioProtected();,     },     /**,      * Sets the protection enabled as well as the password,      * @param password to set for protection. Pass <code>null</code> to remove protection,      */,     public void protectSheet(String password) {,         getProtectionBlock().protectSheet(password, true, true); //protect objs&scenarios(normal),     }, ,     /**,      * Sets the zoom magnification for the sheet.  The zoom is expressed as a,      * fraction.  For example to express a zoom of 75% use 3 for the numerator,      * and 4 for the denominator.,      *,      * @param numerator     The numerator for the zoom magnification.,      * @param denominator   The denominator for the zoom magnification.,      */,     public void setZoom( int numerator, int denominator),     {,         if (numerator < 1 || numerator > 65535),             throw new IllegalArgumentException("Numerator must be greater than 1 and less than 65536");,         if (denominator < 1 || denominator > 65535),             throw new IllegalArgumentException("Denominator must be greater than 1 and less than 65536");, ,         SCLRecord sclRecord = new SCLRecord();,         sclRecord.setNumerator((short)numerator);,         sclRecord.setDenominator((short)denominator);,         getSheet().setSCLRecord(sclRecord);,     }, ,     /**,      * The top row in the visible view when the sheet is,      * first viewed after opening it in a viewer,      * @return short indicating the rownum (0 based) of the top row,      */,     public short getTopRow() {,         return _sheet.getTopRow();,     }, ,     /**,      * The left col in the visible view when the sheet is,      * first viewed after opening it in a viewer,      * @return short indicating the rownum (0 based) of the top row,      */,     public short getLeftCol() {,         return _sheet.getLeftCol();,     }, ,     /**,      * Sets desktop window pane display area, when the,      * file is first opened in a viewer.,      * @param toprow the top row to show in desktop window pane,      * @param leftcol the left column to show in desktop window pane,      */,     public void showInPane(short toprow, short leftcol){,         _sheet.setTopRow(toprow);,         _sheet.setLeftCol(leftcol);,     }, ,     /**,      * Shifts the merged regions left or right depending on mode,      * <p>,      * TODO: MODE , this is only row specific,      * @param startRow,      * @param endRow,      * @param n,      * @param isRow,      */,     protected void shiftMerged(int startRow, int endRow, int n, boolean isRow) {,         List<CellRangeAddress> shiftedRegions = new ArrayList<CellRangeAddress>();,         //move merged regions completely if they fall within the new region boundaries when they are shifted,         for (int i = 0; i < getNumMergedRegions(); i++) {,              CellRangeAddress merged = getMergedRegion(i);, ,              boolean inStart= (merged.getFirstRow() >= startRow || merged.getLastRow() >= startRow);,              boolean inEnd  = (merged.getFirstRow() <= endRow   || merged.getLastRow() <= endRow);, ,              //don't check if it's not within the shifted area,              if (!inStart || !inEnd) {,                 continue;,              }, ,              //only shift if the region outside the shifted rows is not merged too,              if (!SheetUtil.containsCell(merged, startRow-1, 0) &&,                  !SheetUtil.containsCell(merged, endRow+1, 0)){,                  merged.setFirstRow(merged.getFirstRow()+n);,                  merged.setLastRow(merged.getLastRow()+n);,                  //have to remove/add it back,                  shiftedRegions.add(merged);,                  removeMergedRegion(i);,                  i = i -1; // we have to back up now since we removed one,              },         }, ,         //read so it doesn't get shifted again,         Iterator<CellRangeAddress> iterator = shiftedRegions.iterator();,         while (iterator.hasNext()) {,             CellRangeAddress region = iterator.next();, ,             this.addMergedRegion(region);,         },     }, ,     /**,      * Shifts rows between startRow and endRow n number of rows.,      * If you use a negative number, it will shift rows up.,      * Code ensures that rows don't wrap around.,      *,      * Calls shiftRows(startRow, endRow, n, false, false);,      *,      * <p>,      * Additionally shifts merged regions that are completely defined in these,      * rows (ie. merged 2 cells on a row to be shifted).,      * @param startRow the row to start shifting,      * @param endRow the row to end shifting,      * @param n the number of rows to shift,      */,     public void shiftRows( int startRow, int endRow, int n ) {,         shiftRows(startRow, endRow, n, false, false);,     }, ,     /**,      * Shifts rows between startRow and endRow n number of rows.,      * If you use a negative number, it will shift rows up.,      * Code ensures that rows don't wrap around,      *,      * <p>,      * Additionally shifts merged regions that are completely defined in these,      * rows (ie. merged 2 cells on a row to be shifted).,      * <p>,      * TODO Might want to add bounds checking here,      * @param startRow the row to start shifting,      * @param endRow the row to end shifting,      * @param n the number of rows to shift,      * @param copyRowHeight whether to copy the row height during the shift,      * @param resetOriginalRowHeight whether to set the original row's height to the default,      */,     public void shiftRows( int startRow, int endRow, int n, boolean copyRowHeight, boolean resetOriginalRowHeight) {,         shiftRows(startRow, endRow, n, copyRowHeight, resetOriginalRowHeight, true);,     }, ,     /**,      * Shifts rows between startRow and endRow n number of rows.,      * If you use a negative number, it will shift rows up.,      * Code ensures that rows don't wrap around,      *,      * <p>,      * Additionally shifts merged regions that are completely defined in these,      * rows (ie. merged 2 cells on a row to be shifted).,      * <p>,      * TODO Might want to add bounds checking here,      * @param startRow the row to start shifting,      * @param endRow the row to end shifting,      * @param n the number of rows to shift,      * @param copyRowHeight whether to copy the row height during the shift,      * @param resetOriginalRowHeight whether to set the original row's height to the default,      * @param moveComments whether to move comments at the same time as the cells they are attached to,      */,     public void shiftRows(int startRow, int endRow, int n,,             boolean copyRowHeight, boolean resetOriginalRowHeight, boolean moveComments) {,         int s, inc;,         if (n < 0) {,             s = startRow;,             inc = 1;,         } else if (n > 0) {,             s = endRow;,             inc = -1;,         } else {,            // Nothing to do,            return;,         },         ,         NoteRecord[] noteRecs;,         if (moveComments) {,             noteRecs = _sheet.getNoteRecords();,         } else {,             noteRecs = NoteRecord.EMPTY_ARRAY;,         }, ,         shiftMerged(startRow, endRow, n, true);,         _sheet.getPageSettings().shiftRowBreaks(startRow, endRow, n);, ,         for ( int rowNum = s; rowNum >= startRow && rowNum <= endRow && rowNum >= 0 && rowNum < 65536; rowNum += inc ) {,             HSSFRow row = getRow( rowNum );,             // notify all cells in this row that we are going to shift them,,             // it can throw IllegalStateException if the operation is not allowed, for example,,             // if the row contains cells included in a multi-cell array formula,             if(row != null) notifyRowShifting(row);, ,             HSSFRow row2Replace = getRow( rowNum + n );,             if ( row2Replace == null ),                 row2Replace = createRow( rowNum + n );, , ,             // Remove all the old cells from the row we'll,             //  be writing too, before we start overwriting,             //  any cells. This avoids issues with cells,             //  changing type, and records not being correctly,             //  overwritten,             row2Replace.removeAllCells();, ,             // If this row doesn't exist, nothing needs to,             //  be done for the now empty destination row,             if (row == null) continue; // Nothing to do for this row, ,             // Fix up row heights if required,             if (copyRowHeight) {,                 row2Replace.setHeight(row.getHeight());,             },             if (resetOriginalRowHeight) {,                 row.setHeight((short)0xff);,             }, ,             // Copy each cell from the source row to,             //  the destination row,             for(Iterator<Cell> cells = row.cellIterator(); cells.hasNext(); ) {,                 HSSFCell cell = (HSSFCell)cells.next();,                 row.removeCell( cell );,                 CellValueRecordInterface cellRecord = cell.getCellValueRecord();,                 cellRecord.setRow( rowNum + n );,                 row2Replace.createCellFromRecord( cellRecord );,                 _sheet.addValueRecord( rowNum + n, cellRecord );, ,                 HSSFHyperlink link = cell.getHyperlink();,                 if(link != null){,                     link.setFirstRow(link.getFirstRow() + n);,                     link.setLastRow(link.getLastRow() + n);,                 },             },             // Now zap all the cells in the source row,             row.removeAllCells();, ,             // Move comments from the source row to the,             //  destination row. Note that comments can,             //  exist for cells which are null,             if(moveComments) {,                 // This code would get simpler if NoteRecords could be organised by HSSFRow.,                 for(int i=noteRecs.length-1; i>=0; i--) {,                     NoteRecord nr = noteRecs[i];,                     if (nr.getRow() != rowNum) {,                         continue;,                     },                     HSSFComment comment = getCellComment(rowNum, nr.getColumn());,                     if (comment != null) {,                        comment.setRow(rowNum + n);,                     },                 },             },         },         ,         // Re-compute the first and last rows of the sheet as needed,         if(n > 0) {,            // Rows are moving down,            if ( startRow == _firstrow ) {,               // Need to walk forward to find the first non-blank row,               _firstrow = Math.max( startRow + n, 0 );,               for( int i=startRow+1; i < startRow+n; i++ ) {,                  if (getRow(i) != null) {,                     _firstrow = i;,                     break;,                  },               },            },            if ( endRow + n > _lastrow ) {,               _lastrow = Math.min( endRow + n, SpreadsheetVersion.EXCEL97.getLastRowIndex() );,            },         } else {,            // Rows are moving up,            if ( startRow + n < _firstrow ) {,               _firstrow = Math.max( startRow + n, 0 );,            },            if ( endRow == _lastrow  ) {,               // Need to walk backward to find the last non-blank row,               _lastrow = Math.min( endRow + n, SpreadsheetVersion.EXCEL97.getLastRowIndex() );,               for (int i=endRow-1; i > endRow+n; i++) {,                  if (getRow(i) != null) {,                     _lastrow = i;,                     break;,                  },               },            },         }, ,         // Update any formulas on this sheet that point to,         //  rows which have been moved,         int sheetIndex = _workbook.getSheetIndex(this);,         short externSheetIndex = _book.checkExternSheet(sheetIndex);,         FormulaShifter shifter = FormulaShifter.createForRowShift(externSheetIndex, startRow, endRow, n);,         _sheet.updateFormulasAfterCellShift(shifter, externSheetIndex);, ,         int nSheets = _workbook.getNumberOfSheets();,         for(int i=0; i<nSheets; i++) {,             InternalSheet otherSheet = _workbook.getSheetAt(i).getSheet();,             if (otherSheet == this._sheet) {,                 continue;,             },             short otherExtSheetIx = _book.checkExternSheet(i);,             otherSheet.updateFormulasAfterCellShift(shifter, otherExtSheetIx);,         },         _workbook.getWorkbook().updateNamesAfterCellShift(shifter);,     }, ,     protected void insertChartRecords(List<Record> records) {,         int window2Loc = _sheet.findFirstRecordLocBySid(WindowTwoRecord.sid);,         _sheet.getRecords().addAll(window2Loc, records);,     }, ,     private void notifyRowShifting(HSSFRow row){,         String msg = "Row[rownum="+row.getRowNum()+"] contains cell(s) included in a multi-cell array formula. " +,                 "You cannot change part of an array.";,         for(Cell cell : row){,             HSSFCell hcell = (HSSFCell)cell;,             if(hcell.isPartOfArrayFormulaGroup()){,                 hcell.notifyArrayFormulaChanging(msg);,             },         },     }, ,     /**,      * Creates a split (freezepane). Any existing freezepane or split pane is overwritten.,      *,      * <p>,      *     If both colSplit and rowSplit are zero then the existing freeze pane is removed,      * </p>,      *,      * @param colSplit      Horizonatal position of split.,      * @param rowSplit      Vertical position of split.,      * @param leftmostColumn   Left column visible in right pane.,      * @param topRow        Top row visible in bottom pane,      */,     public void createFreezePane(int colSplit, int rowSplit, int leftmostColumn, int topRow) {,         validateColumn(colSplit);,         validateRow(rowSplit);,         if (leftmostColumn < colSplit) throw new IllegalArgumentException("leftmostColumn parameter must not be less than colSplit parameter");,         if (topRow < rowSplit) throw new IllegalArgumentException("topRow parameter must not be less than leftmostColumn parameter");,         getSheet().createFreezePane( colSplit, rowSplit, topRow, leftmostColumn );,     }, ,     /**,      * Creates a split (freezepane). Any existing freezepane or split pane is overwritten.,      *,      * <p>,      *     If both colSplit and rowSplit are zero then the existing freeze pane is removed,      * </p>,      *,      * @param colSplit      Horizonatal position of split.,      * @param rowSplit      Vertical position of split.,      */,     public void createFreezePane(int colSplit, int rowSplit) {,         createFreezePane(colSplit, rowSplit, colSplit, rowSplit);,     }, ,     /**,      * Creates a split pane. Any existing freezepane or split pane is overwritten.,      * @param xSplitPos      Horizonatal position of split (in 1/20th of a point).,      * @param ySplitPos      Vertical position of split (in 1/20th of a point).,      * @param topRow        Top row visible in bottom pane,      * @param leftmostColumn   Left column visible in right pane.,      * @param activePane    Active pane.  One of: PANE_LOWER_RIGHT,,      *                      PANE_UPPER_RIGHT, PANE_LOWER_LEFT, PANE_UPPER_LEFT,      * @see #PANE_LOWER_LEFT,      * @see #PANE_LOWER_RIGHT,      * @see #PANE_UPPER_LEFT,      * @see #PANE_UPPER_RIGHT,      */,     public void createSplitPane(int xSplitPos, int ySplitPos, int leftmostColumn, int topRow, int activePane) {,         getSheet().createSplitPane( xSplitPos, ySplitPos, topRow, leftmostColumn, activePane );,     }, ,     /**,      * Returns the information regarding the currently configured pane (split or freeze).,      * @return null if no pane configured, or the pane information.,      */,     public PaneInformation getPaneInformation() {,         return getSheet().getPaneInformation();,     }, ,     /**,      * Sets whether the gridlines are shown in a viewer.,      * @param show whether to show gridlines or not,      */,     public void setDisplayGridlines(boolean show) {,         _sheet.setDisplayGridlines(show);,     }, ,     /**,      * Returns if gridlines are displayed.,      * @return whether gridlines are displayed,      */,     public boolean isDisplayGridlines() {,     return _sheet.isDisplayGridlines();,     }, ,     /**,      * Sets whether the formulas are shown in a viewer.,      * @param show whether to show formulas or not,      */,     public void setDisplayFormulas(boolean show) {,         _sheet.setDisplayFormulas(show);,     }, ,     /**,      * Returns if formulas are displayed.,      * @return whether formulas are displayed,      */,     public boolean isDisplayFormulas() {,         return _sheet.isDisplayFormulas();,     }, ,     /**,      * Sets whether the RowColHeadings are shown in a viewer.,      * @param show whether to show RowColHeadings or not,      */,     public void setDisplayRowColHeadings(boolean show) {,         _sheet.setDisplayRowColHeadings(show);,     }, ,     /**,      * Returns if RowColHeadings are displayed.,      * @return whether RowColHeadings are displayed,      */,     public boolean isDisplayRowColHeadings() {,         return _sheet.isDisplayRowColHeadings();,     }, ,     /**,      * Sets a page break at the indicated row,      * Breaks occur above the specified row and left of the specified column inclusive.,      *,      * For example, <code>sheet.setColumnBreak(2);</code> breaks the sheet into two parts,      * with columns A,B,C in the first and D,E,... in the second. Simuilar, <code>sheet.setRowBreak(2);</code>,      * breaks the sheet into two parts with first three rows (rownum=1...3) in the first part,      * and rows starting with rownum=4 in the second.,      *,      * @param row the row to break, inclusive,      */,     public void setRowBreak(int row) {,         validateRow(row);,         _sheet.getPageSettings().setRowBreak(row, (short)0, (short)255);,     }, ,     /**,      * @return <code>true</code> if there is a page break at the indicated row,      */,     public boolean isRowBroken(int row) {,         return _sheet.getPageSettings().isRowBroken(row);,     }, ,     /**,      * Removes the page break at the indicated row,      */,     public void removeRowBreak(int row) {,         _sheet.getPageSettings().removeRowBreak(row);,     }, ,     /**,      * @return row indexes of all the horizontal page breaks, never <code>null</code>,      */,     public int[] getRowBreaks() {,         //we can probably cache this information, but this should be a sparsely used function,         return _sheet.getPageSettings().getRowBreaks();,     }, ,     /**,      * @return column indexes of all the vertical page breaks, never <code>null</code>,      */,     public int[] getColumnBreaks() {,         //we can probably cache this information, but this should be a sparsely used function,         return _sheet.getPageSettings().getColumnBreaks();,     }, , ,     /**,      * Sets a page break at the indicated column.,      * Breaks occur above the specified row and left of the specified column inclusive.,      *,      * For example, <code>sheet.setColumnBreak(2);</code> breaks the sheet into two parts,      * with columns A,B,C in the first and D,E,... in the second. Simuilar, <code>sheet.setRowBreak(2);</code>,      * breaks the sheet into two parts with first three rows (rownum=1...3) in the first part,      * and rows starting with rownum=4 in the second.,      *,      * @param column the column to break, inclusive,      */,     public void setColumnBreak(int column) {,         validateColumn((short)column);,         _sheet.getPageSettings().setColumnBreak((short)column, (short)0, (short) SpreadsheetVersion.EXCEL97.getLastRowIndex());,     }, ,     /**,      * Determines if there is a page break at the indicated column,      * @param column FIXME: Document this!,      * @return FIXME: Document this!,      */,     public boolean isColumnBroken(int column) {,         return _sheet.getPageSettings().isColumnBroken(column);,     }, ,     /**,      * Removes a page break at the indicated column,      * @param column,      */,     public void removeColumnBreak(int column) {,         _sheet.getPageSettings().removeColumnBreak(column);,     }, ,     /**,      * Runs a bounds check for row numbers,      * @param row,      */,     protected void validateRow(int row) {,         int maxrow = SpreadsheetVersion.EXCEL97.getLastRowIndex();,         if (row > maxrow) throw new IllegalArgumentException("Maximum row number is " + maxrow);,         if (row < 0) throw new IllegalArgumentException("Minumum row number is 0");,     }, ,     /**,      * Runs a bounds check for column numbers,      * @param column,      */,     protected void validateColumn(int column) {,         int maxcol = SpreadsheetVersion.EXCEL97.getLastColumnIndex();,         if (column > maxcol) throw new IllegalArgumentException("Maximum column number is " + maxcol);,         if (column < 0)    throw new IllegalArgumentException("Minimum column number is 0");,     }, ,     /**,      * Aggregates the drawing records and dumps the escher record hierarchy,      * to the standard output.,      */,     public void dumpDrawingRecords(boolean fat) {,         _sheet.aggregateDrawingRecords(_book.getDrawingManager(), false);, ,         EscherAggregate r = (EscherAggregate) getSheet().findFirstRecordBySid(EscherAggregate.sid);,         List<EscherRecord> escherRecords = r.getEscherRecords();,         PrintWriter w = new PrintWriter(System.out);,         for (Iterator<EscherRecord> iterator = escherRecords.iterator(); iterator.hasNext();) {,             EscherRecord escherRecord = iterator.next();,             if (fat) {,                 System.out.println(escherRecord.toString());,             } else {,                 escherRecord.display(w, 0);,             },         },         w.flush();,     }, ,     /**,      * Creates the top-level drawing patriarch.  This will have,      *  the effect of removing any existing drawings on this,      *  sheet.,      * This may then be used to add graphics or charts,      * @return  The new patriarch.,      */,     public HSSFPatriarch createDrawingPatriarch() {,         if(_patriarch == null){,             // Create the drawing group if it doesn't already exist.,             _workbook.initDrawings();, ,             if(_patriarch == null){,                 _sheet.aggregateDrawingRecords(_book.getDrawingManager(), true);,                 EscherAggregate agg = (EscherAggregate) _sheet.findFirstRecordBySid(EscherAggregate.sid);,                 _patriarch = new HSSFPatriarch(this, agg);,                 agg.setPatriarch(_patriarch);,             },         },         return _patriarch;,     }, ,     /**,      * Returns the agregate escher records for this sheet,,      *  it there is one.,      * WARNING - calling this will trigger a parsing of the,      *  associated escher records. Any that aren't supported,      *  (such as charts and complex drawing types) will almost,      *  certainly be lost or corrupted when written out.,      */,     public EscherAggregate getDrawingEscherAggregate() {,         _book.findDrawingGroup();, ,         // If there's now no drawing manager, then there's,         //  no drawing escher records on the workbook,         if(_book.getDrawingManager() == null) {,             return null;,         }, ,         int found = _sheet.aggregateDrawingRecords(,                 _book.getDrawingManager(), false,         );,         if(found == -1) {,             // Workbook has drawing stuff, but this sheet doesn't,             return null;,         }, ,         // Grab our aggregate record, and wire it up,         EscherAggregate agg = (EscherAggregate) _sheet.findFirstRecordBySid(EscherAggregate.sid);,         return agg;,     }, ,     /**,      * Returns the top-level drawing patriach, if there is,      *  one.,      * This will hold any graphics or charts for the sheet.,      * WARNING - calling this will trigger a parsing of the,      *  associated escher records. Any that aren't supported,      *  (such as charts and complex drawing types) will almost,      *  certainly be lost or corrupted when written out. Only,      *  use this with simple drawings, otherwise call,      *  {@link HSSFSheet#createDrawingPatriarch()} and,      *  start from scratch!,      */,     public HSSFPatriarch getDrawingPatriarch() {,         if(_patriarch != null) return _patriarch;,         ,         EscherAggregate agg = getDrawingEscherAggregate();,         if(agg == null) return null;, ,         _patriarch = new HSSFPatriarch(this, agg);,         agg.setPatriarch(_patriarch);, ,         // Have it process the records into high level objects,         //  as best it can do (this step may eat anything,         //  that isn't supported, you were warned...),         agg.convertRecordsToUserModel();, ,         // Return what we could cope with,         return _patriarch;,     }, ,     /**,      * @deprecated (Sep 2008) use {@link #setColumnGroupCollapsed(int, boolean)},      */,     public void setColumnGroupCollapsed(short columnNumber, boolean collapsed) {,         setColumnGroupCollapsed(columnNumber & 0xFFFF, collapsed);,     },     /**,      * @deprecated (Sep 2008) use {@link #groupColumn(int, int)},      */,     public void groupColumn(short fromColumn, short toColumn) {,         groupColumn(fromColumn & 0xFFFF, toColumn & 0xFFFF);,     },     /**,      * @deprecated (Sep 2008) use {@link #ungroupColumn(int, int)},      */,     public void ungroupColumn(short fromColumn, short toColumn) {,         ungroupColumn(fromColumn & 0xFFFF, toColumn & 0xFFFF);,     }, ,     /**,      * Expands or collapses a column group.,      *,      * @param columnNumber      One of the columns in the group.,      * @param collapsed         true = collapse group, false = expand group.,      */,     public void setColumnGroupCollapsed(int columnNumber, boolean collapsed) {,         _sheet.setColumnGroupCollapsed(columnNumber, collapsed);,     }, ,     /**,      * Create an outline for the provided column range.,      *,      * @param fromColumn        beginning of the column range.,      * @param toColumn          end of the column range.,      */,     public void groupColumn(int fromColumn, int toColumn) {,         _sheet.groupColumnRange(fromColumn, toColumn, true);,     }, ,     public void ungroupColumn(int fromColumn, int toColumn) {,         _sheet.groupColumnRange(fromColumn, toColumn, false);,     }, ,     /**,      * Tie a range of cell together so that they can be collapsed or expanded,      *,      * @param fromRow   start row (0-based),      * @param toRow     end row (0-based),      */,     public void groupRow(int fromRow, int toRow) {,         _sheet.groupRowRange(fromRow, toRow, true);,     }, ,     public void ungroupRow(int fromRow, int toRow) {,         _sheet.groupRowRange(fromRow, toRow, false);,     }, ,     public void setRowGroupCollapsed(int rowIndex, boolean collapse) {,         if (collapse) {,             _sheet.getRowsAggregate().collapseRow(rowIndex);,         } else {,             _sheet.getRowsAggregate().expandRow(rowIndex);,         },     }, ,     /**,      * Sets the default column style for a given column.  POI will only apply this style to new cells added to the sheet.,      *,      * @param column the column index,      * @param style the style to set,      */,     public void setDefaultColumnStyle(int column, CellStyle style) {,         _sheet.setDefaultColumnStyle(column, ((HSSFCellStyle)style).getIndex());,     }, ,     /**,      * Adjusts the column width to fit the contents.,      *,      * This process can be relatively slow on large sheets, so this should,      *  normally only be called once per column, at the end of your,      *  processing.,      *,      * @param column the column index,      */,     public void autoSizeColumn(int column) {,         autoSizeColumn(column, false);,     }, ,     /**,      * Adjusts the column width to fit the contents.,      *,      * This process can be relatively slow on large sheets, so this should,      *  normally only be called once per column, at the end of your,      *  processing.,      *,      * You can specify whether the content of merged cells should be considered or ignored.,      *  Default is to ignore merged cells.,      *,      * @param column the column index,      * @param useMergedCells whether to use the contents of merged cells when calculating the width of the column,      */,     public void autoSizeColumn(int column, boolean useMergedCells) {,         double width = SheetUtil.getColumnWidth(this, column, useMergedCells);, ,         if (width != -1) {,             width *= 256;,             int maxColumnWidth = 255*256; // The maximum column width for an individual cell is 255 characters,             if (width > maxColumnWidth) {,                 width = maxColumnWidth;,             },             setColumnWidth(column, (int)(width));,         }, ,     }, ,     /**,      * Returns cell comment for the specified row and column,      *,      * @return cell comment or <code>null</code> if not found,      */,      public HSSFComment getCellComment(int row, int column) {,         // Don't call findCellComment directly, otherwise,         //  two calls to this method will result in two,         //  new HSSFComment instances, which is bad,         HSSFRow r = getRow(row);,         if(r != null) {,             HSSFCell c = r.getCell(column);,             if(c != null) {,                 return c.getCellComment();,             },             // No cell, so you will get new,             //  objects every time, sorry...,             return HSSFCell.findCellComment(_sheet, row, column);,         },         return null;,     }, ,     public HSSFSheetConditionalFormatting getSheetConditionalFormatting() {,         return new HSSFSheetConditionalFormatting(this);,     }, ,     /**,      * Returns the name of this sheet,      *,      * @return the name of this sheet,      */,     public String getSheetName() {,         HSSFWorkbook wb = getWorkbook();,         int idx = wb.getSheetIndex(this);,         return wb.getSheetName(idx);,     }, ,     /**,      * Also creates cells if they don't exist,      */,     private CellRange<HSSFCell> getCellRange(CellRangeAddress range) {,         int firstRow = range.getFirstRow();,         int firstColumn = range.getFirstColumn();,         int lastRow = range.getLastRow();,         int lastColumn = range.getLastColumn();,         int height = lastRow - firstRow + 1;,         int width = lastColumn - firstColumn + 1;,         List<HSSFCell> temp = new ArrayList<HSSFCell>(height*width);,         for (int rowIn = firstRow; rowIn <= lastRow; rowIn++) {,             for (int colIn = firstColumn; colIn <= lastColumn; colIn++) {,                 HSSFRow row = getRow(rowIn);,                 if (row == null) {,                     row = createRow(rowIn);,                 },                 HSSFCell cell = row.getCell(colIn);,                 if (cell == null) {,                     cell = row.createCell(colIn);,                 },                 temp.add(cell);,             },         },         return SSCellRange.create(firstRow, firstColumn, height, width, temp, HSSFCell.class);,     }, ,     public CellRange<HSSFCell> setArrayFormula(String formula, CellRangeAddress range) {,         // make sure the formula parses OK first,         int sheetIndex = _workbook.getSheetIndex(this);,         Ptg[] ptgs = HSSFFormulaParser.parse(formula, _workbook, FormulaType.ARRAY, sheetIndex);,         CellRange<HSSFCell> cells = getCellRange(range);, ,         for (HSSFCell c : cells) {,             c.setCellArrayFormula(range);,         },         HSSFCell mainArrayFormulaCell = cells.getTopLeftCell();,         FormulaRecordAggregate agg = (FormulaRecordAggregate)mainArrayFormulaCell.getCellValueRecord();,         agg.setArrayFormula(range, ptgs);,         return cells;,     }, , ,     public CellRange<HSSFCell> removeArrayFormula(Cell cell) {,         if (cell.getSheet() != this) {,             throw new IllegalArgumentException("Specified cell does not belong to this sheet.");,         },         CellValueRecordInterface rec = ((HSSFCell) cell).getCellValueRecord();,         if (!(rec instanceof FormulaRecordAggregate)) {,             String ref = new CellReference(cell).formatAsString();,             throw new IllegalArgumentException("Cell " + ref + " is not part of an array formula.");,         },         FormulaRecordAggregate fra = (FormulaRecordAggregate) rec;,         CellRangeAddress range = fra.removeArrayFormula(cell.getRowIndex(), cell.getColumnIndex());, ,         CellRange<HSSFCell> result = getCellRange(range);,         // clear all cells in the range,         for (Cell c : result) {,             c.setCellType(Cell.CELL_TYPE_BLANK);,         },         return result;,     }, , 	public DataValidationHelper getDataValidationHelper() {, 		return new HSSFDataValidationHelper(this);, 	},     ,     public HSSFAutoFilter setAutoFilter(CellRangeAddress range) {, , ,         InternalWorkbook workbook = _workbook.getWorkbook();,         int sheetIndex = _workbook.getSheetIndex(this);, ,         NameRecord name = workbook.getSpecificBuiltinRecord(NameRecord.BUILTIN_FILTER_DB, sheetIndex+1);, ,         if (name == null) {,             name = workbook.createBuiltInName(NameRecord.BUILTIN_FILTER_DB, sheetIndex+1);,         }, ,         // The built-in name must consist of a single Area3d Ptg.,         Area3DPtg ptg = new Area3DPtg(range.getFirstRow(), range.getLastRow(),,                 range.getFirstColumn(), range.getLastColumn(),,                 false, false, false, false, sheetIndex);,         name.setNameDefinition(new Ptg[]{ptg});, ,         AutoFilterInfoRecord r = new AutoFilterInfoRecord();,         // the number of columns that have AutoFilter enabled.,         int numcols = 1 + range.getLastColumn() - range.getFirstColumn();,         r.setNumEntries((short)numcols);,         int idx = _sheet.findFirstRecordLocBySid(DimensionsRecord.sid);,         _sheet.getRecords().add(idx, r);, ,         //create a combobox control for each column,         HSSFPatriarch p = createDrawingPatriarch();,         for(int col = range.getFirstColumn(); col <= range.getLastColumn(); col++){,             p.createComboBox(new HSSFClientAnchor(0,0,0,0,,                     (short)col, range.getFirstRow(), (short)(col+1), range.getFirstRow()+1));,         },         ,         return new HSSFAutoFilter(this);],,
STYLE,DB_DUPLICATE_SWITCH_CLAUSES,org/apache/poi/hssf/view/SVTableCellEditor.java,getTableCellEditorComponent,171-172,[          editor.setHorizontalAlignment(SwingConstants.LEFT);,           break;],,getTableCellEditorComponent,182-182,[          editor.setHorizontalAlignment(SwingConstants.LEFT);],,
BAD_PRACTICE,SE_BAD_FIELD,org/apache/poi/hssf/util/HSSFColor.java,,46-208,[    {,     }, ,     /**,      * This function returns all the colours in an unmodifiable Map.,      * The map is cached on first use.,      *,      * @return a Map containing all colours keyed by <tt>Integer</tt> excel-style palette indexes,      */,     public final static Map<Integer,HSSFColor> getIndexHash() {,         if(indexHash == null) {,            indexHash = Collections.unmodifiableMap( createColorsByIndexMap() );,         }, ,         return indexHash;,     },     /**,      * This function returns all the Colours, stored in a Hashtable that,      *  can be edited. No caching is performed. If you don't need to edit,      *  the table, then call {@link #getIndexHash()} which returns a,      *  statically cached imuatable map of colours.,      */,     public final static Hashtable<Integer,HSSFColor> getMutableIndexHash() {,        return createColorsByIndexMap();,     }, ,     private static Hashtable<Integer,HSSFColor> createColorsByIndexMap() {,         HSSFColor[] colors = getAllColors();,         Hashtable<Integer,HSSFColor> result = new Hashtable<Integer,HSSFColor>(colors.length * 3 / 2);, ,         for (int i = 0; i < colors.length; i++) {,             HSSFColor color = colors[i];, ,             Integer index1 = Integer.valueOf(color.getIndex());,             if (result.containsKey(index1)) {,                 HSSFColor prevColor = (HSSFColor)result.get(index1);,                 throw new RuntimeException("Dup color index (" + index1,                         + ") for colors (" + prevColor.getClass().getName(),                         + "),(" + color.getClass().getName() + ")");,             },             result.put(index1, color);,         }, ,         for (int i = 0; i < colors.length; i++) {,             HSSFColor color = colors[i];,             Integer index2 = getIndex2(color);,             if (index2 == null) {,                 // most colors don't have a second index,                 continue;,             },             if (result.containsKey(index2)) {,                 if (false) { // Many of the second indexes clash,                     HSSFColor prevColor = (HSSFColor)result.get(index2);,                     throw new RuntimeException("Dup color index (" + index2,                             + ") for colors (" + prevColor.getClass().getName(),                             + "),(" + color.getClass().getName() + ")");,                 },             },             result.put(index2, color);,         },         return result;,     }, ,     private static Integer getIndex2(HSSFColor color) {, ,         Field f;,         try {,             f = color.getClass().getDeclaredField("index2");,         } catch (NoSuchFieldException e) {,             // can happen because not all colors have a second index,             return null;,         }, ,         Short s;,         try {,             s = (Short) f.get(color);,         } catch (IllegalArgumentException e) {,             throw new RuntimeException(e);,         } catch (IllegalAccessException e) {,             throw new RuntimeException(e);,         },         return Integer.valueOf(s.intValue());,     }, ,     private static HSSFColor[] getAllColors() {, ,         return new HSSFColor[] {,                 new BLACK(), new BROWN(), new OLIVE_GREEN(), new DARK_GREEN(),,                 new DARK_TEAL(), new DARK_BLUE(), new INDIGO(), new GREY_80_PERCENT(),,                 new ORANGE(), new DARK_YELLOW(), new GREEN(), new TEAL(), new BLUE(),,                 new BLUE_GREY(), new GREY_50_PERCENT(), new RED(), new LIGHT_ORANGE(), new LIME(),,                 new SEA_GREEN(), new AQUA(), new LIGHT_BLUE(), new VIOLET(), new GREY_40_PERCENT(),,                 new PINK(), new GOLD(), new YELLOW(), new BRIGHT_GREEN(), new TURQUOISE(),,                 new DARK_RED(), new SKY_BLUE(), new PLUM(), new GREY_25_PERCENT(), new ROSE(),,                 new LIGHT_YELLOW(), new LIGHT_GREEN(), new LIGHT_TURQUOISE(), new PALE_BLUE(),,                 new LAVENDER(), new WHITE(), new CORNFLOWER_BLUE(), new LEMON_CHIFFON(),,                 new MAROON(), new ORCHID(), new CORAL(), new ROYAL_BLUE(),,                 new LIGHT_CORNFLOWER_BLUE(), new TAN(),,         };,     }, ,     /**,      * this function returns all colors in a hastable.  Its not implemented as a,      * static member/staticly initialized because that would be dirty in a,      * server environment as it is intended.  This means you'll eat the time,      * it takes to create it once per request but you will not hold onto it,      * if you have none of those requests.,      *,      * @return a hashtable containing all colors keyed by String gnumeric-like triplets,      */,     public final static Hashtable<String,HSSFColor> getTripletHash(),     {,         return createColorsByHexStringMap();,     }, ,     private static Hashtable<String,HSSFColor> createColorsByHexStringMap() {,         HSSFColor[] colors = getAllColors();,         Hashtable<String,HSSFColor> result = new Hashtable<String,HSSFColor>(colors.length * 3 / 2);, ,         for (int i = 0; i < colors.length; i++) {,             HSSFColor color = colors[i];, ,             String hexString = color.getHexString();,             if (result.containsKey(hexString)) {,             	HSSFColor other = (HSSFColor)result.get(hexString);,                 throw new RuntimeException(,                 		"Dup color hexString (" + hexString,                         + ") for color (" + color.getClass().getName() + ") - ",                         + " already taken by (" + other.getClass().getName() + ")",                 );,             },             result.put(hexString, color);,         },         return result;,     }, ,     /**,      * @return index to the standard palette,      */, ,     public short getIndex(),     {,         return BLACK.index;,     }, ,     /**,      * @return  triplet representation like that in Excel,      */, ,     public short [] getTriplet(),     {,         return BLACK.triplet;,     }, ,     // its a hack but its a good hack, ,     /**,      * @return a hex string exactly like a gnumeric triplet,      */, ,     public String getHexString(),     {,         return BLACK.hexString;],,
BAD_PRACTICE,SE_BAD_FIELD,org/apache/poi/hssf/usermodel/HSSFCell.java,,74-1295,[public class HSSFCell implements Cell {,     private static POILogger log = POILogFactory.getLogger(HSSFCell.class);, ,     private static final String FILE_FORMAT_NAME  = "BIFF8";,     /**,      * The maximum  number of columns in BIFF8,      */,     public static final int LAST_COLUMN_NUMBER  = SpreadsheetVersion.EXCEL97.getLastColumnIndex(); // 2^8 - 1,     private static final String LAST_COLUMN_NAME  = SpreadsheetVersion.EXCEL97.getLastColumnName();, ,     public final static short        ENCODING_UNCHANGED          = -1;,     public final static short        ENCODING_COMPRESSED_UNICODE = 0;,     public final static short        ENCODING_UTF_16             = 1;, ,     private final HSSFWorkbook       _book;,     private final HSSFSheet          _sheet;,     private int                      _cellType;,     private HSSFRichTextString       _stringValue;,     private CellValueRecordInterface _record;,     private HSSFComment              _comment;, ,     /**,      * Creates new Cell - Should only be called by HSSFRow.  This creates a cell,      * from scratch.,      * <p>,      * When the cell is initially created it is set to CELL_TYPE_BLANK. Cell types,      * can be changed/overwritten by calling setCellValue with the appropriate,      * type as a parameter although conversions from one type to another may be,      * prohibited.,      *,      * @param book - Workbook record of the workbook containing this cell,      * @param sheet - Sheet record of the sheet containing this cell,      * @param row   - the row of this cell,      * @param col   - the column for this cell,      *,      * @see org.apache.poi.hssf.usermodel.HSSFRow#createCell(short),      */,     protected HSSFCell(HSSFWorkbook book, HSSFSheet sheet, int row, short col),     {,         checkBounds(col);,         _stringValue  = null;,         _book    = book;,         _sheet   = sheet;, ,         // Relying on the fact that by default the cellType is set to 0 which,         // is different to CELL_TYPE_BLANK hence the following method call correctly,         // creates a new blank cell.,         short xfindex = sheet.getSheet().getXFIndexForColAt(col);,         setCellType(CELL_TYPE_BLANK, false, row, col,xfindex);,     }, ,     /**,      * Returns the HSSFSheet this cell belongs to,      *,      * @return the HSSFSheet that owns this cell,      */,     public HSSFSheet getSheet() {,         return _sheet;,     }, ,     /**,      * Returns the HSSFRow this cell belongs to,      *,      * @return the HSSFRow that owns this cell,      */,     public HSSFRow getRow() {,         int rowIndex = getRowIndex();,         return _sheet.getRow(rowIndex);,     }, ,     /**,      * Creates new Cell - Should only be called by HSSFRow.  This creates a cell,      * from scratch.,      *,      * @param book - Workbook record of the workbook containing this cell,      * @param sheet - Sheet record of the sheet containing this cell,      * @param row   - the row of this cell,      * @param col   - the column for this cell,      * @param type  - CELL_TYPE_NUMERIC, CELL_TYPE_STRING, CELL_TYPE_FORMULA, CELL_TYPE_BLANK,,      *                CELL_TYPE_BOOLEAN, CELL_TYPE_ERROR,      *                Type of cell,      * @see org.apache.poi.hssf.usermodel.HSSFRow#createCell(short,int),      */,     protected HSSFCell(HSSFWorkbook book, HSSFSheet sheet, int row, short col,,                        int type),     {,         checkBounds(col);,         _cellType     = -1; // Force 'setCellType' to create a first Record,         _stringValue  = null;,         _book    = book;,         _sheet   = sheet;, ,         short xfindex = sheet.getSheet().getXFIndexForColAt(col);,         setCellType(type,false,row,col,xfindex);,     }, ,     /**,      * Creates an HSSFCell from a CellValueRecordInterface.  HSSFSheet uses this when,      * reading in cells from an existing sheet.,      *,      * @param book - Workbook record of the workbook containing this cell,      * @param sheet - Sheet record of the sheet containing this cell,      * @param cval - the Cell Value Record we wish to represent,      */,     protected HSSFCell(HSSFWorkbook book, HSSFSheet sheet, CellValueRecordInterface cval) {,         _record      = cval;,         _cellType    = determineType(cval);,         _stringValue = null;,         _book   = book;,         _sheet  = sheet;,         switch (_cellType),         {,             case CELL_TYPE_STRING :,                 _stringValue = new HSSFRichTextString(book.getWorkbook(), (LabelSSTRecord ) cval);,                 break;, ,             case CELL_TYPE_BLANK :,                 break;, ,             case CELL_TYPE_FORMULA :,                 _stringValue=new HSSFRichTextString(((FormulaRecordAggregate) cval).getStringValue());,                 break;,         },     }, , ,     /**,      * used internally -- given a cell value record, figure out its type,      */,     private static int determineType(CellValueRecordInterface cval) {,         if (cval instanceof FormulaRecordAggregate) {,             return HSSFCell.CELL_TYPE_FORMULA;,         },         // all others are plain BIFF records,         Record record = ( Record ) cval;,         switch (record.getSid()) {, ,             case NumberRecord.sid :   return HSSFCell.CELL_TYPE_NUMERIC;,             case BlankRecord.sid :    return HSSFCell.CELL_TYPE_BLANK;,             case LabelSSTRecord.sid : return HSSFCell.CELL_TYPE_STRING;,             case BoolErrRecord.sid :,                 BoolErrRecord boolErrRecord = ( BoolErrRecord ) record;, ,                 return boolErrRecord.isBoolean(),                          ? HSSFCell.CELL_TYPE_BOOLEAN,                          : HSSFCell.CELL_TYPE_ERROR;,         },         throw new RuntimeException("Bad cell value rec (" + cval.getClass().getName() + ")");,     }, ,     /**,      * Returns the Workbook that this Cell is bound to,      */,     protected InternalWorkbook getBoundWorkbook() {,         return _book.getWorkbook();,     }, ,     /**,      * @return the (zero based) index of the row containing this cell,      */,     public int getRowIndex() {,         return _record.getRow();,     },     /**,      * Set the cell's number within the row (0 based).,      * @param num  short the cell number,      * @deprecated (Jan 2008) Doesn't update the row's idea of what cell this is, use {@link HSSFRow#moveCell(HSSFCell, short)} instead,      */,     public void setCellNum(short num),     {,         _record.setColumn(num);,     }, ,     /**,      * Updates the cell record's idea of what,      *  column it belongs in (0 based),      * @param num the new cell number,      */,     protected void updateCellNum(short num),     {,         _record.setColumn(num);,     }, ,     /**,      * @deprecated (Oct 2008) use {@link #getColumnIndex()},      */,     public short getCellNum() {,         return (short) getColumnIndex();,     }, ,     public int getColumnIndex() {,         return _record.getColumn() & 0xFFFF;,     }, ,     /**,      * set the cells type (numeric, formula or string),      * @see #CELL_TYPE_NUMERIC,      * @see #CELL_TYPE_STRING,      * @see #CELL_TYPE_FORMULA,      * @see #CELL_TYPE_BLANK,      * @see #CELL_TYPE_BOOLEAN,      * @see #CELL_TYPE_ERROR,      */,     public void setCellType(int cellType) {,         notifyFormulaChanging();,         if(isPartOfArrayFormulaGroup()){,             notifyArrayFormulaChanging();,         },         int row=_record.getRow();,         short col=_record.getColumn();,         short styleIndex=_record.getXFIndex();,         setCellType(cellType, true, row, col, styleIndex);,     }, ,     /**,      * sets the cell type. The setValue flag indicates whether to bother about,      *  trying to preserve the current value in the new record if one is created.,      *  <p>,      *  The @see #setCellValue method will call this method with false in setValue,      *  since it will overwrite the cell value later,      *,      */, ,     private void setCellType(int cellType, boolean setValue, int row,short col, short styleIndex),     {, ,         if (cellType > CELL_TYPE_ERROR),         {,             throw new RuntimeException("I have no idea what type that is!");,         },         switch (cellType),         {, ,             case CELL_TYPE_FORMULA :,                 FormulaRecordAggregate frec;, ,                 if (cellType != _cellType) {,                     frec = _sheet.getSheet().getRowsAggregate().createFormula(row, col);,                 } else {,                     frec = (FormulaRecordAggregate) _record;,                     frec.setRow(row);,                     frec.setColumn(col);,                 },                 if (setValue),                 {,                     frec.getFormulaRecord().setValue(getNumericCellValue());,                 },                 frec.setXFIndex(styleIndex);,                 _record = frec;,                 break;, ,             case CELL_TYPE_NUMERIC :,                 NumberRecord nrec = null;, ,                 if (cellType != _cellType),                 {,                     nrec = new NumberRecord();,                 },                 else,                 {,                     nrec = ( NumberRecord ) _record;,                 },                 nrec.setColumn(col);,                 if (setValue),                 {,                     nrec.setValue(getNumericCellValue());,                 },                 nrec.setXFIndex(styleIndex);,                 nrec.setRow(row);,                 _record = nrec;,                 break;, ,             case CELL_TYPE_STRING :,                 LabelSSTRecord lrec;, ,                 if (cellType == _cellType) {,                     lrec = (LabelSSTRecord) _record;,                 } else {,                     lrec = new LabelSSTRecord();,                     lrec.setColumn(col);,                     lrec.setRow(row);,                     lrec.setXFIndex(styleIndex);,                 },                 if (setValue) {,                     String str = convertCellValueToString();,                     int sstIndex = _book.getWorkbook().addSSTString(new UnicodeString(str));,                     lrec.setSSTIndex(sstIndex);,                     UnicodeString us = _book.getWorkbook().getSSTString(sstIndex);,                     _stringValue = new HSSFRichTextString();,                     _stringValue.setUnicodeString(us);,                 },                 _record = lrec;,                 break;, ,             case CELL_TYPE_BLANK :,                 BlankRecord brec = null;, ,                 if (cellType != _cellType),                 {,                     brec = new BlankRecord();,                 },                 else,                 {,                     brec = ( BlankRecord ) _record;,                 },                 brec.setColumn(col);, ,                 // During construction the cellStyle may be null for a Blank cell.,                 brec.setXFIndex(styleIndex);,                 brec.setRow(row);,                 _record = brec;,                 break;, ,             case CELL_TYPE_BOOLEAN :,                 BoolErrRecord boolRec = null;, ,                 if (cellType != _cellType),                 {,                     boolRec = new BoolErrRecord();,                 },                 else,                 {,                     boolRec = ( BoolErrRecord ) _record;,                 },                 boolRec.setColumn(col);,                 if (setValue),                 {,                     boolRec.setValue(convertCellValueToBoolean());,                 },                 boolRec.setXFIndex(styleIndex);,                 boolRec.setRow(row);,                 _record = boolRec;,                 break;, ,             case CELL_TYPE_ERROR :,                 BoolErrRecord errRec = null;, ,                 if (cellType != _cellType),                 {,                     errRec = new BoolErrRecord();,                 },                 else,                 {,                     errRec = ( BoolErrRecord ) _record;,                 },                 errRec.setColumn(col);,                 if (setValue),                 {,                     errRec.setValue((byte)HSSFErrorConstants.ERROR_VALUE);,                 },                 errRec.setXFIndex(styleIndex);,                 errRec.setRow(row);,                 _record = errRec;,                 break;,         },         if (cellType != _cellType &&,             _cellType!=-1 )  // Special Value to indicate an uninitialized Cell,         {,             _sheet.getSheet().replaceValueRecord(_record);,         },         _cellType = cellType;,     }, ,     /**,      * get the cells type (numeric, formula or string),      * @see #CELL_TYPE_STRING,      * @see #CELL_TYPE_NUMERIC,      * @see #CELL_TYPE_FORMULA,      * @see #CELL_TYPE_BOOLEAN,      * @see #CELL_TYPE_ERROR,      */, ,     public int getCellType(),     {,         return _cellType;,     }, ,     /**,      * set a numeric value for the cell,      *,      * @param value  the numeric value to set this cell to.  For formulas we'll set the,      *        precalculated value, for numerics we'll set its value. For other types we,      *        will change the cell to a numeric cell and set its value.,      */,     public void setCellValue(double value) {,         if(Double.isInfinite(value)) {,             // Excel does not support positive/negative infinities,,             // rather, it gives a #DIV/0! error in these cases.,             setCellErrorValue(FormulaError.DIV0.getCode());,         } else if (Double.isNaN(value)){,             // Excel does not support Not-a-Number (NaN),,             // instead it immediately generates a #NUM! error.,             setCellErrorValue(FormulaError.NUM.getCode());,         } else {,             int row=_record.getRow();,             short col=_record.getColumn();,             short styleIndex=_record.getXFIndex();, ,             switch (_cellType) {,                 default:,                     setCellType(CELL_TYPE_NUMERIC, false, row, col, styleIndex);,                 case CELL_TYPE_NUMERIC:,                     (( NumberRecord ) _record).setValue(value);,                     break;,                 case CELL_TYPE_FORMULA:,                     ((FormulaRecordAggregate)_record).setCachedDoubleResult(value);,                     break;,             },         }, ,     }, ,     /**,      * set a date value for the cell. Excel treats dates as numeric so you will need to format the cell as,      * a date.,      *,      * @param value  the date value to set this cell to.  For formulas we'll set the,      *        precalculated value, for numerics we'll set its value. For other types we,      *        will change the cell to a numeric cell and set its value.,      */,     public void setCellValue(Date value),     {,         setCellValue(HSSFDateUtil.getExcelDate(value, _book.getWorkbook().isUsing1904DateWindowing()));,     }, ,     /**,      * set a date value for the cell. Excel treats dates as numeric so you will need to format the cell as,      * a date.,      *,      * This will set the cell value based on the Calendar's timezone. As Excel,      * does not support timezones this means that both 20:00+03:00 and,      * 20:00-03:00 will be reported as the same value (20:00) even that there,      * are 6 hours difference between the two times. This difference can be,      * preserved by using <code>setCellValue(value.getTime())</code> which will,      * automatically shift the times to the default timezone.,      *,      * @param value  the date value to set this cell to.  For formulas we'll set the,      *        precalculated value, for numerics we'll set its value. For othertypes we,      *        will change the cell to a numeric cell and set its value.,      */,     public void setCellValue(Calendar value),     {,         setCellValue( HSSFDateUtil.getExcelDate(value, _book.getWorkbook().isUsing1904DateWindowing()) );,     }, ,     /**,      * set a string value for the cell.,      *,      * @param value value to set the cell to.  For formulas we'll set the formula,      * cached string result, for String cells we'll set its value. For other types we will,      * change the cell to a string cell and set its value.,      * If value is null then we will change the cell to a Blank cell.,      */,     public void setCellValue(String value) {,         HSSFRichTextString str = value == null ? null :  new HSSFRichTextString(value);,         setCellValue(str);,     }, ,     /**,      * Set a string value for the cell.,      *,      * @param value  value to set the cell to.  For formulas we'll set the formula,      * string, for String cells we'll set its value.  For other types we will,      * change the cell to a string cell and set its value.,      * If value is <code>null</code> then we will change the cell to a Blank cell.,      */, ,     public void setCellValue(RichTextString value),     {,         HSSFRichTextString hvalue = (HSSFRichTextString) value;,         int row=_record.getRow();,         short col=_record.getColumn();,         short styleIndex=_record.getXFIndex();,         if (hvalue == null),         {,             notifyFormulaChanging();,             setCellType(CELL_TYPE_BLANK, false, row, col, styleIndex);,             return;,         }, ,         if(hvalue.length() > SpreadsheetVersion.EXCEL97.getMaxTextLength()){,             throw new IllegalArgumentException("The maximum length of cell contents (text) is 32,767 characters");,         }, ,         if (_cellType == CELL_TYPE_FORMULA) {,             // Set the 'pre-evaluated result' for the formula,             // note - formulas do not preserve text formatting.,             FormulaRecordAggregate fr = (FormulaRecordAggregate) _record;,             fr.setCachedStringResult(hvalue.getString());,             // Update our local cache to the un-formatted version,             _stringValue = new HSSFRichTextString(value.getString());, ,             // All done,             return;,         }, ,         // If we get here, we're not dealing with a formula,,         //  so handle things as a normal rich text cell, ,         if (_cellType != CELL_TYPE_STRING) {,             setCellType(CELL_TYPE_STRING, false, row, col, styleIndex);,         },         int index = 0;, ,         UnicodeString str = hvalue.getUnicodeString();,         index = _book.getWorkbook().addSSTString(str);,         (( LabelSSTRecord ) _record).setSSTIndex(index);,         _stringValue = hvalue;,         _stringValue.setWorkbookReferences(_book.getWorkbook(), (( LabelSSTRecord ) _record));,         _stringValue.setUnicodeString(_book.getWorkbook().getSSTString(index));,     }, ,     public void setCellFormula(String formula) {,         if(isPartOfArrayFormulaGroup()){,             notifyArrayFormulaChanging();,         }, ,         int row=_record.getRow();,         short col=_record.getColumn();,         short styleIndex=_record.getXFIndex();, ,         if (formula==null) {,             notifyFormulaChanging();,             setCellType(CELL_TYPE_BLANK, false, row, col, styleIndex);,             return;,         },         int sheetIndex = _book.getSheetIndex(_sheet);,         Ptg[] ptgs = HSSFFormulaParser.parse(formula, _book, FormulaType.CELL, sheetIndex);,         setCellType(CELL_TYPE_FORMULA, false, row, col, styleIndex);,         FormulaRecordAggregate agg = (FormulaRecordAggregate) _record;,         FormulaRecord frec = agg.getFormulaRecord();,         frec.setOptions((short) 2);,         frec.setValue(0);, ,         //only set to default if there is no extended format index already set,         if (agg.getXFIndex() == (short)0) {,             agg.setXFIndex((short) 0x0f);,         },         agg.setParsedExpression(ptgs);,     },     /**,      * Should be called any time that a formula could potentially be deleted.,      * Does nothing if this cell currently does not hold a formula,      */,     private void notifyFormulaChanging() {,         if (_record instanceof FormulaRecordAggregate) {,             ((FormulaRecordAggregate)_record).notifyFormulaChanging();,         },     }, ,     public String getCellFormula() {,         if (!(_record instanceof FormulaRecordAggregate)) {,             throw typeMismatch(CELL_TYPE_FORMULA, _cellType, true);,         },         return HSSFFormulaParser.toFormulaString(_book, ((FormulaRecordAggregate)_record).getFormulaTokens());,     }, ,     /**,      * Used to help format error messages,      */,     private static String getCellTypeName(int cellTypeCode) {,         switch (cellTypeCode) {,             case CELL_TYPE_BLANK:   return "blank";,             case CELL_TYPE_STRING:  return "text";,             case CELL_TYPE_BOOLEAN: return "boolean";,             case CELL_TYPE_ERROR:   return "error";,             case CELL_TYPE_NUMERIC: return "numeric";,             case CELL_TYPE_FORMULA: return "formula";,         },         return "#unknown cell type (" + cellTypeCode + ")#";,     }, ,     private static RuntimeException typeMismatch(int expectedTypeCode, int actualTypeCode, boolean isFormulaCell) {,         String msg = "Cannot get a ",             + getCellTypeName(expectedTypeCode) + " value from a ",             + getCellTypeName(actualTypeCode) + " " + (isFormulaCell ? "formula " : "") + "cell";,         return new IllegalStateException(msg);,     },     private static void checkFormulaCachedValueType(int expectedTypeCode, FormulaRecord fr) {,         int cachedValueType = fr.getCachedResultType();,         if (cachedValueType != expectedTypeCode) {,             throw typeMismatch(expectedTypeCode, cachedValueType, true);,         },     }, ,     /**,      * Get the value of the cell as a number.,      * For strings we throw an exception.,      * For blank cells we return a 0.,      * See {@link HSSFDataFormatter} for turning this,      *  number into a string similar to that which,      *  Excel would render this number as.,      */,     public double getNumericCellValue() {, ,         switch(_cellType) {,             case CELL_TYPE_BLANK:,                 return 0.0;,             case CELL_TYPE_NUMERIC:,                 return ((NumberRecord)_record).getValue();,             default:,                 throw typeMismatch(CELL_TYPE_NUMERIC, _cellType, false);,             case CELL_TYPE_FORMULA:,                 break;,         },         FormulaRecord fr = ((FormulaRecordAggregate)_record).getFormulaRecord();,         checkFormulaCachedValueType(CELL_TYPE_NUMERIC, fr);,         return fr.getValue();,     }, ,     /**,      * Get the value of the cell as a date.,      * For strings we throw an exception.,      * For blank cells we return a null.,      * See {@link HSSFDataFormatter} for formatting,      *  this date into a string similar to how excel does.,      */,     public Date getDateCellValue() {, ,         if (_cellType == CELL_TYPE_BLANK) {,             return null;,         },         double value = getNumericCellValue();,         if (_book.getWorkbook().isUsing1904DateWindowing()) {,             return HSSFDateUtil.getJavaDate(value, true);,         },         return HSSFDateUtil.getJavaDate(value, false);,     }, ,     /**,      * get the value of the cell as a string - for numeric cells we throw an exception.,      * For blank cells we return an empty string.,      * For formulaCells that are not string Formulas, we throw an exception,      */,     public String getStringCellValue(),     {,       HSSFRichTextString str = getRichStringCellValue();,       return str.getString();,     }, ,     /**,      * get the value of the cell as a string - for numeric cells we throw an exception.,      * For blank cells we return an empty string.,      * For formulaCells that are not string Formulas, we throw an exception,      */,     public HSSFRichTextString getRichStringCellValue() {, ,         switch(_cellType) {,             case CELL_TYPE_BLANK:,                 return new HSSFRichTextString("");,             case CELL_TYPE_STRING:,                 return _stringValue;,             default:,                 throw typeMismatch(CELL_TYPE_STRING, _cellType, false);,             case CELL_TYPE_FORMULA:,                 break;,         },         FormulaRecordAggregate fra = ((FormulaRecordAggregate)_record);,         checkFormulaCachedValueType(CELL_TYPE_STRING, fra.getFormulaRecord());,         String strVal = fra.getStringValue();,         return new HSSFRichTextString(strVal == null ? "" : strVal);,     }, ,     /**,      * set a boolean value for the cell,      *,      * @param value the boolean value to set this cell to.  For formulas we'll set the,      *        precalculated value, for booleans we'll set its value. For other types we,      *        will change the cell to a boolean cell and set its value.,      */,     public void setCellValue(boolean value) {,         int row=_record.getRow();,         short col=_record.getColumn();,         short styleIndex=_record.getXFIndex();, ,         switch (_cellType) {,             default:,                 setCellType(CELL_TYPE_BOOLEAN, false, row, col, styleIndex);,             case CELL_TYPE_BOOLEAN:,                 (( BoolErrRecord ) _record).setValue(value);,                 break;,             case CELL_TYPE_FORMULA:,                 ((FormulaRecordAggregate)_record).setCachedBooleanResult(value);,                 break;,         },     }, ,     /**,      * set a error value for the cell,      *,      * @param errorCode the error value to set this cell to.  For formulas we'll set the,      *        precalculated value , for errors we'll set,      *        its value. For other types we will change the cell to an error,      *        cell and set its value.,      */,     public void setCellErrorValue(byte errorCode) {,         int row=_record.getRow();,         short col=_record.getColumn();,         short styleIndex=_record.getXFIndex();,         switch (_cellType) {,             default:,                 setCellType(CELL_TYPE_ERROR, false, row, col, styleIndex);,             case CELL_TYPE_ERROR:,                 (( BoolErrRecord ) _record).setValue(errorCode);,                 break;,             case CELL_TYPE_FORMULA:,                 ((FormulaRecordAggregate)_record).setCachedErrorResult(errorCode);,                 break;,         },     },     /**,      * Chooses a new boolean value for the cell when its type is changing.<p/>,      *,      * Usually the caller is calling setCellType() with the intention of calling,      * setCellValue(boolean) straight afterwards.  This method only exists to give,      * the cell a somewhat reasonable value until the setCellValue() call (if at all).,      * TODO - perhaps a method like setCellTypeAndValue(int, Object) should be introduced to avoid this,      */,     private boolean convertCellValueToBoolean() {, ,         switch (_cellType) {,             case CELL_TYPE_BOOLEAN:,                 return (( BoolErrRecord ) _record).getBooleanValue();,             case CELL_TYPE_STRING:,                 int sstIndex = ((LabelSSTRecord)_record).getSSTIndex();,                 String text = _book.getWorkbook().getSSTString(sstIndex).getString();,                 return Boolean.valueOf(text).booleanValue();,             case CELL_TYPE_NUMERIC:,                 return ((NumberRecord)_record).getValue() != 0;, ,             case CELL_TYPE_FORMULA:,                 // use cached formula result if it's the right type:,                 FormulaRecord fr = ((FormulaRecordAggregate)_record).getFormulaRecord();,                 checkFormulaCachedValueType(CELL_TYPE_BOOLEAN, fr);,                 return fr.getCachedBooleanValue();,             // Other cases convert to false,             // These choices are not well justified.,             case CELL_TYPE_ERROR:,             case CELL_TYPE_BLANK:,                 return false;,         },         throw new RuntimeException("Unexpected cell type (" + _cellType + ")");,     },     private String convertCellValueToString() {, ,         switch (_cellType) {,             case CELL_TYPE_BLANK:,                 return "";,             case CELL_TYPE_BOOLEAN:,                 return ((BoolErrRecord) _record).getBooleanValue() ? "TRUE" : "FALSE";,             case CELL_TYPE_STRING:,                 int sstIndex = ((LabelSSTRecord)_record).getSSTIndex();,                 return _book.getWorkbook().getSSTString(sstIndex).getString();,             case CELL_TYPE_NUMERIC:,                 return NumberToTextConverter.toText(((NumberRecord)_record).getValue());,             case CELL_TYPE_ERROR:,                    return HSSFErrorConstants.getText(((BoolErrRecord) _record).getErrorValue());,             case CELL_TYPE_FORMULA:,                 // should really evaluate, but HSSFCell can't call HSSFFormulaEvaluator,                 // just use cached formula result instead,                 break;,             default:,                 throw new IllegalStateException("Unexpected cell type (" + _cellType + ")");,         },         FormulaRecordAggregate fra = ((FormulaRecordAggregate)_record);,         FormulaRecord fr = fra.getFormulaRecord();,         switch (fr.getCachedResultType()) {,             case CELL_TYPE_BOOLEAN:,                 return fr.getCachedBooleanValue() ? "TRUE" : "FALSE";,             case CELL_TYPE_STRING:,                 return fra.getStringValue();,             case CELL_TYPE_NUMERIC:,                 return NumberToTextConverter.toText(fr.getValue());,             case CELL_TYPE_ERROR:,                    return HSSFErrorConstants.getText(fr.getCachedErrorValue());,         },         throw new IllegalStateException("Unexpected formula result type (" + _cellType + ")");,     }, ,     /**,      * get the value of the cell as a boolean.  For strings, numbers, and errors, we throw an exception.,      * For blank cells we return a false.,      */,     public boolean getBooleanCellValue() {, ,         switch(_cellType) {,             case CELL_TYPE_BLANK:,                 return false;,             case CELL_TYPE_BOOLEAN:,                 return (( BoolErrRecord ) _record).getBooleanValue();,             default:,                 throw typeMismatch(CELL_TYPE_BOOLEAN, _cellType, false);,             case CELL_TYPE_FORMULA:,                 break;,         },         FormulaRecord fr = ((FormulaRecordAggregate)_record).getFormulaRecord();,         checkFormulaCachedValueType(CELL_TYPE_BOOLEAN, fr);,         return fr.getCachedBooleanValue();,     }, ,     /**,      * get the value of the cell as an error code.  For strings, numbers, and booleans, we throw an exception.,      * For blank cells we return a 0.,      */,     public byte getErrorCellValue() {,         switch(_cellType) {,             case CELL_TYPE_ERROR:,                 return (( BoolErrRecord ) _record).getErrorValue();,             default:,                 throw typeMismatch(CELL_TYPE_ERROR, _cellType, false);,             case CELL_TYPE_FORMULA:,                 break;,         },         FormulaRecord fr = ((FormulaRecordAggregate)_record).getFormulaRecord();,         checkFormulaCachedValueType(CELL_TYPE_ERROR, fr);,         return (byte) fr.getCachedErrorValue();,     }, ,     /**,      * set the style for the cell.  The style should be an HSSFCellStyle created/retreived from,      * the HSSFWorkbook.,      *,      * @param style  reference contained in the workbook,      * @see org.apache.poi.hssf.usermodel.HSSFWorkbook#createCellStyle(),      * @see org.apache.poi.hssf.usermodel.HSSFWorkbook#getCellStyleAt(short),      */,     public void setCellStyle(CellStyle style) {,         setCellStyle( (HSSFCellStyle)style );,     },     public void setCellStyle(HSSFCellStyle style) {,         // Verify it really does belong to our workbook,         style.verifyBelongsToWorkbook(_book);, ,         short styleIndex;,         if(style.getUserStyleName() != null) {,             styleIndex = applyUserCellStyle(style);,         } else {,             styleIndex = style.getIndex();,         }, ,         // Change our cell record to use this style,         _record.setXFIndex(styleIndex);,     }, ,     /**,      * get the style for the cell.  This is a reference to a cell style contained in the workbook,      * object.,      * @see org.apache.poi.hssf.usermodel.HSSFWorkbook#getCellStyleAt(short),      */,     public HSSFCellStyle getCellStyle(),     {,       short styleIndex=_record.getXFIndex();,       ExtendedFormatRecord xf = _book.getWorkbook().getExFormatAt(styleIndex);,       return new HSSFCellStyle(styleIndex, xf, _book);,     }, ,     /**,      * Should only be used by HSSFSheet and friends.  Returns the low level CellValueRecordInterface record,      *,      * @return CellValueRecordInterface representing the cell via the low level api.,      */, ,     protected CellValueRecordInterface getCellValueRecord(),     {,         return _record;,     }, ,     /**,      * @throws RuntimeException if the bounds are exceeded.,      */,     private static void checkBounds(int cellIndex) {,         if (cellIndex < 0 || cellIndex > LAST_COLUMN_NUMBER) {,             throw new IllegalArgumentException("Invalid column index (" + cellIndex,                     + ").  Allowable column range for " + FILE_FORMAT_NAME + " is (0..",                     + LAST_COLUMN_NUMBER + ") or ('A'..'" + LAST_COLUMN_NAME + "')");,         },     }, ,     /**,      * Sets this cell as the active cell for the worksheet,      */,     public void setAsActiveCell(),     {,         int row=_record.getRow();,         short col=_record.getColumn();,         _sheet.getSheet().setActiveCellRow(row);,         _sheet.getSheet().setActiveCellCol(col);,     }, ,     /**,      * Returns a string representation of the cell,      *,      * This method returns a simple representation,,      * anthing more complex should be in user code, with,      * knowledge of the semantics of the sheet being processed.,      *,      * Formula cells return the formula string,,      * rather than the formula result.,      * Dates are displayed in dd-MMM-yyyy format,      * Errors are displayed as #ERR&lt;errIdx&gt;,      */,     public String toString() {,         switch (getCellType()) {,             case CELL_TYPE_BLANK:,                 return "";,             case CELL_TYPE_BOOLEAN:,                 return getBooleanCellValue()?"TRUE":"FALSE";,             case CELL_TYPE_ERROR:,                 return ErrorEval.getText((( BoolErrRecord ) _record).getErrorValue());,             case CELL_TYPE_FORMULA:,                 return getCellFormula();,             case CELL_TYPE_NUMERIC:,                 //TODO apply the dataformat for this cell,                 if (HSSFDateUtil.isCellDateFormatted(this)) {,                     DateFormat sdf = new SimpleDateFormat("dd-MMM-yyyy");,                     return sdf.format(getDateCellValue());,                 }, 				return  String.valueOf(getNumericCellValue());,             case CELL_TYPE_STRING:,                 return getStringCellValue();,             default:,                 return "Unknown Cell Type: " + getCellType();,         },     }, ,     /**,      * Assign a comment to this cell. If the supplied,      *  comment is null, the comment for this cell,      *  will be removed.,      *,      * @param comment comment associated with this cell,      */,     public void setCellComment(Comment comment){,         if(comment == null) {,             removeCellComment();,             return;,         }, ,         comment.setRow(_record.getRow());,         comment.setColumn(_record.getColumn());,         _comment = (HSSFComment)comment;,     }, ,     /**,      * Returns comment associated with this cell,      *,      * @return comment associated with this cell,      */,      public HSSFComment getCellComment(){,         if (_comment == null) {,             _comment = findCellComment(_sheet.getSheet(), _record.getRow(), _record.getColumn());,         },         return _comment;,     }, ,     /**,      * Removes the comment for this cell, if,      *  there is one.,      * WARNING - some versions of excel will loose,      *  all comments after performing this action!,      */,     public void removeCellComment() {,         HSSFComment comment = findCellComment(_sheet.getSheet(), _record.getRow(), _record.getColumn());,         _comment = null;, ,         if(comment == null) {,             // Nothing to do,             return;,         }, ,         // Zap the underlying NoteRecord,         List<RecordBase> sheetRecords = _sheet.getSheet().getRecords();,         sheetRecords.remove(comment.getNoteRecord());, ,         // If we have a TextObjectRecord, is should,         //  be proceeed by:,         // MSODRAWING with container,         // OBJ,         // MSODRAWING with EscherTextboxRecord,         if(comment.getTextObjectRecord() != null) {,             TextObjectRecord txo = comment.getTextObjectRecord();,             int txoAt = sheetRecords.indexOf(txo);, ,             if(sheetRecords.get(txoAt-3) instanceof DrawingRecord &&,                 sheetRecords.get(txoAt-2) instanceof ObjRecord &&,                 sheetRecords.get(txoAt-1) instanceof DrawingRecord) {,                 // Zap these, in reverse order,                 sheetRecords.remove(txoAt-1);,                 sheetRecords.remove(txoAt-2);,                 sheetRecords.remove(txoAt-3);,             } else {,                 throw new IllegalStateException("Found the wrong records before the TextObjectRecord, can't remove comment");,             }, ,             // Now remove the text record,             sheetRecords.remove(txo);,         },     }, ,     /**,      * Cell comment finder.,      * Returns cell comment for the specified sheet, row and column.,      *,      * @return cell comment or <code>null</code> if not found,      */,     protected static HSSFComment findCellComment(InternalSheet sheet, int row, int column) {,         // TODO - optimise this code by searching backwards, find NoteRecord first, quit if not found. Find one TXO by id,         HSSFComment comment = null;,         Map<Integer, TextObjectRecord> noteTxo =,                                new HashMap<Integer, TextObjectRecord>();,         int i = 0;,         for (Iterator<RecordBase> it = sheet.getRecords().iterator(); it.hasNext();) {,             RecordBase rec = it.next();,             if (rec instanceof NoteRecord) {,                 NoteRecord note = (NoteRecord) rec;,                 if (note.getRow() == row && note.getColumn() == column) {,                     if(i < noteTxo.size()) {,                         TextObjectRecord txo = noteTxo.get(note.getShapeId());,                         if(txo != null){,                             comment = new HSSFComment(note, txo);,                             comment.setRow(note.getRow());,                             comment.setColumn(note.getColumn());,                             comment.setAuthor(note.getAuthor());,                             comment.setVisible(note.getFlags() == NoteRecord.NOTE_VISIBLE);,                             comment.setString(txo.getStr());     ,                         } else{,                             log.log(POILogger.WARN, "Failed to match NoteRecord and TextObjectRecord, row: " + row + ", column: " + column);,                          },                     } else {,                         log.log(POILogger.WARN, "Failed to match NoteRecord and TextObjectRecord, row: " + row + ", column: " + column);,                     },                     break;,                 },                 i++;,             } else if (rec instanceof ObjRecord) {,                 ObjRecord obj = (ObjRecord) rec;,                 SubRecord sub = obj.getSubRecords().get(0);,                 if (sub instanceof CommonObjectDataSubRecord) {,                     CommonObjectDataSubRecord cmo = (CommonObjectDataSubRecord) sub;,                     if (cmo.getObjectType() == CommonObjectDataSubRecord.OBJECT_TYPE_COMMENT) {,                         //map ObjectId and corresponding TextObjectRecord,,                         //it will be used to match NoteRecord and TextObjectRecord,                         while (it.hasNext()) {,                             rec = it.next();,                             if (rec instanceof TextObjectRecord) {,                                 noteTxo.put(cmo.getObjectId(), (TextObjectRecord) rec);,                                 break;,                             },                         },                     },                 },             },         },         return comment;,     }, ,     /**,      * @return hyperlink associated with this cell or <code>null</code> if not found,      */,     public HSSFHyperlink getHyperlink(){,         for (Iterator<RecordBase> it = _sheet.getSheet().getRecords().iterator(); it.hasNext(); ) {,             RecordBase rec = it.next();,             if (rec instanceof HyperlinkRecord){,                 HyperlinkRecord link = (HyperlinkRecord)rec;,                 if(link.getFirstColumn() == _record.getColumn() && link.getFirstRow() == _record.getRow()){,                     return new HSSFHyperlink(link);,                 },             },         },         return null;,     }, ,     /**,      * Assign a hyperlink to this cell,      *,      * @param hyperlink hyperlink associated with this cell,      */,     public void setHyperlink(Hyperlink hyperlink){,         HSSFHyperlink link = (HSSFHyperlink)hyperlink;, ,         link.setFirstRow(_record.getRow());,         link.setLastRow(_record.getRow());,         link.setFirstColumn(_record.getColumn());,         link.setLastColumn(_record.getColumn());, ,         switch(link.getType()){,             case HSSFHyperlink.LINK_EMAIL:,             case HSSFHyperlink.LINK_URL:,                 link.setLabel("url");,                 break;,             case HSSFHyperlink.LINK_FILE:,                 link.setLabel("file");,                 break;,             case HSSFHyperlink.LINK_DOCUMENT:,                 link.setLabel("place");,                 break;,         }, ,         List<RecordBase> records = _sheet.getSheet().getRecords();,         int eofLoc = records.size() - 1;,         records.add( eofLoc, link.record );,     },     /**,      * Only valid for formula cells,      * @return one of ({@link #CELL_TYPE_NUMERIC}, {@link #CELL_TYPE_STRING},,      *     {@link #CELL_TYPE_BOOLEAN}, {@link #CELL_TYPE_ERROR}) depending,      * on the cached value of the formula,      */,     public int getCachedFormulaResultType() {,         if (_cellType != CELL_TYPE_FORMULA) {,             throw new IllegalStateException("Only formula cells have cached results");,         },         return ((FormulaRecordAggregate)_record).getFormulaRecord().getCachedResultType();,     }, ,     void setCellArrayFormula(CellRangeAddress range) {,         int row = _record.getRow();,         short col = _record.getColumn();,         short styleIndex = _record.getXFIndex();,         setCellType(CELL_TYPE_FORMULA, false, row, col, styleIndex);, ,         // Billet for formula in rec,         Ptg[] ptgsForCell = {new ExpPtg(range.getFirstRow(), range.getFirstColumn())};,         FormulaRecordAggregate agg = (FormulaRecordAggregate) _record;,         agg.setParsedExpression(ptgsForCell);,     }, ,     public CellRangeAddress getArrayFormulaRange() {,         if (_cellType != CELL_TYPE_FORMULA) {,             String ref = new CellReference(this).formatAsString();,             throw new IllegalStateException("Cell " + ref,                     + " is not part of an array formula.");,         },         return ((FormulaRecordAggregate)_record).getArrayFormulaRange();,     }, ,     public boolean isPartOfArrayFormulaGroup() {,         if (_cellType != CELL_TYPE_FORMULA) {,             return false;,         },         return ((FormulaRecordAggregate)_record).isPartOfArrayFormula();,     }, ,     /**,      * The purpose of this method is to validate the cell state prior to modification,      *,      * @see #notifyArrayFormulaChanging(),      */,     void notifyArrayFormulaChanging(String msg){,         CellRangeAddress cra = getArrayFormulaRange();,         if(cra.getNumberOfCells() > 1) {,             throw new IllegalStateException(msg);,         },         //un-register the single-cell array formula from the parent XSSFSheet,         getRow().getSheet().removeArrayFormula(this);,     }, ,     /**,      * Called when this cell is modified.,      * <p>,      * The purpose of this method is to validate the cell state prior to modification.,      * </p>,      *,      * @see #setCellType(int),      * @see #setCellFormula(String),      * @see HSSFRow#removeCell(org.apache.poi.ss.usermodel.Cell),      * @see org.apache.poi.hssf.usermodel.HSSFSheet#removeRow(org.apache.poi.ss.usermodel.Row),      * @see org.apache.poi.hssf.usermodel.HSSFSheet#shiftRows(int, int, int),      * @see org.apache.poi.hssf.usermodel.HSSFSheet#addMergedRegion(org.apache.poi.ss.util.CellRangeAddress),      * @throws IllegalStateException if modification is not allowed,      */,     void notifyArrayFormulaChanging(){,         CellReference ref = new CellReference(this);,         String msg = "Cell "+ref.formatAsString()+" is part of a multi-cell array formula. " +,                 "You cannot change part of an array.";,         notifyArrayFormulaChanging(msg);,     }, ,     /**,      * Applying a user-defined style (UDS) is special. Excel does not directly reference user-defined styles, but,      * instead create a 'proxy' ExtendedFormatRecord referencing the UDS as parent.,      *,      * The proceudre to apply a UDS is as follows:,      *,      * 1. search for a ExtendedFormatRecord with parentIndex == style.getIndex(),      *    and xfType ==  ExtendedFormatRecord.XF_CELL.,      * 2. if not found then create a new ExtendedFormatRecord and copy all attributes from the user-defined style,      *    and set the parentIndex to be style.getIndex(),      * 3. return the index of the ExtendedFormatRecord, this will be assigned to the parent cell record,      *,      * @param style  the user style to apply,      *,      * @return  the index of a ExtendedFormatRecord record that will be referenced by the cell,      */,     private short applyUserCellStyle(HSSFCellStyle style){,         if(style.getUserStyleName() == null) {,             throw new IllegalArgumentException("Expected user-defined style");,         }, ,         InternalWorkbook iwb = _book.getWorkbook();,         short userXf = -1;,         int numfmt = iwb.getNumExFormats();,         for(short i = 0; i < numfmt; i++){,             ExtendedFormatRecord xf = iwb.getExFormatAt(i);,             if(xf.getXFType() == ExtendedFormatRecord.XF_CELL && xf.getParentIndex() == style.getIndex() ){,                 userXf = i;,                 break;,             },         },         short styleIndex;,         if (userXf == -1){,             ExtendedFormatRecord xfr = iwb.createCellXF();,             xfr.cloneStyleFrom(iwb.getExFormatAt(style.getIndex()));,             xfr.setIndentionOptions((short)0);,             xfr.setXFType(ExtendedFormatRecord.XF_CELL);,             xfr.setParentIndex(style.getIndex());,             styleIndex = (short)numfmt;,         } else {,             styleIndex = userXf;,         }, ,         return styleIndex;],,
BAD_PRACTICE,SE_BAD_FIELD,org/apache/poi/hssf/usermodel/HSSFWorkbook.java,,78-1798,[public final class HSSFWorkbook extends POIDocument implements org.apache.poi.ss.usermodel.Workbook {,     private static final Pattern COMMA_PATTERN = Pattern.compile(",");,     private static final int MAX_ROW = 0xFFFF;,     private static final short MAX_COLUMN = (short)0x00FF;, ,     /**,      * The maximum number of cell styles in a .xls workbook.,      * The 'official' limit is 4,000, but POI allows a slightly larger number.,      * This extra delta takes into account built-in styles that are automatically,      * created for new workbooks,      *,      * See http://office.microsoft.com/en-us/excel-help/excel-specifications-and-limits-HP005199291.aspx,      */,     private static final int MAX_STYLES = 4030;, ,     private static final int DEBUG = POILogger.DEBUG;, ,     /**,      * used for compile-time performance/memory optimization.  This determines the,      * initial capacity for the sheet collection.  Its currently set to 3.,      * Changing it in this release will decrease performance,      * since you're never allowed to have more or less than three sheets!,      */, ,     public final static int INITIAL_CAPACITY = 3;, ,     /**,      * this is the reference to the low level Workbook object,      */, ,     private InternalWorkbook workbook;, ,     /**,      * this holds the HSSFSheet objects attached to this workbook,      */, ,     protected List<HSSFSheet> _sheets;, ,     /**,      * this holds the HSSFName objects attached to this workbook,      */, ,     private ArrayList<HSSFName> names;, ,     /**,      * this holds the HSSFFont objects attached to this workbook.,      * We only create these from the low level records as required.,      */,     private Hashtable fonts;, ,     /**,      * holds whether or not to preserve other nodes in the POIFS.  Used,      * for macros and embedded objects.,      */,     private boolean   preserveNodes;, ,     /**,      * Used to keep track of the data formatter so that all,      * createDataFormatter calls return the same one for a given,      * book.  This ensures that updates from one places is visible,      * someplace else.,      */,     private HSSFDataFormat formatter;, ,     /**,      * The policy to apply in the event of missing or,      *  blank cells when fetching from a row.,      * See {@link MissingCellPolicy},      */,     private MissingCellPolicy missingCellPolicy = HSSFRow.RETURN_NULL_AND_BLANK;, ,     private static POILogger log = POILogFactory.getLogger(HSSFWorkbook.class);, ,     /**,      * The locator of user-defined functions.,      * By default includes functions from the Excel Analysis Toolpack,      */,     private UDFFinder _udfFinder = UDFFinder.DEFAULT;, ,     public static HSSFWorkbook create(InternalWorkbook book) {,     	return new HSSFWorkbook(book);,     },     /**,      * Creates new HSSFWorkbook from scratch (start here!),      *,      */,     public HSSFWorkbook() {,         this(InternalWorkbook.createWorkbook());,     }, , 	private HSSFWorkbook(InternalWorkbook book) {, 		super((DirectoryNode)null);, 		workbook = book;, 		_sheets = new ArrayList<HSSFSheet>(INITIAL_CAPACITY);, 		names = new ArrayList<HSSFName>(INITIAL_CAPACITY);, 	}, ,     public HSSFWorkbook(POIFSFileSystem fs) throws IOException {,         this(fs,true);,     }, ,     /**,      * given a POI POIFSFileSystem object, read in its Workbook and populate the high and,      * low level models.  If you're reading in a workbook...start here.,      *,      * @param fs the POI filesystem that contains the Workbook stream.,      * @param preserveNodes whether to preseve other nodes, such as,      *        macros.  This takes more memory, so only say yes if you,      *        need to. If set, will store all of the POIFSFileSystem,      *        in memory,      * @see org.apache.poi.poifs.filesystem.POIFSFileSystem,      * @exception IOException if the stream cannot be read,      */,     public HSSFWorkbook(POIFSFileSystem fs, boolean preserveNodes),             throws IOException,     {,         this(fs.getRoot(), fs, preserveNodes);,     }, ,     /**,      * Normally, the Workbook will be in a POIFS Stream,      * called "Workbook". However, some weird XLS generators use "WORKBOOK",      */,     private static final String[] WORKBOOK_DIR_ENTRY_NAMES = {,         "Workbook", // as per BIFF8 spec,         "WORKBOOK",,     };, , ,     private static String getWorkbookDirEntryName(DirectoryNode directory) {, ,         String[] potentialNames = WORKBOOK_DIR_ENTRY_NAMES;,         for (int i = 0; i < potentialNames.length; i++) {,             String wbName = potentialNames[i];,             try {,                 directory.getEntry(wbName);,                 return wbName;,             } catch (FileNotFoundException e) {,                 // continue - to try other options,             },         }, ,         // check for previous version of file format,         try {,             directory.getEntry("Book");,             throw new OldExcelFormatException("The supplied spreadsheet seems to be Excel 5.0/7.0 (BIFF5) format. ",                     + "POI only supports BIFF8 format (from Excel versions 97/2000/XP/2003)");,         } catch (FileNotFoundException e) {,             // fall through,         }, ,         throw new IllegalArgumentException("The supplied POIFSFileSystem does not contain a BIFF8 'Workbook' entry. ",             + "Is it really an excel file?");,     }, ,     /**,      * given a POI POIFSFileSystem object, and a specific directory,      *  within it, read in its Workbook and populate the high and,      *  low level models.  If you're reading in a workbook...start here.,      *,      * @param directory the POI filesystem directory to process from,      * @param fs the POI filesystem that contains the Workbook stream.,      * @param preserveNodes whether to preseve other nodes, such as,      *        macros.  This takes more memory, so only say yes if you,      *        need to. If set, will store all of the POIFSFileSystem,      *        in memory,      * @see org.apache.poi.poifs.filesystem.POIFSFileSystem,      * @exception IOException if the stream cannot be read,      */,     public HSSFWorkbook(DirectoryNode directory, POIFSFileSystem fs, boolean preserveNodes),             throws IOException,     {,        this(directory, preserveNodes);,     },     ,     /**,      * given a POI POIFSFileSystem object, and a specific directory,      *  within it, read in its Workbook and populate the high and,      *  low level models.  If you're reading in a workbook...start here.,      *,      * @param directory the POI filesystem directory to process from,      * @param preserveNodes whether to preseve other nodes, such as,      *        macros.  This takes more memory, so only say yes if you,      *        need to. If set, will store all of the POIFSFileSystem,      *        in memory,      * @see org.apache.poi.poifs.filesystem.POIFSFileSystem,      * @exception IOException if the stream cannot be read,      */,     public HSSFWorkbook(DirectoryNode directory, boolean preserveNodes),             throws IOException,     {,         super(directory);,         String workbookName = getWorkbookDirEntryName(directory);, ,         this.preserveNodes = preserveNodes;, ,         // If we're not preserving nodes, don't track the,         //  POIFS any more,         if(! preserveNodes) {,            this.directory = null;,         }, ,         _sheets = new ArrayList<HSSFSheet>(INITIAL_CAPACITY);,         names  = new ArrayList<HSSFName>(INITIAL_CAPACITY);, ,         // Grab the data from the workbook stream, however,         //  it happens to be spelled.,         InputStream stream = directory.createDocumentInputStream(workbookName);, ,         List<Record> records = RecordFactory.createRecords(stream);, ,         workbook = InternalWorkbook.createWorkbook(records);,         setPropertiesFromWorkbook(workbook);,         int recOffset = workbook.getNumRecords();,         int sheetNum = 0;, ,         // convert all LabelRecord records to LabelSSTRecord,         convertLabelRecords(records, recOffset);,         RecordStream rs = new RecordStream(records, recOffset);,         while (rs.hasNext()) {,             InternalSheet sheet = InternalSheet.createSheet(rs);,             _sheets.add(new HSSFSheet(this, sheet));,         }, ,         for (int i = 0 ; i < workbook.getNumNames() ; ++i){,             NameRecord nameRecord = workbook.getNameRecord(i);,             HSSFName name = new HSSFName(this, nameRecord, workbook.getNameCommentRecord(nameRecord));,             names.add(name);,         },     }, ,      public HSSFWorkbook(InputStream s) throws IOException {,          this(s,true);,      }, ,     /**,      * Companion to HSSFWorkbook(POIFSFileSystem), this constructs the POI filesystem around your,      * inputstream.,      *,      * @param s  the POI filesystem that contains the Workbook stream.,      * @param preserveNodes whether to preseve other nodes, such as,      *        macros.  This takes more memory, so only say yes if you,      *        need to.,      * @see org.apache.poi.poifs.filesystem.POIFSFileSystem,      * @see #HSSFWorkbook(POIFSFileSystem),      * @exception IOException if the stream cannot be read,      */, ,     public HSSFWorkbook(InputStream s, boolean preserveNodes),             throws IOException,     {,         this(new POIFSFileSystem(s), preserveNodes);,     }, ,     /**,      * used internally to set the workbook properties.,      */, ,     private void setPropertiesFromWorkbook(InternalWorkbook book),     {,         this.workbook = book;, ,         // none currently,     }, ,     /**,       * This is basically a kludge to deal with the now obsolete Label records.  If,       * you have to read in a sheet that contains Label records, be aware that the rest,       * of the API doesn't deal with them, the low level structure only provides read-only,       * semi-immutable structures (the sets are there for interface conformance with NO,       * impelmentation).  In short, you need to call this function passing it a reference,       * to the Workbook object.  All labels will be converted to LabelSST records and their,       * contained strings will be written to the Shared String tabel (SSTRecord) within,       * the Workbook.,       *,       * @param records a collection of sheet's records.,       * @param offset the offset to search at ,       * @see org.apache.poi.hssf.record.LabelRecord,       * @see org.apache.poi.hssf.record.LabelSSTRecord,       * @see org.apache.poi.hssf.record.SSTRecord,       */, ,      private void convertLabelRecords(List records, int offset),      {,          if (log.check( POILogger.DEBUG )),              log.log(POILogger.DEBUG, "convertLabelRecords called");,          for (int k = offset; k < records.size(); k++),          {,              Record rec = ( Record ) records.get(k);, ,              if (rec.getSid() == LabelRecord.sid),              {,                  LabelRecord oldrec = ( LabelRecord ) rec;, ,                  records.remove(k);,                  LabelSSTRecord newrec   = new LabelSSTRecord();,                  int            stringid =,                      workbook.addSSTString(new UnicodeString(oldrec.getValue()));, ,                  newrec.setRow(oldrec.getRow());,                  newrec.setColumn(oldrec.getColumn());,                  newrec.setXFIndex(oldrec.getXFIndex());,                  newrec.setSSTIndex(stringid);,                        records.add(k, newrec);,              },          },          if (log.check( POILogger.DEBUG )),              log.log(POILogger.DEBUG, "convertLabelRecords exit");,      }, ,     /**,      * Retrieves the current policy on what to do when,      *  getting missing or blank cells from a row.,      * The default is to return blank and null cells.,      *  {@link MissingCellPolicy},      */,     public MissingCellPolicy getMissingCellPolicy() {,         return missingCellPolicy;,     }, ,     /**,      * Sets the policy on what to do when,      *  getting missing or blank cells from a row.,      * This will then apply to all calls to,      *  {@link HSSFRow#getCell(int)}}. See,      *  {@link MissingCellPolicy}.,      * Note that this has no effect on any,      *  iterators, only on when fetching Cells,      *  by their column index.,      */,     public void setMissingCellPolicy(MissingCellPolicy missingCellPolicy) {,         this.missingCellPolicy = missingCellPolicy;,     }, ,     /**,      * sets the order of appearance for a given sheet.,      *,      * @param sheetname the name of the sheet to reorder,      * @param pos the position that we want to insert the sheet into (0 based),      */, ,     public void setSheetOrder(String sheetname, int pos ) {,         int oldSheetIndex = getSheetIndex(sheetname);,         _sheets.add(pos,_sheets.remove(oldSheetIndex));,         workbook.setSheetOrder(sheetname, pos);, ,         FormulaShifter shifter = FormulaShifter.createForSheetShift(oldSheetIndex, pos);,         for (HSSFSheet sheet : _sheets) {,             sheet.getSheet().updateFormulasAfterCellShift(shifter, /* not used */ -1 );,         }, ,         workbook.updateNamesAfterCellShift(shifter);, ,     }, ,     private void validateSheetIndex(int index) {,         int lastSheetIx = _sheets.size() - 1;,         if (index < 0 || index > lastSheetIx) {,             throw new IllegalArgumentException("Sheet index (",                     + index +") is out of range (0.." +    lastSheetIx + ")");,         },     }, ,     /**,      * Selects a single sheet. This may be different to,      * the 'active' sheet (which is the sheet with focus).,      */,     public void setSelectedTab(int index) {, ,         validateSheetIndex(index);,         int nSheets = _sheets.size();,         for (int i=0; i<nSheets; i++) {,                getSheetAt(i).setSelected(i == index);,         },         workbook.getWindowOne().setNumSelectedTabs((short)1);,     },     /**,      * deprecated May 2008,      * @deprecated use setSelectedTab(int),      */,     public void setSelectedTab(short index) {,         setSelectedTab((int)index);,     },     public void setSelectedTabs(int[] indexes) {, ,         for (int i = 0; i < indexes.length; i++) {,             validateSheetIndex(indexes[i]);,         },         int nSheets = _sheets.size();,         for (int i=0; i<nSheets; i++) {,             boolean bSelect = false;,             for (int j = 0; j < indexes.length; j++) {,                 if (indexes[j] == i) {,                     bSelect = true;,                     break;,                 }, ,             },                getSheetAt(i).setSelected(bSelect);,         },         workbook.getWindowOne().setNumSelectedTabs((short)indexes.length);,     },     /**,      * Convenience method to set the active sheet.  The active sheet is is the sheet,      * which is currently displayed when the workbook is viewed in Excel.,      * 'Selected' sheet(s) is a distinct concept.,      */,     public void setActiveSheet(int index) {, ,         validateSheetIndex(index);,         int nSheets = _sheets.size();,         for (int i=0; i<nSheets; i++) {,              getSheetAt(i).setActive(i == index);,         },         workbook.getWindowOne().setActiveSheetIndex(index);,     }, ,     /**,      * gets the tab whose data is actually seen when the sheet is opened.,      * This may be different from the "selected sheet" since excel seems to,      * allow you to show the data of one sheet when another is seen "selected",      * in the tabs (at the bottom).,      * @see org.apache.poi.hssf.usermodel.HSSFSheet#setSelected(boolean),      */,     public int getActiveSheetIndex() {,         return workbook.getWindowOne().getActiveSheetIndex();,     },     /**,      * deprecated May 2008,      * @deprecated - Misleading name - use getActiveSheetIndex(),      */,     public short getSelectedTab() {,         return (short) getActiveSheetIndex();,     }, , ,     /**,      * sets the first tab that is displayed in the list of tabs,      * in excel.,      * @param index,      */,     public void setFirstVisibleTab(int index) {,         workbook.getWindowOne().setFirstVisibleTab(index);,     },     /**,      * deprecated May 2008,      * @deprecated - Misleading name - use setFirstVisibleTab(),      */,     public void setDisplayedTab(short index) {,        setFirstVisibleTab(index);,     }, ,     /**,      * sets the first tab that is displayed in the list of tabs in excel.,      */,     public int getFirstVisibleTab() {,         return workbook.getWindowOne().getFirstVisibleTab();,     },     /**,      * deprecated May 2008,      * @deprecated - Misleading name - use getFirstVisibleTab(),      */,     public short getDisplayedTab() {,         return (short) getFirstVisibleTab();,     }, ,     /**,      * Set the sheet name.,      *,      * @param sheetIx number (0 based),      * @throws IllegalArgumentException if the name is null or invalid,      *  or workbook already contains a sheet with this name,      * @see #createSheet(String),      * @see org.apache.poi.ss.util.WorkbookUtil#createSafeSheetName(String nameProposal),      */,     public void setSheetName(int sheetIx, String name) {,         if (name == null) {,             throw new IllegalArgumentException("sheetName must not be null");,         }, ,         if (workbook.doesContainsSheetName(name, sheetIx)) {,             throw new IllegalArgumentException("The workbook already contains a sheet with this name");,         },         validateSheetIndex(sheetIx);,         workbook.setSheetName(sheetIx, name);,     }, ,     /**,      * @return Sheet name for the specified index,      */,     public String getSheetName(int sheetIndex) {,         validateSheetIndex(sheetIndex);,         return workbook.getSheetName(sheetIndex);,     }, ,     public boolean isHidden() {,         return workbook.getWindowOne().getHidden();,     }, ,     public void setHidden(boolean hiddenFlag) {,         workbook.getWindowOne().setHidden(hiddenFlag);,     }, ,     public boolean isSheetHidden(int sheetIx) {,         validateSheetIndex(sheetIx);,         return workbook.isSheetHidden(sheetIx);,     }, ,     public boolean isSheetVeryHidden(int sheetIx) {,         validateSheetIndex(sheetIx);,         return workbook.isSheetVeryHidden(sheetIx);,     }, , ,     public void setSheetHidden(int sheetIx, boolean hidden) {,         validateSheetIndex(sheetIx);,         workbook.setSheetHidden(sheetIx, hidden);,     }, ,     public void setSheetHidden(int sheetIx, int hidden) {,         validateSheetIndex(sheetIx);,         WorkbookUtil.validateSheetState(hidden);,         workbook.setSheetHidden(sheetIx, hidden);,     }, ,     /** Returns the index of the sheet by his name,      * @param name the sheet name,      * @return index of the sheet (0 based),      */,     public int getSheetIndex(String name){,         return workbook.getSheetIndex(name);,     }, ,     /** Returns the index of the given sheet,      * @param sheet the sheet to look up,      * @return index of the sheet (0 based). <tt>-1</tt> if not found,      */,     public int getSheetIndex(org.apache.poi.ss.usermodel.Sheet sheet) {,         for(int i=0; i<_sheets.size(); i++) {,             if(_sheets.get(i) == sheet) {,                 return i;,             },         },         return -1;,     }, ,     /**,      * Returns the external sheet index of the sheet,      *  with the given internal index, creating one,      *  if needed.,      * Used by some of the more obscure formula and,      *  named range things.,      * @deprecated for POI internal use only (formula parsing).  This method is likely to,      * be removed in future versions of POI.,      */,     public int getExternalSheetIndex(int internalSheetIndex) {,         return workbook.checkExternSheet(internalSheetIndex);,     },     /**,      * @deprecated for POI internal use only (formula rendering).  This method is likely to,      * be removed in future versions of POI.,      */,     public String findSheetNameFromExternSheet(int externSheetIndex){,         // TODO - don't expose internal ugliness like externSheet indexes to the user model API,         return workbook.findSheetNameFromExternSheet(externSheetIndex);,     },     /**,      * @deprecated for POI internal use only (formula rendering).  This method is likely to,      * be removed in future versions of POI.,      *,      * @param refIndex Index to REF entry in EXTERNSHEET record in the Link Table,      * @param definedNameIndex zero-based to DEFINEDNAME or EXTERNALNAME record,      * @return the string representation of the defined or external name,      */,     public String resolveNameXText(int refIndex, int definedNameIndex) {,         // TODO - make this less cryptic / move elsewhere,         return workbook.resolveNameXText(refIndex, definedNameIndex);,     }, , , , ,     /**,      * create an HSSFSheet for this HSSFWorkbook, adds it to the sheets and returns,      * the high level representation.  Use this to create new sheets.,      *,      * @return HSSFSheet representing the new sheet.,      */, ,     public HSSFSheet createSheet(),     {,         HSSFSheet sheet = new HSSFSheet(this);, ,         _sheets.add(sheet);,         workbook.setSheetName(_sheets.size() - 1, "Sheet" + (_sheets.size() - 1));,         boolean isOnlySheet = _sheets.size() == 1;,         sheet.setSelected(isOnlySheet);,         sheet.setActive(isOnlySheet);,         return sheet;,     }, ,     /**,      * create an HSSFSheet from an existing sheet in the HSSFWorkbook.,      *,      * @return HSSFSheet representing the cloned sheet.,      */, ,     public HSSFSheet cloneSheet(int sheetIndex) {,         validateSheetIndex(sheetIndex);,         HSSFSheet srcSheet = _sheets.get(sheetIndex);,         String srcName = workbook.getSheetName(sheetIndex);,         HSSFSheet clonedSheet = srcSheet.cloneSheet(this);,         clonedSheet.setSelected(false);,         clonedSheet.setActive(false);, ,         String name = getUniqueSheetName(srcName);,         int newSheetIndex = _sheets.size();,         _sheets.add(clonedSheet);,         workbook.setSheetName(newSheetIndex, name);, ,         // Check this sheet has an autofilter, (which has a built-in NameRecord at workbook level),         int filterDbNameIndex = findExistingBuiltinNameRecordIdx(sheetIndex, NameRecord.BUILTIN_FILTER_DB);,         if (filterDbNameIndex != -1) {,             NameRecord newNameRecord = workbook.cloneFilter(filterDbNameIndex, newSheetIndex);,             HSSFName newName = new HSSFName(this, newNameRecord);,             names.add(newName);,         },         // TODO - maybe same logic required for other/all built-in name records,         workbook.cloneDrawings(clonedSheet.getSheet());, ,         return clonedSheet;,     }, ,     private String getUniqueSheetName(String srcName) {,         int uniqueIndex = 2;,         String baseName = srcName;,         int bracketPos = srcName.lastIndexOf('(');,         if (bracketPos > 0 && srcName.endsWith(")")) {,             String suffix = srcName.substring(bracketPos + 1, srcName.length() - ")".length());,             try {,                 uniqueIndex = Integer.parseInt(suffix.trim());,                 uniqueIndex++;,                 baseName=srcName.substring(0, bracketPos).trim();,             } catch (NumberFormatException e) {,                 // contents of brackets not numeric,             },         },         while (true) {,             // Try and find the next sheet name that is unique,             String index = Integer.toString(uniqueIndex++);,             String name;,             if (baseName.length() + index.length() + 2 < 31) {,                 name = baseName + " (" + index + ")";,             } else {,                 name = baseName.substring(0, 31 - index.length() - 2) + "(" + index + ")";,             }, ,             //If the sheet name is unique, then set it otherwise move on to the next number.,             if (workbook.getSheetIndex(name) == -1) {,               return name;,             },         },     }, ,     /**,      * Create a new sheet for this Workbook and return the high level representation.,      * Use this to create new sheets.,      *,      * <p>,      *     Note that Excel allows sheet names up to 31 chars in length but other applications,      *     (such as OpenOffice) allow more. Some versions of Excel crash with names longer than 31 chars,,      *     others - truncate such names to 31 character.,      * </p>,      * <p>,      *     POI's SpreadsheetAPI silently truncates the input argument to 31 characters.,      *     Example:,      *,      *     <pre><code>,      *     Sheet sheet = workbook.createSheet("My very long sheet name which is longer than 31 chars"); // will be truncated,      *     assert 31 == sheet.getSheetName().length();,      *     assert "My very long sheet name which i" == sheet.getSheetName();,      *     </code></pre>,      * </p>,      *,      * Except the 31-character constraint, Excel applies some other rules:,      * <p>,      * Sheet name MUST be unique in the workbook and MUST NOT contain the any of the following characters:,      * <ul>,      * <li> 0x0000 </li>,      * <li> 0x0003 </li>,      * <li> colon (:) </li>,      * <li> backslash (\) </li>,      * <li> asterisk (*) </li>,      * <li> question mark (?) </li>,      * <li> forward slash (/) </li>,      * <li> opening square bracket ([) </li>,      * <li> closing square bracket (]) </li>,      * </ul>,      * The string MUST NOT begin or end with the single quote (') character.,      * </p>,      *,      * @param sheetname  sheetname to set for the sheet.,      * @return Sheet representing the new sheet.,      * @throws IllegalArgumentException if the name is null or invalid,      *  or workbook already contains a sheet with this name,      * @see org.apache.poi.ss.util.WorkbookUtil#createSafeSheetName(String nameProposal),      */,     public HSSFSheet createSheet(String sheetname),     {,         if (sheetname == null) {,             throw new IllegalArgumentException("sheetName must not be null");,         }, ,         if (workbook.doesContainsSheetName( sheetname, _sheets.size() )),             throw new IllegalArgumentException( "The workbook already contains a sheet of this name" );, ,         HSSFSheet sheet = new HSSFSheet(this);, ,         workbook.setSheetName(_sheets.size(), sheetname);,         _sheets.add(sheet);,         boolean isOnlySheet = _sheets.size() == 1;,         sheet.setSelected(isOnlySheet);,         sheet.setActive(isOnlySheet);,         return sheet;,     }, ,     /**,      * get the number of spreadsheets in the workbook (this will be three after serialization),      * @return number of sheets,      */, ,     public int getNumberOfSheets(),     {,         return _sheets.size();,     }, ,     public int getSheetIndexFromExternSheetIndex(int externSheetNumber) {,         return workbook.getSheetIndexFromExternSheetIndex(externSheetNumber);,     }, ,     private HSSFSheet[] getSheets() {,         HSSFSheet[] result = new HSSFSheet[_sheets.size()];,         _sheets.toArray(result);,         return result;,     }, ,     /**,      * Get the HSSFSheet object at the given index.,      * @param index of the sheet number (0-based physical & logical),      * @return HSSFSheet at the provided index,      */, ,     public HSSFSheet getSheetAt(int index),     {,         validateSheetIndex(index);,         return (HSSFSheet) _sheets.get(index);,     }, ,     /**,      * Get sheet with the given name (case insensitive match),      * @param name of the sheet,      * @return HSSFSheet with the name provided or <code>null</code> if it does not exist,      */, ,     public HSSFSheet getSheet(String name),     {,         HSSFSheet retval = null;, ,         for (int k = 0; k < _sheets.size(); k++),         {,             String sheetname = workbook.getSheetName(k);, ,             if (sheetname.equalsIgnoreCase(name)),             {,                 retval = (HSSFSheet) _sheets.get(k);,             },         },         return retval;,     }, ,     /**,      * Removes sheet at the given index.<p/>,      *,      * Care must be taken if the removed sheet is the currently active or only selected sheet in,      * the workbook. There are a few situations when Excel must have a selection and/or active,      * sheet. (For example when printing - see Bug 40414).<br/>,      *,      * This method makes sure that if the removed sheet was active, another sheet will become,      * active in its place.  Furthermore, if the removed sheet was the only selected sheet, another,      * sheet will become selected.  The newly active/selected sheet will have the same index, or,      * one less if the removed sheet was the last in the workbook.,      *,      * @param index of the sheet  (0-based),      */,     public void removeSheetAt(int index) {,         validateSheetIndex(index);,         boolean wasActive = getSheetAt(index).isActive();,         boolean wasSelected = getSheetAt(index).isSelected();, ,         _sheets.remove(index);,         workbook.removeSheet(index);, ,         // set the remaining active/selected sheet,         int nSheets = _sheets.size();,         if (nSheets < 1) {,             // nothing more to do if there are no sheets left,             return;,         },         // the index of the closest remaining sheet to the one just deleted,         int newSheetIndex = index;,         if (newSheetIndex >= nSheets) {,             newSheetIndex = nSheets-1;,         },         if (wasActive) {,             setActiveSheet(newSheetIndex);,         }, ,         if (wasSelected) {,             boolean someOtherSheetIsStillSelected = false;,             for (int i =0; i < nSheets; i++) {,                 if (getSheetAt(i).isSelected()) {,                     someOtherSheetIsStillSelected = true;,                     break;,                 },             },             if (!someOtherSheetIsStillSelected) {,                 setSelectedTab(newSheetIndex);,             },         },     }, ,     /**,      * determine whether the Excel GUI will backup the workbook when saving.,      *,      * @param backupValue   true to indicate a backup will be performed.,      */, ,     public void setBackupFlag(boolean backupValue),     {,         BackupRecord backupRecord = workbook.getBackupRecord();, ,         backupRecord.setBackup(backupValue ? (short) 1,                 : (short) 0);,     }, ,     /**,      * determine whether the Excel GUI will backup the workbook when saving.,      *,      * @return the current setting for backups.,      */, ,     public boolean getBackupFlag(),     {,         BackupRecord backupRecord = workbook.getBackupRecord();, ,         return (backupRecord.getBackup() == 0) ? false,                 : true;,     }, ,     /**,      * Sets the repeating rows and columns for a sheet (as found in,      * 2003:File->PageSetup->Sheet, 2007:Page Layout->Print Titles).,      *   This is function is included in the workbook,      * because it creates/modifies name records which are stored at the,      * workbook level.,      * <p>,      * To set just repeating columns:,      * <pre>,      *  workbook.setRepeatingRowsAndColumns(0,0,1,-1-1);,      * </pre>,      * To set just repeating rows:,      * <pre>,      *  workbook.setRepeatingRowsAndColumns(0,-1,-1,0,4);,      * </pre>,      * To remove all repeating rows and columns for a sheet.,      * <pre>,      *  workbook.setRepeatingRowsAndColumns(0,-1,-1,-1,-1);,      * </pre>,      *,      * @param sheetIndex    0 based index to sheet.,      * @param startColumn   0 based start of repeating columns.,      * @param endColumn     0 based end of repeating columns.,      * @param startRow      0 based start of repeating rows.,      * @param endRow        0 based end of repeating rows.,      */,     public void setRepeatingRowsAndColumns(int sheetIndex,,                                            int startColumn, int endColumn,,                                            int startRow, int endRow),     {,         // Check arguments,         if (startColumn == -1 && endColumn != -1) throw new IllegalArgumentException("Invalid column range specification");,         if (startRow == -1 && endRow != -1) throw new IllegalArgumentException("Invalid row range specification");,         if (startColumn < -1 || startColumn >= MAX_COLUMN) throw new IllegalArgumentException("Invalid column range specification");,         if (endColumn < -1 || endColumn >= MAX_COLUMN) throw new IllegalArgumentException("Invalid column range specification");,         if (startRow < -1 || startRow > MAX_ROW) throw new IllegalArgumentException("Invalid row range specification");,         if (endRow < -1 || endRow > MAX_ROW) throw new IllegalArgumentException("Invalid row range specification");,         if (startColumn > endColumn) throw new IllegalArgumentException("Invalid column range specification");,         if (startRow > endRow) throw new IllegalArgumentException("Invalid row range specification");, ,         HSSFSheet sheet = getSheetAt(sheetIndex);,         short externSheetIndex = getWorkbook().checkExternSheet(sheetIndex);, ,         boolean settingRowAndColumn =,                 startColumn != -1 && endColumn != -1 && startRow != -1 && endRow != -1;,         boolean removingRange =,                 startColumn == -1 && endColumn == -1 && startRow == -1 && endRow == -1;, ,         int rowColHeaderNameIndex = findExistingBuiltinNameRecordIdx(sheetIndex, NameRecord.BUILTIN_PRINT_TITLE);,         if (removingRange) {,             if (rowColHeaderNameIndex >= 0) {,                 workbook.removeName(rowColHeaderNameIndex);,             },             return;,         },         boolean isNewRecord;,         NameRecord nameRecord;,         if (rowColHeaderNameIndex < 0) {,             //does a lot of the house keeping for builtin records, like setting lengths to zero etc,             nameRecord = workbook.createBuiltInName(NameRecord.BUILTIN_PRINT_TITLE, sheetIndex+1);,             isNewRecord = true;,         } else {,             nameRecord = workbook.getNameRecord(rowColHeaderNameIndex);,             isNewRecord = false;,         }, ,         List temp = new ArrayList();, ,         if (settingRowAndColumn) {,             final int exprsSize = 2 * 11 + 1; // 2 * Area3DPtg.SIZE + UnionPtg.SIZE,             temp.add(new MemFuncPtg(exprsSize));,         },         if (startColumn >= 0) {,             Area3DPtg colArea = new Area3DPtg(0, MAX_ROW, startColumn, endColumn,,                     false, false, false, false, externSheetIndex);,             temp.add(colArea);,         },         if (startRow >= 0) {,             Area3DPtg rowArea = new Area3DPtg(startRow, endRow, 0, MAX_COLUMN,,                     false, false, false, false, externSheetIndex);,             temp.add(rowArea);,         },         if (settingRowAndColumn) {,             temp.add(UnionPtg.instance);,         },         Ptg[] ptgs = new Ptg[temp.size()];,         temp.toArray(ptgs);,         nameRecord.setNameDefinition(ptgs);, ,         if (isNewRecord),         {,             HSSFName newName = new HSSFName(this, nameRecord, nameRecord.isBuiltInName() ? null : workbook.getNameCommentRecord(nameRecord));,             names.add(newName);,         }, ,         HSSFPrintSetup printSetup = sheet.getPrintSetup();,         printSetup.setValidSettings(false);, ,         sheet.setActive(true);,     }, , ,     private int findExistingBuiltinNameRecordIdx(int sheetIndex, byte builtinCode) {,         for(int defNameIndex =0; defNameIndex<names.size(); defNameIndex++) {,             NameRecord r = workbook.getNameRecord(defNameIndex);,             if (r == null) {,                 throw new RuntimeException("Unable to find all defined names to iterate over");,             },             if (!r.isBuiltInName() || r.getBuiltInName() != builtinCode) {,                 continue;,             },             if (r.getSheetNumber() -1 == sheetIndex) {,                 return defNameIndex;,             },         },         return -1;,     }, ,     /**,      * create a new Font and add it to the workbook's font table,      * @return new font object,      */, ,     public HSSFFont createFont(),     {,         FontRecord font = workbook.createNewFont();,         short fontindex = (short) (getNumberOfFonts() - 1);, ,         if (fontindex > 3),         {,             fontindex++;   // THERE IS NO FOUR!!,         },         if(fontindex == Short.MAX_VALUE){,             throw new IllegalArgumentException("Maximum number of fonts was exceeded");,         }, ,         // Ask getFontAt() to build it for us,,         //  so it gets properly cached,         return getFontAt(fontindex);,     }, ,     /**,      * Finds a font that matches the one with the supplied attributes,      */,     public HSSFFont findFont(short boldWeight, short color, short fontHeight,,                              String name, boolean italic, boolean strikeout,,                              short typeOffset, byte underline),     {,         for (short i=0; i<=getNumberOfFonts(); i++) {,             // Remember - there is no 4!,             if(i == 4) continue;, ,             HSSFFont hssfFont = getFontAt(i);,             if (hssfFont.getBoldweight() == boldWeight,                     && hssfFont.getColor() == color,                     && hssfFont.getFontHeight() == fontHeight,                     && hssfFont.getFontName().equals(name),                     && hssfFont.getItalic() == italic,                     && hssfFont.getStrikeout() == strikeout,                     && hssfFont.getTypeOffset() == typeOffset,                     && hssfFont.getUnderline() == underline),             {,                 return hssfFont;,             },         }, ,         return null;,     }, ,     /**,      * get the number of fonts in the font table,      * @return number of fonts,      */, ,     public short getNumberOfFonts(),     {,         return (short) workbook.getNumberOfFontRecords();,     }, ,     /**,      * Get the font at the given index number,      * @param idx  index number,      * @return HSSFFont at the index,      */,     public HSSFFont getFontAt(short idx) {,         if(fonts == null) fonts = new Hashtable();, ,         // So we don't confuse users, give them back,         //  the same object every time, but create,         //  them lazily,         Short sIdx = Short.valueOf(idx);,         if(fonts.containsKey(sIdx)) {,             return (HSSFFont)fonts.get(sIdx);,         }, ,         FontRecord font = workbook.getFontRecordAt(idx);,         HSSFFont retval = new HSSFFont(idx, font);,         fonts.put(sIdx, retval);, ,         return retval;,     }, ,     /**,      * Reset the fonts cache, causing all new calls,      *  to getFontAt() to create new objects.,      * Should only be called after deleting fonts,,      *  and that's not something you should normally do,      */,     protected void resetFontCache() {,         fonts = new Hashtable();,     }, ,     /**,      * Create a new Cell style and add it to the workbook's style table.,      * You can define up to 4000 unique styles in a .xls workbook.,      *,      * @return the new Cell Style object,      * @throws IllegalStateException if the maximum number of cell styles exceeded the limit,      */, ,     public HSSFCellStyle createCellStyle(),     {,         if(workbook.getNumExFormats() == MAX_STYLES) {,             throw new IllegalStateException("The maximum number of cell styles was exceeded. " +,                     "You can define up to 4000 styles in a .xls workbook");,         },         ExtendedFormatRecord xfr = workbook.createCellXF();,         short index = (short) (getNumCellStyles() - 1);,         HSSFCellStyle style = new HSSFCellStyle(index, xfr, this);, ,         return style;,     }, ,     /**,      * get the number of styles the workbook contains,      * @return count of cell styles,      */, ,     public short getNumCellStyles(),     {,         return (short) workbook.getNumExFormats();,     }, ,     /**,      * get the cell style object at the given index,      * @param idx  index within the set of styles,      * @return HSSFCellStyle object at the index,      */,     public HSSFCellStyle getCellStyleAt(short idx),     {,         ExtendedFormatRecord xfr = workbook.getExFormatAt(idx);,         HSSFCellStyle style = new HSSFCellStyle(idx, xfr, this);, ,         return style;,     }, ,     /**,      * Method write - write out this workbook to an Outputstream.  Constructs,      * a new POI POIFSFileSystem, passes in the workbook binary representation  and,      * writes it out.,      *,      * @param stream - the java OutputStream you wish to write the XLS to,      *,      * @exception IOException if anything can't be written.,      * @see org.apache.poi.poifs.filesystem.POIFSFileSystem,      */, ,     public void write(OutputStream stream),             throws IOException,     {,         byte[] bytes = getBytes();,         POIFSFileSystem fs = new POIFSFileSystem();, ,         // For tracking what we've written out, used if we're,         //  going to be preserving nodes,         List<String> excepts = new ArrayList<String>(1);, ,         // Write out the Workbook stream,         fs.createDocument(new ByteArrayInputStream(bytes), "Workbook");, ,         // Write out our HPFS properties, if we have them,         writeProperties(fs, excepts);, ,         if (preserveNodes) {,             // Don't write out the old Workbook, we'll be doing our new one,             excepts.add("Workbook");,             // If the file had WORKBOOK instead of Workbook, we'll write it,             //  out correctly shortly, so don't include the old one,             excepts.add("WORKBOOK");, ,             // Copy over all the other nodes to our new poifs,             copyNodes(this.directory, fs.getRoot(), excepts);, ,             // YK: preserve StorageClsid, it is important for embedded workbooks,,             // see Bugzilla 47920,             fs.getRoot().setStorageClsid(this.directory.getStorageClsid());,         },         fs.writeFilesystem(stream);,     }, ,     /**,      * Totals the sizes of all sheet records and eventually serializes them,      */,     private static final class SheetRecordCollector implements RecordVisitor {, ,         private List _list;,         private int _totalSize;, ,         public SheetRecordCollector() {,             _totalSize = 0;,             _list = new ArrayList(128);,         },         public int getTotalSize() {,             return _totalSize;,         },         public void visitRecord(Record r) {,             _list.add(r);,             _totalSize+=r.getRecordSize();,         },         public int serialize(int offset, byte[] data) {,             int result = 0;,             int nRecs = _list.size();,             for(int i=0; i<nRecs; i++) {,                 Record rec = (Record)_list.get(i);,                 result += rec.serialize(offset + result, data);,             },             return result;,         },     }, , ,     /**,      * Method getBytes - get the bytes of just the HSSF portions of the XLS file.,      * Use this to construct a POI POIFSFileSystem yourself.,      *,      *,      * @return byte[] array containing the binary representation of this workbook and all contained,      *         sheets, rows, cells, etc.,      */,     public byte[] getBytes() {,         if (log.check( POILogger.DEBUG )) {,             log.log(DEBUG, "HSSFWorkbook.getBytes()");,         }, ,         HSSFSheet[] sheets = getSheets();,         int nSheets = sheets.length;, ,         // before getting the workbook size we must tell the sheets that,         // serialization is about to occur.,         for (int i = 0; i < nSheets; i++) {,             sheets[i].getSheet().preSerialize();,         }, ,         int totalsize = workbook.getSize();, ,         // pre-calculate all the sheet sizes and set BOF indexes,         SheetRecordCollector[] srCollectors = new SheetRecordCollector[nSheets];,         for (int k = 0; k < nSheets; k++) {,             workbook.setSheetBof(k, totalsize);,             SheetRecordCollector src = new SheetRecordCollector();,             sheets[k].getSheet().visitContainedRecords(src, totalsize);,             totalsize += src.getTotalSize();,             srCollectors[k] = src;,         }, ,         byte[] retval = new byte[totalsize];,         int pos = workbook.serialize(0, retval);, ,         for (int k = 0; k < nSheets; k++) {,             SheetRecordCollector src = srCollectors[k];,             int serializedSize = src.serialize(pos, retval);,             if (serializedSize != src.getTotalSize()) {,                 // Wrong offset values have been passed in the call to setSheetBof() above.,                 // For books with more than one sheet, this discrepancy would cause excel,                 // to report errors and loose data while reading the workbook,                 throw new IllegalStateException("Actual serialized sheet size (" + serializedSize,                         + ") differs from pre-calculated size (" + src.getTotalSize(),                         + ") for sheet (" + k + ")");,                 // TODO - add similar sanity check to ensure that Sheet.serializeIndexRecord() does not write mis-aligned offsets either,             },             pos += serializedSize;,         },         return retval;,     }, ,     /** @deprecated Do not call this method from your applications. Use the methods,      *  available in the HSSFRow to add string HSSFCells,      */,     public int addSSTString(String string),     {,         return workbook.addSSTString(new UnicodeString(string));,     }, ,     /** @deprecated Do not call this method from your applications. Use the methods,      *  available in the HSSFRow to get string HSSFCells,      */,     public String getSSTString(int index),     {,         return workbook.getSSTString(index).getString();,     }, ,     InternalWorkbook getWorkbook() {,         return workbook;,     }, ,     public int getNumberOfNames(){,         int result = names.size();,         return result;,     }, ,     public HSSFName getName(String name) {,         int nameIndex = getNameIndex(name);,         if (nameIndex < 0) {,             return null;,         },         return (HSSFName) names.get(nameIndex);,     }, ,     public HSSFName getNameAt(int nameIndex) {,         int nNames = names.size();,         if (nNames < 1) {,             throw new IllegalStateException("There are no defined names in this workbook");,         },         if (nameIndex < 0 || nameIndex > nNames) {,             throw new IllegalArgumentException("Specified name index " + nameIndex,                     + " is outside the allowable range (0.." + (nNames-1) + ").");,         },         return (HSSFName) names.get(nameIndex);,     }, ,     public NameRecord getNameRecord(int nameIndex) {,         return getWorkbook().getNameRecord(nameIndex);,     }, ,     /** gets the named range name,      * @param index the named range index (0 based),      * @return named range name,      */,     public String getNameName(int index){,         String result = getNameAt(index).getNameName();, ,         return result;,     }, ,     /**,      * Sets the printarea for the sheet provided,      * <p>,      * i.e. Reference = $A$1:$B$2,      * @param sheetIndex Zero-based sheet index (0 Represents the first sheet to keep consistent with java),      * @param reference Valid name Reference for the Print Area,      */,     public void setPrintArea(int sheetIndex, String reference),     {,         NameRecord name = workbook.getSpecificBuiltinRecord(NameRecord.BUILTIN_PRINT_AREA, sheetIndex+1);, , ,         if (name == null) {,             name = workbook.createBuiltInName(NameRecord.BUILTIN_PRINT_AREA, sheetIndex+1);,             // adding one here because 0 indicates a global named region; doesn't make sense for print areas,         },         String[] parts = COMMA_PATTERN.split(reference);,         StringBuffer sb = new StringBuffer(32);,         for (int i = 0; i < parts.length; i++) {,             if(i>0) {,                 sb.append(",");,             },             SheetNameFormatter.appendFormat(sb, getSheetName(sheetIndex));,             sb.append("!");,             sb.append(parts[i]);,         },         name.setNameDefinition(HSSFFormulaParser.parse(sb.toString(), this, FormulaType.NAMEDRANGE, sheetIndex));,     }, ,     /**,      * For the Convenience of Java Programmers maintaining pointers.,      * @see #setPrintArea(int, String),      * @param sheetIndex Zero-based sheet index (0 = First Sheet),      * @param startColumn Column to begin printarea,      * @param endColumn Column to end the printarea,      * @param startRow Row to begin the printarea,      * @param endRow Row to end the printarea,      */,     public void setPrintArea(int sheetIndex, int startColumn, int endColumn,,                               int startRow, int endRow) {, ,         //using absolute references because they don't get copied and pasted anyway,         CellReference cell = new CellReference(startRow, startColumn, true, true);,         String reference = cell.formatAsString();, ,         cell = new CellReference(endRow, endColumn, true, true);,         reference = reference+":"+cell.formatAsString();, ,         setPrintArea(sheetIndex, reference);,     }, , ,     /**,      * Retrieves the reference for the printarea of the specified sheet, the sheet name is appended to the reference even if it was not specified.,      * @param sheetIndex Zero-based sheet index (0 Represents the first sheet to keep consistent with java),      * @return String Null if no print area has been defined,      */,     public String getPrintArea(int sheetIndex) {,         NameRecord name = workbook.getSpecificBuiltinRecord(NameRecord.BUILTIN_PRINT_AREA, sheetIndex+1);,         //adding one here because 0 indicates a global named region; doesn't make sense for print areas,         if (name == null) {,             return null;,         }, ,         return HSSFFormulaParser.toFormulaString(this, name.getNameDefinition());,     }, ,     /**,      * Delete the printarea for the sheet specified,      * @param sheetIndex Zero-based sheet index (0 = First Sheet),      */,     public void removePrintArea(int sheetIndex) {,         getWorkbook().removeBuiltinRecord(NameRecord.BUILTIN_PRINT_AREA, sheetIndex+1);,     }, ,     /** creates a new named range and add it to the model,      * @return named range high level,      */,     public HSSFName createName(){,         NameRecord nameRecord = workbook.createName();, ,         HSSFName newName = new HSSFName(this, nameRecord);, ,         names.add(newName);, ,         return newName;,     }, ,     public int getNameIndex(String name) {, ,         for (int k = 0; k < names.size(); k++) {,             String nameName = getNameName(k);, ,             if (nameName.equalsIgnoreCase(name)) {,                 return k;,             },         },         return -1;,     }, , ,     public void removeName(int index){,         names.remove(index);,         workbook.removeName(index);,     }, ,     /**,      * Returns the instance of HSSFDataFormat for this workbook.,      * @return the HSSFDataFormat object,      * @see org.apache.poi.hssf.record.FormatRecord,      * @see org.apache.poi.hssf.record.Record,      */,     public HSSFDataFormat createDataFormat() {,     if (formatter == null),         formatter = new HSSFDataFormat(workbook);,     return formatter;,     }, , ,     public void removeName(String name) {,         int index = getNameIndex(name);, ,         removeName(index);,     }, ,     public HSSFPalette getCustomPalette(),     {,         return new HSSFPalette(workbook.getCustomPalette());,     }, ,     /** Test only. Do not use */,     public void insertChartRecord(),     {,         int loc = workbook.findFirstRecordLocBySid(SSTRecord.sid);,         byte[] data = {,            (byte)0x0F, (byte)0x00, (byte)0x00, (byte)0xF0, (byte)0x52,,            (byte)0x00, (byte)0x00, (byte)0x00, (byte)0x00, (byte)0x00,,            (byte)0x06, (byte)0xF0, (byte)0x18, (byte)0x00, (byte)0x00,,            (byte)0x00, (byte)0x01, (byte)0x08, (byte)0x00, (byte)0x00,,            (byte)0x02, (byte)0x00, (byte)0x00, (byte)0x00, (byte)0x02,,            (byte)0x00, (byte)0x00, (byte)0x00, (byte)0x01, (byte)0x00,,            (byte)0x00, (byte)0x00, (byte)0x01, (byte)0x00, (byte)0x00,,            (byte)0x00, (byte)0x03, (byte)0x00, (byte)0x00, (byte)0x00,,            (byte)0x33, (byte)0x00, (byte)0x0B, (byte)0xF0, (byte)0x12,,            (byte)0x00, (byte)0x00, (byte)0x00, (byte)0xBF, (byte)0x00,,            (byte)0x08, (byte)0x00, (byte)0x08, (byte)0x00, (byte)0x81,,            (byte)0x01, (byte)0x09, (byte)0x00, (byte)0x00, (byte)0x08,,            (byte)0xC0, (byte)0x01, (byte)0x40, (byte)0x00, (byte)0x00,,            (byte)0x08, (byte)0x40, (byte)0x00, (byte)0x1E, (byte)0xF1,,            (byte)0x10, (byte)0x00, (byte)0x00, (byte)0x00, (byte)0x0D,,            (byte)0x00, (byte)0x00, (byte)0x08, (byte)0x0C, (byte)0x00,,            (byte)0x00, (byte)0x08, (byte)0x17, (byte)0x00, (byte)0x00,,            (byte)0x08, (byte)0xF7, (byte)0x00, (byte)0x00, (byte)0x10,,         };,         UnknownRecord r = new UnknownRecord((short)0x00EB, data);,         workbook.getRecords().add(loc, r);,     }, ,     /**,      * Spits out a list of all the drawing records in the workbook.,      */,     public void dumpDrawingGroupRecords(boolean fat),     {,         DrawingGroupRecord r = (DrawingGroupRecord) workbook.findFirstRecordBySid( DrawingGroupRecord.sid );,         r.decode();,         List escherRecords = r.getEscherRecords();,         PrintWriter w = new PrintWriter(System.out);,         for ( Iterator iterator = escherRecords.iterator(); iterator.hasNext(); ),         {,             EscherRecord escherRecord = (EscherRecord) iterator.next();,             if (fat),                 System.out.println(escherRecord.toString());,             else,                 escherRecord.display(w, 0);,         },         w.flush();,     }, ,     void initDrawings(){,         DrawingManager2 mgr = workbook.findDrawingGroup();,         if(mgr != null) {,             for(int i=0; i < getNumberOfSheets(); i++)  {,                 getSheetAt(i).getDrawingPatriarch();,             },         } else {,             workbook.createDrawingGroup();,         },     }, ,     /**,      * Adds a picture to the workbook.,      *,      * @param pictureData       The bytes of the picture,      * @param format            The format of the picture.  One of <code>PICTURE_TYPE_*</code>,      *,      * @return the index to this picture (1 based).,      */,     public int addPicture(byte[] pictureData, int format),     {,         initDrawings();,         ,         byte[] uid = DigestUtils.md5(pictureData);,         EscherBitmapBlip blipRecord = new EscherBitmapBlip();,         blipRecord.setRecordId( (short) ( EscherBitmapBlip.RECORD_ID_START + format ) );,         switch (format),         {,             case PICTURE_TYPE_EMF:,                 blipRecord.setOptions(HSSFPictureData.MSOBI_EMF);,                 break;,             case PICTURE_TYPE_WMF:,                 blipRecord.setOptions(HSSFPictureData.MSOBI_WMF);,                 break;,             case PICTURE_TYPE_PICT:,                 blipRecord.setOptions(HSSFPictureData.MSOBI_PICT);,                 break;,             case PICTURE_TYPE_PNG:,                 blipRecord.setOptions(HSSFPictureData.MSOBI_PNG);,                 break;,             case HSSFWorkbook.PICTURE_TYPE_JPEG:,                 blipRecord.setOptions(HSSFPictureData.MSOBI_JPEG);,                 break;,             case HSSFWorkbook.PICTURE_TYPE_DIB:,                 blipRecord.setOptions(HSSFPictureData.MSOBI_DIB);,                 break;,         }, ,         blipRecord.setUID( uid );,         blipRecord.setMarker( (byte) 0xFF );,         blipRecord.setPictureData( pictureData );, ,         EscherBSERecord r = new EscherBSERecord();,         r.setRecordId( EscherBSERecord.RECORD_ID );,         r.setOptions( (short) ( 0x0002 | ( format << 4 ) ) );,         r.setBlipTypeMacOS( (byte) format );,         r.setBlipTypeWin32( (byte) format );,         r.setUid( uid );,         r.setTag( (short) 0xFF );,         r.setSize( pictureData.length + 25 );,         r.setRef( 1 );,         r.setOffset( 0 );,         r.setBlipRecord( blipRecord );, ,         return workbook.addBSERecord( r );,     }, ,     /**,      * Gets all pictures from the Workbook.,      *,      * @return the list of pictures (a list of {@link HSSFPictureData} objects.),      */,     public List<HSSFPictureData> getAllPictures(),     {,         // The drawing group record always exists at the top level, so we won't need to do this recursively.,         List<HSSFPictureData> pictures = new ArrayList<HSSFPictureData>();,         Iterator<Record> recordIter = workbook.getRecords().iterator();,         while (recordIter.hasNext()),         {,             Record r = recordIter.next();,             if (r instanceof AbstractEscherHolderRecord),             {,                 ((AbstractEscherHolderRecord) r).decode();,                 List<EscherRecord> escherRecords = ((AbstractEscherHolderRecord) r).getEscherRecords();,                 searchForPictures(escherRecords, pictures);,             },         },         return pictures;,     }, ,     /**,      * Performs a recursive search for pictures in the given list of escher records.,      *,      * @param escherRecords the escher records.,      * @param pictures the list to populate with the pictures.,      */,     private void searchForPictures(List<EscherRecord> escherRecords, List<HSSFPictureData> pictures),     {,         for(EscherRecord escherRecord : escherRecords) {, ,             if (escherRecord instanceof EscherBSERecord),             {,                 EscherBlipRecord blip = ((EscherBSERecord) escherRecord).getBlipRecord();,                 if (blip != null),                 {,                     // TODO: Some kind of structure.,                     HSSFPictureData picture = new HSSFPictureData(blip);, 					pictures.add(picture);,                 },                 ,                 ,             }, ,             // Recursive call.,             searchForPictures(escherRecord.getChildRecords(), pictures);,         },         ,     }, ,     /**,      * Is the workbook protected with a password (not encrypted)?,      */,     public boolean isWriteProtected() {,         return this.workbook.isWriteProtected();,     }, ,     /**,      * protect a workbook with a password (not encypted, just sets writeprotect,      * flags and the password.,      * @param password to set,      */,     public void writeProtectWorkbook( String password, String username ) {,        this.workbook.writeProtectWorkbook(password, username);,     }, ,     /**,      * removes the write protect flag,      */,     public void unwriteProtectWorkbook() {,        this.workbook.unwriteProtectWorkbook();,     }, ,     /**,      * Gets all embedded OLE2 objects from the Workbook.,      *,      * @return the list of embedded objects (a list of {@link HSSFObjectData} objects.),      */,     public List<HSSFObjectData> getAllEmbeddedObjects(),     {,         List<HSSFObjectData> objects = new ArrayList<HSSFObjectData>();,         for (int i = 0; i < getNumberOfSheets(); i++),         {,             getAllEmbeddedObjects(getSheetAt(i).getSheet().getRecords(), objects);,         },         return objects;,     }, ,     /**,      * Gets all embedded OLE2 objects from the Workbook.,      *,      * @param records the list of records to search.,      * @param objects the list of embedded objects to populate.,      */,     private void getAllEmbeddedObjects(List<RecordBase> records, List<HSSFObjectData> objects),     {,        for (RecordBase obj : records) {,           if (obj instanceof ObjRecord),           {,              // TODO: More convenient way of determining if there is stored binary.,              // TODO: Link to the data stored in the other stream.,              Iterator<SubRecord> subRecordIter = ((ObjRecord) obj).getSubRecords().iterator();,              while (subRecordIter.hasNext()),              {,                 SubRecord sub = subRecordIter.next();,                 if (sub instanceof EmbeddedObjectRefSubRecord),                 {,                    objects.add(new HSSFObjectData((ObjRecord) obj, directory));,                 },              },           },        },     }, ,     public HSSFCreationHelper getCreationHelper() {,         return new HSSFCreationHelper(this);,     }, ,     /**,      *,      * Returns the locator of user-defined functions.,      * The default instance extends the built-in functions with the Analysis Tool Pack,      *,      * @return the locator of user-defined functions,      */,     /*package*/ UDFFinder getUDFFinder(){,         return _udfFinder;,     }, ,     /**,      * Register a new toolpack in this workbook.,      *,      * @param toopack the toolpack to register,      */,     public void addToolPack(UDFFinder toopack){,         AggregatingUDFFinder udfs = (AggregatingUDFFinder)_udfFinder;,         udfs.add(toopack);,     }, ,     /**,      * Whether the application shall perform a full recalculation when the workbook is opened.,      * <p>,      * Typically you want to force formula recalculation when you modify cell formulas or values,      * of a workbook previously created by Excel. When set to true, this flag will tell Excel,      * that it needs to recalculate all formulas in the workbook the next time the file is opened.,      * </p>,      * <p>,      * Note, that recalculation updates cached formula results and, thus, modifies the workbook.,      * Depending on the version, Excel may prompt you with "Do you want to save the changes in <em>filename</em>?",      * on close.,      * </p>,      *,      * @param value true if the application will perform a full recalculation of,      * workbook values when the workbook is opened,      * @since 3.8,      */,     public void setForceFormulaRecalculation(boolean value){,         InternalWorkbook iwb = getWorkbook();,         RecalcIdRecord recalc = iwb.getRecalcId();,         recalc.setEngineId(0);,     }, ,     /**,      * Whether Excel will be asked to recalculate all formulas when the  workbook is opened.,      *,      * @since 3.8,      */,     public boolean getForceFormulaRecalculation(){,         InternalWorkbook iwb = getWorkbook();,         RecalcIdRecord recalc = (RecalcIdRecord)iwb.findFirstRecordBySid(RecalcIdRecord.sid);,         return recalc != null && recalc.getEngineId() != 0;],,
BAD_PRACTICE,ES_COMPARING_PARAMETER_STRING_WITH_EQ,org/apache/poi/hssf/view/SVTableCellRenderer.java,firePropertyChange,260-260,[	if (propertyName=="text") {],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/poi/hssf/view/SVTableCellRenderer.java,,45-45,[    protected static Border noFocusBorder = new EmptyBorder(1, 1, 1, 1);],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/poi/hssf/view/SVTableCellRenderer.java,,45-273,[    protected static Border noFocusBorder = new EmptyBorder(1, 1, 1, 1);,     protected SVBorder cellBorder = new SVBorder();, , ,     private HSSFWorkbook wb = null;, ,     /** This class holds the references to the predefined cell formats.,      */,     private class CellFormatter {,       private Format[] textFormatter;, ,       private DecimalFormat generalNumberFormat = new DecimalFormat("0");, ,       public CellFormatter() {,         textFormatter = new Format[0x31];, ,         textFormatter[0x01] = new DecimalFormat("0");,         textFormatter[0x02] = new DecimalFormat("0.00");,         textFormatter[0x03] = new DecimalFormat("#,##0");,         textFormatter[0x04] = new DecimalFormat("#,##0.00");,         textFormatter[0x05] = new DecimalFormat("$#,##0;$#,##0");,         textFormatter[0x06] = new DecimalFormat("$#,##0;$#,##0");,         textFormatter[0x07] = new DecimalFormat("$#,##0.00;$#,##0.00");,         textFormatter[0x08] = new DecimalFormat("$#,##0.00;$#,##0.00");,         textFormatter[0x09] = new DecimalFormat("0%");,         textFormatter[0x0A] = new DecimalFormat("0.00%");,         textFormatter[0x0B] = new DecimalFormat("0.00E0");,         textFormatter[0x0C] = new SVFractionalFormat("# ?/?");,         textFormatter[0x0D] = new SVFractionalFormat("# ??/??");,         textFormatter[0x0E] = new SimpleDateFormat("M/d/yy");,         textFormatter[0x0F] = new SimpleDateFormat("d-MMM-yy");,         textFormatter[0x10] = new SimpleDateFormat("d-MMM");,         textFormatter[0x11] = new SimpleDateFormat("MMM-yy");,         textFormatter[0x12] = new SimpleDateFormat("h:mm a");,         textFormatter[0x13] = new SimpleDateFormat("h:mm:ss a");,         textFormatter[0x14] = new SimpleDateFormat("h:mm");,         textFormatter[0x15] = new SimpleDateFormat("h:mm:ss");,         textFormatter[0x16] = new SimpleDateFormat("M/d/yy h:mm");,         // 0x17 - 0x24 reserved for international and undocumented 0x25, "(#,##0_);(#,##0)",         //start at 0x26,         //jmh need to do colour,         //"(#,##0_);[Red](#,##0)",         textFormatter[0x26] = new DecimalFormat("#,##0;#,##0");,         //jmh need to do colour,         //(#,##0.00_);(#,##0.00),         textFormatter[0x27] = new DecimalFormat("#,##0.00;#,##0.00");,         textFormatter[0x28] = new DecimalFormat("#,##0.00;#,##0.00");, //??        textFormatter[0x29] = new DecimalFormat("_(*#,##0_);_(*(#,##0);_(* \"-\"_);_(@_)");, //??        textFormatter[0x2A] = new DecimalFormat("_($*#,##0_);_($*(#,##0);_($* \"-\"_);_(@_)");, //??        textFormatter[0x2B] = new DecimalFormat("_(*#,##0.00_);_(*(#,##0.00);_(*\"-\"??_);_(@_)");, //??        textFormatter[0x2C] = new DecimalFormat("_($*#,##0.00_);_($*(#,##0.00);_($*\"-\"??_);_(@_)");,         textFormatter[0x2D] = new SimpleDateFormat("mm:ss");, //??        textFormatter[0x2E] = new SimpleDateFormat("[h]:mm:ss");,         textFormatter[0x2F] = new SimpleDateFormat("mm:ss.0");,         textFormatter[0x30] = new DecimalFormat("##0.0E0");,       }, ,       public String format(short index, Object value) {,         if (index == 0),           return value.toString();,         if (textFormatter[index] == null),           throw new RuntimeException("Sorry. I cant handle the format code :"+Integer.toHexString(index));,         return textFormatter[index].format(value);,       }, ,       public String format(short index, double value) {,         if ( index <= 0 ),           return generalNumberFormat.format(value);,         if (textFormatter[index] == null),           throw new RuntimeException("Sorry. I cant handle the format code :"+Integer.toHexString(index));,         if (textFormatter[index] instanceof DecimalFormat) {,           return ((DecimalFormat)textFormatter[index]).format(value);,         },         if (textFormatter[index] instanceof SVFractionalFormat) {,           return ((SVFractionalFormat)textFormatter[index]).format(value);,         },         throw new RuntimeException("Sorry. I cant handle a non decimal formatter for a decimal value :"+Integer.toHexString(index));,       }, ,       public boolean useRedColor(short index, double value) {,         return (((index == 0x06)||(index == 0x08)||(index == 0x26) || (index == 0x27)) && (value < 0));,       },     }, ,     private final CellFormatter cellFormatter = new CellFormatter();, ,     public SVTableCellRenderer(HSSFWorkbook wb) {, 	super();, 	setOpaque(true);,         setBorder(noFocusBorder);,         this.wb = wb;,     }, ,     public Component getTableCellRendererComponent(JTable table, Object value,,                           boolean isSelected, boolean hasFocus, int row, int column) {, 	boolean isBorderSet = false;, ,         //If the JTables default cell renderer has been setup correctly the,         //value will be the HSSFCell that we are trying to render,         HSSFCell c = (HSSFCell)value;, ,         if (c != null) {,           HSSFCellStyle s = c.getCellStyle();,           HSSFFont f = wb.getFontAt(s.getFontIndex());,           setFont(SVTableUtils.makeFont(f));, ,           if (s.getFillPattern() == HSSFCellStyle.SOLID_FOREGROUND) {,             setBackground(SVTableUtils.getAWTColor(s.getFillForegroundColor(), SVTableUtils.white));,           } else setBackground(SVTableUtils.white);, ,           setForeground(SVTableUtils.getAWTColor(f.getColor(), SVTableUtils.black));, ,           cellBorder.setBorder(SVTableUtils.getAWTColor(s.getTopBorderColor(), SVTableUtils.black),,                                SVTableUtils.getAWTColor(s.getRightBorderColor(), SVTableUtils.black),,                                SVTableUtils.getAWTColor(s.getBottomBorderColor(), SVTableUtils.black),,                                SVTableUtils.getAWTColor(s.getLeftBorderColor(), SVTableUtils.black),,                                s.getBorderTop(), s.getBorderRight(),,                                s.getBorderBottom(), s.getBorderLeft(),,                                hasFocus);,             setBorder(cellBorder);,             isBorderSet=true;, ,             //Set the value that is rendered for the cell,             switch (c.getCellType()) {,               case HSSFCell.CELL_TYPE_BLANK:,                 setValue("");,               break;,               case HSSFCell.CELL_TYPE_BOOLEAN:,                 if (c.getBooleanCellValue()) {,                   setValue("true");,                 } else {,                   setValue("false");,                 },               break;,               case HSSFCell.CELL_TYPE_NUMERIC:,                 short format = s.getDataFormat();,                 double numericValue = c.getNumericCellValue();,                 if (cellFormatter.useRedColor(format, numericValue)),                   setForeground(Color.red);,                 else setForeground(null);,                 setValue(cellFormatter.format(format, c.getNumericCellValue()));,               break;,               case HSSFCell.CELL_TYPE_STRING:,                 setValue(c.getRichStringCellValue().getString());,               break;,               case HSSFCell.CELL_TYPE_FORMULA:,               default:,                 setValue("?");,             },             //Set the text alignment of the cell,             switch (s.getAlignment()) {,               case HSSFCellStyle.ALIGN_LEFT:,               case HSSFCellStyle.ALIGN_JUSTIFY:,               case HSSFCellStyle.ALIGN_FILL:,                 setHorizontalAlignment(SwingConstants.LEFT);,                 break;,               case HSSFCellStyle.ALIGN_CENTER:,               case HSSFCellStyle.ALIGN_CENTER_SELECTION:,                 setHorizontalAlignment(SwingConstants.CENTER);,                 break;,               case HSSFCellStyle.ALIGN_GENERAL:,               case HSSFCellStyle.ALIGN_RIGHT:,                 setHorizontalAlignment(SwingConstants.RIGHT);,                 break;,               default:,                 setHorizontalAlignment(SwingConstants.LEFT);,                 break;,             },         } else {,           setValue("");,           setBackground(SVTableUtils.white);,         }, , , 	if (hasFocus) {,             if (!isBorderSet) {,               //This is the border to paint when there is no border,               //and the cell has focus,               cellBorder.setBorder(SVTableUtils.black,,                                    SVTableUtils.black,,                                    SVTableUtils.black,,                                    SVTableUtils.black,,                                    HSSFCellStyle.BORDER_NONE,,                                    HSSFCellStyle.BORDER_NONE,,                                    HSSFCellStyle.BORDER_NONE,,                                    HSSFCellStyle.BORDER_NONE,,                                    isSelected);,               setBorder(cellBorder);,             }, 	    if (table.isCellEditable(row, column)) {, 	        setForeground( UIManager.getColor("Table.focusCellForeground") );, 	        setBackground( UIManager.getColor("Table.focusCellBackground") );, 	    }, 	} else if (!isBorderSet) {, 	    setBorder(noFocusBorder);, 	}, , 	// ---- begin optimization to avoid painting background ----, 	Color back = getBackground();, 	boolean colorMatch = (back != null) && ( back.equals(table.getBackground()) ) && table.isOpaque();,         setOpaque(!colorMatch);, 	// ---- end optimization to aviod painting background ----, 	return this;,     }, ,     public void validate() {}, ,     public void revalidate() {}, ,     public void repaint(long tm, int x, int y, int width, int height) {}, ,     public void repaint(Rectangle r) { }, ,     protected void firePropertyChange(String propertyName, Object oldValue, Object newValue) {, 	// Strings get interned..., 	if (propertyName=="text") {, 	    super.firePropertyChange(propertyName, oldValue, newValue);, 	},     }, ,     public void firePropertyChange(String propertyName, boolean oldValue, boolean newValue) { }, ,     /**,      * Sets the string to either the value or "" if the value is null.,      *,      */,     protected void setValue(Object value) {, 	setText((value == null) ? "" : value.toString());,     }],,
BAD_PRACTICE,SE_BAD_FIELD,org/apache/poi/hssf/view/SVTableCellRenderer.java,,56-125,[      private DecimalFormat generalNumberFormat = new DecimalFormat("0");, ,       public CellFormatter() {,         textFormatter = new Format[0x31];, ,         textFormatter[0x01] = new DecimalFormat("0");,         textFormatter[0x02] = new DecimalFormat("0.00");,         textFormatter[0x03] = new DecimalFormat("#,##0");,         textFormatter[0x04] = new DecimalFormat("#,##0.00");,         textFormatter[0x05] = new DecimalFormat("$#,##0;$#,##0");,         textFormatter[0x06] = new DecimalFormat("$#,##0;$#,##0");,         textFormatter[0x07] = new DecimalFormat("$#,##0.00;$#,##0.00");,         textFormatter[0x08] = new DecimalFormat("$#,##0.00;$#,##0.00");,         textFormatter[0x09] = new DecimalFormat("0%");,         textFormatter[0x0A] = new DecimalFormat("0.00%");,         textFormatter[0x0B] = new DecimalFormat("0.00E0");,         textFormatter[0x0C] = new SVFractionalFormat("# ?/?");,         textFormatter[0x0D] = new SVFractionalFormat("# ??/??");,         textFormatter[0x0E] = new SimpleDateFormat("M/d/yy");,         textFormatter[0x0F] = new SimpleDateFormat("d-MMM-yy");,         textFormatter[0x10] = new SimpleDateFormat("d-MMM");,         textFormatter[0x11] = new SimpleDateFormat("MMM-yy");,         textFormatter[0x12] = new SimpleDateFormat("h:mm a");,         textFormatter[0x13] = new SimpleDateFormat("h:mm:ss a");,         textFormatter[0x14] = new SimpleDateFormat("h:mm");,         textFormatter[0x15] = new SimpleDateFormat("h:mm:ss");,         textFormatter[0x16] = new SimpleDateFormat("M/d/yy h:mm");,         // 0x17 - 0x24 reserved for international and undocumented 0x25, "(#,##0_);(#,##0)",         //start at 0x26,         //jmh need to do colour,         //"(#,##0_);[Red](#,##0)",         textFormatter[0x26] = new DecimalFormat("#,##0;#,##0");,         //jmh need to do colour,         //(#,##0.00_);(#,##0.00),         textFormatter[0x27] = new DecimalFormat("#,##0.00;#,##0.00");,         textFormatter[0x28] = new DecimalFormat("#,##0.00;#,##0.00");, //??        textFormatter[0x29] = new DecimalFormat("_(*#,##0_);_(*(#,##0);_(* \"-\"_);_(@_)");, //??        textFormatter[0x2A] = new DecimalFormat("_($*#,##0_);_($*(#,##0);_($* \"-\"_);_(@_)");, //??        textFormatter[0x2B] = new DecimalFormat("_(*#,##0.00_);_(*(#,##0.00);_(*\"-\"??_);_(@_)");, //??        textFormatter[0x2C] = new DecimalFormat("_($*#,##0.00_);_($*(#,##0.00);_($*\"-\"??_);_(@_)");,         textFormatter[0x2D] = new SimpleDateFormat("mm:ss");, //??        textFormatter[0x2E] = new SimpleDateFormat("[h]:mm:ss");,         textFormatter[0x2F] = new SimpleDateFormat("mm:ss.0");,         textFormatter[0x30] = new DecimalFormat("##0.0E0");,       }, ,       public String format(short index, Object value) {,         if (index == 0),           return value.toString();,         if (textFormatter[index] == null),           throw new RuntimeException("Sorry. I cant handle the format code :"+Integer.toHexString(index));,         return textFormatter[index].format(value);,       }, ,       public String format(short index, double value) {,         if ( index <= 0 ),           return generalNumberFormat.format(value);,         if (textFormatter[index] == null),           throw new RuntimeException("Sorry. I cant handle the format code :"+Integer.toHexString(index));,         if (textFormatter[index] instanceof DecimalFormat) {,           return ((DecimalFormat)textFormatter[index]).format(value);,         },         if (textFormatter[index] instanceof SVFractionalFormat) {,           return ((SVFractionalFormat)textFormatter[index]).format(value);,         },         throw new RuntimeException("Sorry. I cant handle a non decimal formatter for a decimal value :"+Integer.toHexString(index));,       }, ,       public boolean useRedColor(short index, double value) {,         return (((index == 0x06)||(index == 0x08)||(index == 0x26) || (index == 0x27)) && (value < 0));],,
BAD_PRACTICE,SE_BAD_FIELD,org/apache/poi/hssf/usermodel/HSSFWorkbook.java,,78-1798,[public final class HSSFWorkbook extends POIDocument implements org.apache.poi.ss.usermodel.Workbook {,     private static final Pattern COMMA_PATTERN = Pattern.compile(",");,     private static final int MAX_ROW = 0xFFFF;,     private static final short MAX_COLUMN = (short)0x00FF;, ,     /**,      * The maximum number of cell styles in a .xls workbook.,      * The 'official' limit is 4,000, but POI allows a slightly larger number.,      * This extra delta takes into account built-in styles that are automatically,      * created for new workbooks,      *,      * See http://office.microsoft.com/en-us/excel-help/excel-specifications-and-limits-HP005199291.aspx,      */,     private static final int MAX_STYLES = 4030;, ,     private static final int DEBUG = POILogger.DEBUG;, ,     /**,      * used for compile-time performance/memory optimization.  This determines the,      * initial capacity for the sheet collection.  Its currently set to 3.,      * Changing it in this release will decrease performance,      * since you're never allowed to have more or less than three sheets!,      */, ,     public final static int INITIAL_CAPACITY = 3;, ,     /**,      * this is the reference to the low level Workbook object,      */, ,     private InternalWorkbook workbook;, ,     /**,      * this holds the HSSFSheet objects attached to this workbook,      */, ,     protected List<HSSFSheet> _sheets;, ,     /**,      * this holds the HSSFName objects attached to this workbook,      */, ,     private ArrayList<HSSFName> names;, ,     /**,      * this holds the HSSFFont objects attached to this workbook.,      * We only create these from the low level records as required.,      */,     private Hashtable fonts;, ,     /**,      * holds whether or not to preserve other nodes in the POIFS.  Used,      * for macros and embedded objects.,      */,     private boolean   preserveNodes;, ,     /**,      * Used to keep track of the data formatter so that all,      * createDataFormatter calls return the same one for a given,      * book.  This ensures that updates from one places is visible,      * someplace else.,      */,     private HSSFDataFormat formatter;, ,     /**,      * The policy to apply in the event of missing or,      *  blank cells when fetching from a row.,      * See {@link MissingCellPolicy},      */,     private MissingCellPolicy missingCellPolicy = HSSFRow.RETURN_NULL_AND_BLANK;, ,     private static POILogger log = POILogFactory.getLogger(HSSFWorkbook.class);, ,     /**,      * The locator of user-defined functions.,      * By default includes functions from the Excel Analysis Toolpack,      */,     private UDFFinder _udfFinder = UDFFinder.DEFAULT;, ,     public static HSSFWorkbook create(InternalWorkbook book) {,     	return new HSSFWorkbook(book);,     },     /**,      * Creates new HSSFWorkbook from scratch (start here!),      *,      */,     public HSSFWorkbook() {,         this(InternalWorkbook.createWorkbook());,     }, , 	private HSSFWorkbook(InternalWorkbook book) {, 		super((DirectoryNode)null);, 		workbook = book;, 		_sheets = new ArrayList<HSSFSheet>(INITIAL_CAPACITY);, 		names = new ArrayList<HSSFName>(INITIAL_CAPACITY);, 	}, ,     public HSSFWorkbook(POIFSFileSystem fs) throws IOException {,         this(fs,true);,     }, ,     /**,      * given a POI POIFSFileSystem object, read in its Workbook and populate the high and,      * low level models.  If you're reading in a workbook...start here.,      *,      * @param fs the POI filesystem that contains the Workbook stream.,      * @param preserveNodes whether to preseve other nodes, such as,      *        macros.  This takes more memory, so only say yes if you,      *        need to. If set, will store all of the POIFSFileSystem,      *        in memory,      * @see org.apache.poi.poifs.filesystem.POIFSFileSystem,      * @exception IOException if the stream cannot be read,      */,     public HSSFWorkbook(POIFSFileSystem fs, boolean preserveNodes),             throws IOException,     {,         this(fs.getRoot(), fs, preserveNodes);,     }, ,     /**,      * Normally, the Workbook will be in a POIFS Stream,      * called "Workbook". However, some weird XLS generators use "WORKBOOK",      */,     private static final String[] WORKBOOK_DIR_ENTRY_NAMES = {,         "Workbook", // as per BIFF8 spec,         "WORKBOOK",,     };, , ,     private static String getWorkbookDirEntryName(DirectoryNode directory) {, ,         String[] potentialNames = WORKBOOK_DIR_ENTRY_NAMES;,         for (int i = 0; i < potentialNames.length; i++) {,             String wbName = potentialNames[i];,             try {,                 directory.getEntry(wbName);,                 return wbName;,             } catch (FileNotFoundException e) {,                 // continue - to try other options,             },         }, ,         // check for previous version of file format,         try {,             directory.getEntry("Book");,             throw new OldExcelFormatException("The supplied spreadsheet seems to be Excel 5.0/7.0 (BIFF5) format. ",                     + "POI only supports BIFF8 format (from Excel versions 97/2000/XP/2003)");,         } catch (FileNotFoundException e) {,             // fall through,         }, ,         throw new IllegalArgumentException("The supplied POIFSFileSystem does not contain a BIFF8 'Workbook' entry. ",             + "Is it really an excel file?");,     }, ,     /**,      * given a POI POIFSFileSystem object, and a specific directory,      *  within it, read in its Workbook and populate the high and,      *  low level models.  If you're reading in a workbook...start here.,      *,      * @param directory the POI filesystem directory to process from,      * @param fs the POI filesystem that contains the Workbook stream.,      * @param preserveNodes whether to preseve other nodes, such as,      *        macros.  This takes more memory, so only say yes if you,      *        need to. If set, will store all of the POIFSFileSystem,      *        in memory,      * @see org.apache.poi.poifs.filesystem.POIFSFileSystem,      * @exception IOException if the stream cannot be read,      */,     public HSSFWorkbook(DirectoryNode directory, POIFSFileSystem fs, boolean preserveNodes),             throws IOException,     {,        this(directory, preserveNodes);,     },     ,     /**,      * given a POI POIFSFileSystem object, and a specific directory,      *  within it, read in its Workbook and populate the high and,      *  low level models.  If you're reading in a workbook...start here.,      *,      * @param directory the POI filesystem directory to process from,      * @param preserveNodes whether to preseve other nodes, such as,      *        macros.  This takes more memory, so only say yes if you,      *        need to. If set, will store all of the POIFSFileSystem,      *        in memory,      * @see org.apache.poi.poifs.filesystem.POIFSFileSystem,      * @exception IOException if the stream cannot be read,      */,     public HSSFWorkbook(DirectoryNode directory, boolean preserveNodes),             throws IOException,     {,         super(directory);,         String workbookName = getWorkbookDirEntryName(directory);, ,         this.preserveNodes = preserveNodes;, ,         // If we're not preserving nodes, don't track the,         //  POIFS any more,         if(! preserveNodes) {,            this.directory = null;,         }, ,         _sheets = new ArrayList<HSSFSheet>(INITIAL_CAPACITY);,         names  = new ArrayList<HSSFName>(INITIAL_CAPACITY);, ,         // Grab the data from the workbook stream, however,         //  it happens to be spelled.,         InputStream stream = directory.createDocumentInputStream(workbookName);, ,         List<Record> records = RecordFactory.createRecords(stream);, ,         workbook = InternalWorkbook.createWorkbook(records);,         setPropertiesFromWorkbook(workbook);,         int recOffset = workbook.getNumRecords();,         int sheetNum = 0;, ,         // convert all LabelRecord records to LabelSSTRecord,         convertLabelRecords(records, recOffset);,         RecordStream rs = new RecordStream(records, recOffset);,         while (rs.hasNext()) {,             InternalSheet sheet = InternalSheet.createSheet(rs);,             _sheets.add(new HSSFSheet(this, sheet));,         }, ,         for (int i = 0 ; i < workbook.getNumNames() ; ++i){,             NameRecord nameRecord = workbook.getNameRecord(i);,             HSSFName name = new HSSFName(this, nameRecord, workbook.getNameCommentRecord(nameRecord));,             names.add(name);,         },     }, ,      public HSSFWorkbook(InputStream s) throws IOException {,          this(s,true);,      }, ,     /**,      * Companion to HSSFWorkbook(POIFSFileSystem), this constructs the POI filesystem around your,      * inputstream.,      *,      * @param s  the POI filesystem that contains the Workbook stream.,      * @param preserveNodes whether to preseve other nodes, such as,      *        macros.  This takes more memory, so only say yes if you,      *        need to.,      * @see org.apache.poi.poifs.filesystem.POIFSFileSystem,      * @see #HSSFWorkbook(POIFSFileSystem),      * @exception IOException if the stream cannot be read,      */, ,     public HSSFWorkbook(InputStream s, boolean preserveNodes),             throws IOException,     {,         this(new POIFSFileSystem(s), preserveNodes);,     }, ,     /**,      * used internally to set the workbook properties.,      */, ,     private void setPropertiesFromWorkbook(InternalWorkbook book),     {,         this.workbook = book;, ,         // none currently,     }, ,     /**,       * This is basically a kludge to deal with the now obsolete Label records.  If,       * you have to read in a sheet that contains Label records, be aware that the rest,       * of the API doesn't deal with them, the low level structure only provides read-only,       * semi-immutable structures (the sets are there for interface conformance with NO,       * impelmentation).  In short, you need to call this function passing it a reference,       * to the Workbook object.  All labels will be converted to LabelSST records and their,       * contained strings will be written to the Shared String tabel (SSTRecord) within,       * the Workbook.,       *,       * @param records a collection of sheet's records.,       * @param offset the offset to search at ,       * @see org.apache.poi.hssf.record.LabelRecord,       * @see org.apache.poi.hssf.record.LabelSSTRecord,       * @see org.apache.poi.hssf.record.SSTRecord,       */, ,      private void convertLabelRecords(List records, int offset),      {,          if (log.check( POILogger.DEBUG )),              log.log(POILogger.DEBUG, "convertLabelRecords called");,          for (int k = offset; k < records.size(); k++),          {,              Record rec = ( Record ) records.get(k);, ,              if (rec.getSid() == LabelRecord.sid),              {,                  LabelRecord oldrec = ( LabelRecord ) rec;, ,                  records.remove(k);,                  LabelSSTRecord newrec   = new LabelSSTRecord();,                  int            stringid =,                      workbook.addSSTString(new UnicodeString(oldrec.getValue()));, ,                  newrec.setRow(oldrec.getRow());,                  newrec.setColumn(oldrec.getColumn());,                  newrec.setXFIndex(oldrec.getXFIndex());,                  newrec.setSSTIndex(stringid);,                        records.add(k, newrec);,              },          },          if (log.check( POILogger.DEBUG )),              log.log(POILogger.DEBUG, "convertLabelRecords exit");,      }, ,     /**,      * Retrieves the current policy on what to do when,      *  getting missing or blank cells from a row.,      * The default is to return blank and null cells.,      *  {@link MissingCellPolicy},      */,     public MissingCellPolicy getMissingCellPolicy() {,         return missingCellPolicy;,     }, ,     /**,      * Sets the policy on what to do when,      *  getting missing or blank cells from a row.,      * This will then apply to all calls to,      *  {@link HSSFRow#getCell(int)}}. See,      *  {@link MissingCellPolicy}.,      * Note that this has no effect on any,      *  iterators, only on when fetching Cells,      *  by their column index.,      */,     public void setMissingCellPolicy(MissingCellPolicy missingCellPolicy) {,         this.missingCellPolicy = missingCellPolicy;,     }, ,     /**,      * sets the order of appearance for a given sheet.,      *,      * @param sheetname the name of the sheet to reorder,      * @param pos the position that we want to insert the sheet into (0 based),      */, ,     public void setSheetOrder(String sheetname, int pos ) {,         int oldSheetIndex = getSheetIndex(sheetname);,         _sheets.add(pos,_sheets.remove(oldSheetIndex));,         workbook.setSheetOrder(sheetname, pos);, ,         FormulaShifter shifter = FormulaShifter.createForSheetShift(oldSheetIndex, pos);,         for (HSSFSheet sheet : _sheets) {,             sheet.getSheet().updateFormulasAfterCellShift(shifter, /* not used */ -1 );,         }, ,         workbook.updateNamesAfterCellShift(shifter);, ,     }, ,     private void validateSheetIndex(int index) {,         int lastSheetIx = _sheets.size() - 1;,         if (index < 0 || index > lastSheetIx) {,             throw new IllegalArgumentException("Sheet index (",                     + index +") is out of range (0.." +    lastSheetIx + ")");,         },     }, ,     /**,      * Selects a single sheet. This may be different to,      * the 'active' sheet (which is the sheet with focus).,      */,     public void setSelectedTab(int index) {, ,         validateSheetIndex(index);,         int nSheets = _sheets.size();,         for (int i=0; i<nSheets; i++) {,                getSheetAt(i).setSelected(i == index);,         },         workbook.getWindowOne().setNumSelectedTabs((short)1);,     },     /**,      * deprecated May 2008,      * @deprecated use setSelectedTab(int),      */,     public void setSelectedTab(short index) {,         setSelectedTab((int)index);,     },     public void setSelectedTabs(int[] indexes) {, ,         for (int i = 0; i < indexes.length; i++) {,             validateSheetIndex(indexes[i]);,         },         int nSheets = _sheets.size();,         for (int i=0; i<nSheets; i++) {,             boolean bSelect = false;,             for (int j = 0; j < indexes.length; j++) {,                 if (indexes[j] == i) {,                     bSelect = true;,                     break;,                 }, ,             },                getSheetAt(i).setSelected(bSelect);,         },         workbook.getWindowOne().setNumSelectedTabs((short)indexes.length);,     },     /**,      * Convenience method to set the active sheet.  The active sheet is is the sheet,      * which is currently displayed when the workbook is viewed in Excel.,      * 'Selected' sheet(s) is a distinct concept.,      */,     public void setActiveSheet(int index) {, ,         validateSheetIndex(index);,         int nSheets = _sheets.size();,         for (int i=0; i<nSheets; i++) {,              getSheetAt(i).setActive(i == index);,         },         workbook.getWindowOne().setActiveSheetIndex(index);,     }, ,     /**,      * gets the tab whose data is actually seen when the sheet is opened.,      * This may be different from the "selected sheet" since excel seems to,      * allow you to show the data of one sheet when another is seen "selected",      * in the tabs (at the bottom).,      * @see org.apache.poi.hssf.usermodel.HSSFSheet#setSelected(boolean),      */,     public int getActiveSheetIndex() {,         return workbook.getWindowOne().getActiveSheetIndex();,     },     /**,      * deprecated May 2008,      * @deprecated - Misleading name - use getActiveSheetIndex(),      */,     public short getSelectedTab() {,         return (short) getActiveSheetIndex();,     }, , ,     /**,      * sets the first tab that is displayed in the list of tabs,      * in excel.,      * @param index,      */,     public void setFirstVisibleTab(int index) {,         workbook.getWindowOne().setFirstVisibleTab(index);,     },     /**,      * deprecated May 2008,      * @deprecated - Misleading name - use setFirstVisibleTab(),      */,     public void setDisplayedTab(short index) {,        setFirstVisibleTab(index);,     }, ,     /**,      * sets the first tab that is displayed in the list of tabs in excel.,      */,     public int getFirstVisibleTab() {,         return workbook.getWindowOne().getFirstVisibleTab();,     },     /**,      * deprecated May 2008,      * @deprecated - Misleading name - use getFirstVisibleTab(),      */,     public short getDisplayedTab() {,         return (short) getFirstVisibleTab();,     }, ,     /**,      * Set the sheet name.,      *,      * @param sheetIx number (0 based),      * @throws IllegalArgumentException if the name is null or invalid,      *  or workbook already contains a sheet with this name,      * @see #createSheet(String),      * @see org.apache.poi.ss.util.WorkbookUtil#createSafeSheetName(String nameProposal),      */,     public void setSheetName(int sheetIx, String name) {,         if (name == null) {,             throw new IllegalArgumentException("sheetName must not be null");,         }, ,         if (workbook.doesContainsSheetName(name, sheetIx)) {,             throw new IllegalArgumentException("The workbook already contains a sheet with this name");,         },         validateSheetIndex(sheetIx);,         workbook.setSheetName(sheetIx, name);,     }, ,     /**,      * @return Sheet name for the specified index,      */,     public String getSheetName(int sheetIndex) {,         validateSheetIndex(sheetIndex);,         return workbook.getSheetName(sheetIndex);,     }, ,     public boolean isHidden() {,         return workbook.getWindowOne().getHidden();,     }, ,     public void setHidden(boolean hiddenFlag) {,         workbook.getWindowOne().setHidden(hiddenFlag);,     }, ,     public boolean isSheetHidden(int sheetIx) {,         validateSheetIndex(sheetIx);,         return workbook.isSheetHidden(sheetIx);,     }, ,     public boolean isSheetVeryHidden(int sheetIx) {,         validateSheetIndex(sheetIx);,         return workbook.isSheetVeryHidden(sheetIx);,     }, , ,     public void setSheetHidden(int sheetIx, boolean hidden) {,         validateSheetIndex(sheetIx);,         workbook.setSheetHidden(sheetIx, hidden);,     }, ,     public void setSheetHidden(int sheetIx, int hidden) {,         validateSheetIndex(sheetIx);,         WorkbookUtil.validateSheetState(hidden);,         workbook.setSheetHidden(sheetIx, hidden);,     }, ,     /** Returns the index of the sheet by his name,      * @param name the sheet name,      * @return index of the sheet (0 based),      */,     public int getSheetIndex(String name){,         return workbook.getSheetIndex(name);,     }, ,     /** Returns the index of the given sheet,      * @param sheet the sheet to look up,      * @return index of the sheet (0 based). <tt>-1</tt> if not found,      */,     public int getSheetIndex(org.apache.poi.ss.usermodel.Sheet sheet) {,         for(int i=0; i<_sheets.size(); i++) {,             if(_sheets.get(i) == sheet) {,                 return i;,             },         },         return -1;,     }, ,     /**,      * Returns the external sheet index of the sheet,      *  with the given internal index, creating one,      *  if needed.,      * Used by some of the more obscure formula and,      *  named range things.,      * @deprecated for POI internal use only (formula parsing).  This method is likely to,      * be removed in future versions of POI.,      */,     public int getExternalSheetIndex(int internalSheetIndex) {,         return workbook.checkExternSheet(internalSheetIndex);,     },     /**,      * @deprecated for POI internal use only (formula rendering).  This method is likely to,      * be removed in future versions of POI.,      */,     public String findSheetNameFromExternSheet(int externSheetIndex){,         // TODO - don't expose internal ugliness like externSheet indexes to the user model API,         return workbook.findSheetNameFromExternSheet(externSheetIndex);,     },     /**,      * @deprecated for POI internal use only (formula rendering).  This method is likely to,      * be removed in future versions of POI.,      *,      * @param refIndex Index to REF entry in EXTERNSHEET record in the Link Table,      * @param definedNameIndex zero-based to DEFINEDNAME or EXTERNALNAME record,      * @return the string representation of the defined or external name,      */,     public String resolveNameXText(int refIndex, int definedNameIndex) {,         // TODO - make this less cryptic / move elsewhere,         return workbook.resolveNameXText(refIndex, definedNameIndex);,     }, , , , ,     /**,      * create an HSSFSheet for this HSSFWorkbook, adds it to the sheets and returns,      * the high level representation.  Use this to create new sheets.,      *,      * @return HSSFSheet representing the new sheet.,      */, ,     public HSSFSheet createSheet(),     {,         HSSFSheet sheet = new HSSFSheet(this);, ,         _sheets.add(sheet);,         workbook.setSheetName(_sheets.size() - 1, "Sheet" + (_sheets.size() - 1));,         boolean isOnlySheet = _sheets.size() == 1;,         sheet.setSelected(isOnlySheet);,         sheet.setActive(isOnlySheet);,         return sheet;,     }, ,     /**,      * create an HSSFSheet from an existing sheet in the HSSFWorkbook.,      *,      * @return HSSFSheet representing the cloned sheet.,      */, ,     public HSSFSheet cloneSheet(int sheetIndex) {,         validateSheetIndex(sheetIndex);,         HSSFSheet srcSheet = _sheets.get(sheetIndex);,         String srcName = workbook.getSheetName(sheetIndex);,         HSSFSheet clonedSheet = srcSheet.cloneSheet(this);,         clonedSheet.setSelected(false);,         clonedSheet.setActive(false);, ,         String name = getUniqueSheetName(srcName);,         int newSheetIndex = _sheets.size();,         _sheets.add(clonedSheet);,         workbook.setSheetName(newSheetIndex, name);, ,         // Check this sheet has an autofilter, (which has a built-in NameRecord at workbook level),         int filterDbNameIndex = findExistingBuiltinNameRecordIdx(sheetIndex, NameRecord.BUILTIN_FILTER_DB);,         if (filterDbNameIndex != -1) {,             NameRecord newNameRecord = workbook.cloneFilter(filterDbNameIndex, newSheetIndex);,             HSSFName newName = new HSSFName(this, newNameRecord);,             names.add(newName);,         },         // TODO - maybe same logic required for other/all built-in name records,         workbook.cloneDrawings(clonedSheet.getSheet());, ,         return clonedSheet;,     }, ,     private String getUniqueSheetName(String srcName) {,         int uniqueIndex = 2;,         String baseName = srcName;,         int bracketPos = srcName.lastIndexOf('(');,         if (bracketPos > 0 && srcName.endsWith(")")) {,             String suffix = srcName.substring(bracketPos + 1, srcName.length() - ")".length());,             try {,                 uniqueIndex = Integer.parseInt(suffix.trim());,                 uniqueIndex++;,                 baseName=srcName.substring(0, bracketPos).trim();,             } catch (NumberFormatException e) {,                 // contents of brackets not numeric,             },         },         while (true) {,             // Try and find the next sheet name that is unique,             String index = Integer.toString(uniqueIndex++);,             String name;,             if (baseName.length() + index.length() + 2 < 31) {,                 name = baseName + " (" + index + ")";,             } else {,                 name = baseName.substring(0, 31 - index.length() - 2) + "(" + index + ")";,             }, ,             //If the sheet name is unique, then set it otherwise move on to the next number.,             if (workbook.getSheetIndex(name) == -1) {,               return name;,             },         },     }, ,     /**,      * Create a new sheet for this Workbook and return the high level representation.,      * Use this to create new sheets.,      *,      * <p>,      *     Note that Excel allows sheet names up to 31 chars in length but other applications,      *     (such as OpenOffice) allow more. Some versions of Excel crash with names longer than 31 chars,,      *     others - truncate such names to 31 character.,      * </p>,      * <p>,      *     POI's SpreadsheetAPI silently truncates the input argument to 31 characters.,      *     Example:,      *,      *     <pre><code>,      *     Sheet sheet = workbook.createSheet("My very long sheet name which is longer than 31 chars"); // will be truncated,      *     assert 31 == sheet.getSheetName().length();,      *     assert "My very long sheet name which i" == sheet.getSheetName();,      *     </code></pre>,      * </p>,      *,      * Except the 31-character constraint, Excel applies some other rules:,      * <p>,      * Sheet name MUST be unique in the workbook and MUST NOT contain the any of the following characters:,      * <ul>,      * <li> 0x0000 </li>,      * <li> 0x0003 </li>,      * <li> colon (:) </li>,      * <li> backslash (\) </li>,      * <li> asterisk (*) </li>,      * <li> question mark (?) </li>,      * <li> forward slash (/) </li>,      * <li> opening square bracket ([) </li>,      * <li> closing square bracket (]) </li>,      * </ul>,      * The string MUST NOT begin or end with the single quote (') character.,      * </p>,      *,      * @param sheetname  sheetname to set for the sheet.,      * @return Sheet representing the new sheet.,      * @throws IllegalArgumentException if the name is null or invalid,      *  or workbook already contains a sheet with this name,      * @see org.apache.poi.ss.util.WorkbookUtil#createSafeSheetName(String nameProposal),      */,     public HSSFSheet createSheet(String sheetname),     {,         if (sheetname == null) {,             throw new IllegalArgumentException("sheetName must not be null");,         }, ,         if (workbook.doesContainsSheetName( sheetname, _sheets.size() )),             throw new IllegalArgumentException( "The workbook already contains a sheet of this name" );, ,         HSSFSheet sheet = new HSSFSheet(this);, ,         workbook.setSheetName(_sheets.size(), sheetname);,         _sheets.add(sheet);,         boolean isOnlySheet = _sheets.size() == 1;,         sheet.setSelected(isOnlySheet);,         sheet.setActive(isOnlySheet);,         return sheet;,     }, ,     /**,      * get the number of spreadsheets in the workbook (this will be three after serialization),      * @return number of sheets,      */, ,     public int getNumberOfSheets(),     {,         return _sheets.size();,     }, ,     public int getSheetIndexFromExternSheetIndex(int externSheetNumber) {,         return workbook.getSheetIndexFromExternSheetIndex(externSheetNumber);,     }, ,     private HSSFSheet[] getSheets() {,         HSSFSheet[] result = new HSSFSheet[_sheets.size()];,         _sheets.toArray(result);,         return result;,     }, ,     /**,      * Get the HSSFSheet object at the given index.,      * @param index of the sheet number (0-based physical & logical),      * @return HSSFSheet at the provided index,      */, ,     public HSSFSheet getSheetAt(int index),     {,         validateSheetIndex(index);,         return (HSSFSheet) _sheets.get(index);,     }, ,     /**,      * Get sheet with the given name (case insensitive match),      * @param name of the sheet,      * @return HSSFSheet with the name provided or <code>null</code> if it does not exist,      */, ,     public HSSFSheet getSheet(String name),     {,         HSSFSheet retval = null;, ,         for (int k = 0; k < _sheets.size(); k++),         {,             String sheetname = workbook.getSheetName(k);, ,             if (sheetname.equalsIgnoreCase(name)),             {,                 retval = (HSSFSheet) _sheets.get(k);,             },         },         return retval;,     }, ,     /**,      * Removes sheet at the given index.<p/>,      *,      * Care must be taken if the removed sheet is the currently active or only selected sheet in,      * the workbook. There are a few situations when Excel must have a selection and/or active,      * sheet. (For example when printing - see Bug 40414).<br/>,      *,      * This method makes sure that if the removed sheet was active, another sheet will become,      * active in its place.  Furthermore, if the removed sheet was the only selected sheet, another,      * sheet will become selected.  The newly active/selected sheet will have the same index, or,      * one less if the removed sheet was the last in the workbook.,      *,      * @param index of the sheet  (0-based),      */,     public void removeSheetAt(int index) {,         validateSheetIndex(index);,         boolean wasActive = getSheetAt(index).isActive();,         boolean wasSelected = getSheetAt(index).isSelected();, ,         _sheets.remove(index);,         workbook.removeSheet(index);, ,         // set the remaining active/selected sheet,         int nSheets = _sheets.size();,         if (nSheets < 1) {,             // nothing more to do if there are no sheets left,             return;,         },         // the index of the closest remaining sheet to the one just deleted,         int newSheetIndex = index;,         if (newSheetIndex >= nSheets) {,             newSheetIndex = nSheets-1;,         },         if (wasActive) {,             setActiveSheet(newSheetIndex);,         }, ,         if (wasSelected) {,             boolean someOtherSheetIsStillSelected = false;,             for (int i =0; i < nSheets; i++) {,                 if (getSheetAt(i).isSelected()) {,                     someOtherSheetIsStillSelected = true;,                     break;,                 },             },             if (!someOtherSheetIsStillSelected) {,                 setSelectedTab(newSheetIndex);,             },         },     }, ,     /**,      * determine whether the Excel GUI will backup the workbook when saving.,      *,      * @param backupValue   true to indicate a backup will be performed.,      */, ,     public void setBackupFlag(boolean backupValue),     {,         BackupRecord backupRecord = workbook.getBackupRecord();, ,         backupRecord.setBackup(backupValue ? (short) 1,                 : (short) 0);,     }, ,     /**,      * determine whether the Excel GUI will backup the workbook when saving.,      *,      * @return the current setting for backups.,      */, ,     public boolean getBackupFlag(),     {,         BackupRecord backupRecord = workbook.getBackupRecord();, ,         return (backupRecord.getBackup() == 0) ? false,                 : true;,     }, ,     /**,      * Sets the repeating rows and columns for a sheet (as found in,      * 2003:File->PageSetup->Sheet, 2007:Page Layout->Print Titles).,      *   This is function is included in the workbook,      * because it creates/modifies name records which are stored at the,      * workbook level.,      * <p>,      * To set just repeating columns:,      * <pre>,      *  workbook.setRepeatingRowsAndColumns(0,0,1,-1-1);,      * </pre>,      * To set just repeating rows:,      * <pre>,      *  workbook.setRepeatingRowsAndColumns(0,-1,-1,0,4);,      * </pre>,      * To remove all repeating rows and columns for a sheet.,      * <pre>,      *  workbook.setRepeatingRowsAndColumns(0,-1,-1,-1,-1);,      * </pre>,      *,      * @param sheetIndex    0 based index to sheet.,      * @param startColumn   0 based start of repeating columns.,      * @param endColumn     0 based end of repeating columns.,      * @param startRow      0 based start of repeating rows.,      * @param endRow        0 based end of repeating rows.,      */,     public void setRepeatingRowsAndColumns(int sheetIndex,,                                            int startColumn, int endColumn,,                                            int startRow, int endRow),     {,         // Check arguments,         if (startColumn == -1 && endColumn != -1) throw new IllegalArgumentException("Invalid column range specification");,         if (startRow == -1 && endRow != -1) throw new IllegalArgumentException("Invalid row range specification");,         if (startColumn < -1 || startColumn >= MAX_COLUMN) throw new IllegalArgumentException("Invalid column range specification");,         if (endColumn < -1 || endColumn >= MAX_COLUMN) throw new IllegalArgumentException("Invalid column range specification");,         if (startRow < -1 || startRow > MAX_ROW) throw new IllegalArgumentException("Invalid row range specification");,         if (endRow < -1 || endRow > MAX_ROW) throw new IllegalArgumentException("Invalid row range specification");,         if (startColumn > endColumn) throw new IllegalArgumentException("Invalid column range specification");,         if (startRow > endRow) throw new IllegalArgumentException("Invalid row range specification");, ,         HSSFSheet sheet = getSheetAt(sheetIndex);,         short externSheetIndex = getWorkbook().checkExternSheet(sheetIndex);, ,         boolean settingRowAndColumn =,                 startColumn != -1 && endColumn != -1 && startRow != -1 && endRow != -1;,         boolean removingRange =,                 startColumn == -1 && endColumn == -1 && startRow == -1 && endRow == -1;, ,         int rowColHeaderNameIndex = findExistingBuiltinNameRecordIdx(sheetIndex, NameRecord.BUILTIN_PRINT_TITLE);,         if (removingRange) {,             if (rowColHeaderNameIndex >= 0) {,                 workbook.removeName(rowColHeaderNameIndex);,             },             return;,         },         boolean isNewRecord;,         NameRecord nameRecord;,         if (rowColHeaderNameIndex < 0) {,             //does a lot of the house keeping for builtin records, like setting lengths to zero etc,             nameRecord = workbook.createBuiltInName(NameRecord.BUILTIN_PRINT_TITLE, sheetIndex+1);,             isNewRecord = true;,         } else {,             nameRecord = workbook.getNameRecord(rowColHeaderNameIndex);,             isNewRecord = false;,         }, ,         List temp = new ArrayList();, ,         if (settingRowAndColumn) {,             final int exprsSize = 2 * 11 + 1; // 2 * Area3DPtg.SIZE + UnionPtg.SIZE,             temp.add(new MemFuncPtg(exprsSize));,         },         if (startColumn >= 0) {,             Area3DPtg colArea = new Area3DPtg(0, MAX_ROW, startColumn, endColumn,,                     false, false, false, false, externSheetIndex);,             temp.add(colArea);,         },         if (startRow >= 0) {,             Area3DPtg rowArea = new Area3DPtg(startRow, endRow, 0, MAX_COLUMN,,                     false, false, false, false, externSheetIndex);,             temp.add(rowArea);,         },         if (settingRowAndColumn) {,             temp.add(UnionPtg.instance);,         },         Ptg[] ptgs = new Ptg[temp.size()];,         temp.toArray(ptgs);,         nameRecord.setNameDefinition(ptgs);, ,         if (isNewRecord),         {,             HSSFName newName = new HSSFName(this, nameRecord, nameRecord.isBuiltInName() ? null : workbook.getNameCommentRecord(nameRecord));,             names.add(newName);,         }, ,         HSSFPrintSetup printSetup = sheet.getPrintSetup();,         printSetup.setValidSettings(false);, ,         sheet.setActive(true);,     }, , ,     private int findExistingBuiltinNameRecordIdx(int sheetIndex, byte builtinCode) {,         for(int defNameIndex =0; defNameIndex<names.size(); defNameIndex++) {,             NameRecord r = workbook.getNameRecord(defNameIndex);,             if (r == null) {,                 throw new RuntimeException("Unable to find all defined names to iterate over");,             },             if (!r.isBuiltInName() || r.getBuiltInName() != builtinCode) {,                 continue;,             },             if (r.getSheetNumber() -1 == sheetIndex) {,                 return defNameIndex;,             },         },         return -1;,     }, ,     /**,      * create a new Font and add it to the workbook's font table,      * @return new font object,      */, ,     public HSSFFont createFont(),     {,         FontRecord font = workbook.createNewFont();,         short fontindex = (short) (getNumberOfFonts() - 1);, ,         if (fontindex > 3),         {,             fontindex++;   // THERE IS NO FOUR!!,         },         if(fontindex == Short.MAX_VALUE){,             throw new IllegalArgumentException("Maximum number of fonts was exceeded");,         }, ,         // Ask getFontAt() to build it for us,,         //  so it gets properly cached,         return getFontAt(fontindex);,     }, ,     /**,      * Finds a font that matches the one with the supplied attributes,      */,     public HSSFFont findFont(short boldWeight, short color, short fontHeight,,                              String name, boolean italic, boolean strikeout,,                              short typeOffset, byte underline),     {,         for (short i=0; i<=getNumberOfFonts(); i++) {,             // Remember - there is no 4!,             if(i == 4) continue;, ,             HSSFFont hssfFont = getFontAt(i);,             if (hssfFont.getBoldweight() == boldWeight,                     && hssfFont.getColor() == color,                     && hssfFont.getFontHeight() == fontHeight,                     && hssfFont.getFontName().equals(name),                     && hssfFont.getItalic() == italic,                     && hssfFont.getStrikeout() == strikeout,                     && hssfFont.getTypeOffset() == typeOffset,                     && hssfFont.getUnderline() == underline),             {,                 return hssfFont;,             },         }, ,         return null;,     }, ,     /**,      * get the number of fonts in the font table,      * @return number of fonts,      */, ,     public short getNumberOfFonts(),     {,         return (short) workbook.getNumberOfFontRecords();,     }, ,     /**,      * Get the font at the given index number,      * @param idx  index number,      * @return HSSFFont at the index,      */,     public HSSFFont getFontAt(short idx) {,         if(fonts == null) fonts = new Hashtable();, ,         // So we don't confuse users, give them back,         //  the same object every time, but create,         //  them lazily,         Short sIdx = Short.valueOf(idx);,         if(fonts.containsKey(sIdx)) {,             return (HSSFFont)fonts.get(sIdx);,         }, ,         FontRecord font = workbook.getFontRecordAt(idx);,         HSSFFont retval = new HSSFFont(idx, font);,         fonts.put(sIdx, retval);, ,         return retval;,     }, ,     /**,      * Reset the fonts cache, causing all new calls,      *  to getFontAt() to create new objects.,      * Should only be called after deleting fonts,,      *  and that's not something you should normally do,      */,     protected void resetFontCache() {,         fonts = new Hashtable();,     }, ,     /**,      * Create a new Cell style and add it to the workbook's style table.,      * You can define up to 4000 unique styles in a .xls workbook.,      *,      * @return the new Cell Style object,      * @throws IllegalStateException if the maximum number of cell styles exceeded the limit,      */, ,     public HSSFCellStyle createCellStyle(),     {,         if(workbook.getNumExFormats() == MAX_STYLES) {,             throw new IllegalStateException("The maximum number of cell styles was exceeded. " +,                     "You can define up to 4000 styles in a .xls workbook");,         },         ExtendedFormatRecord xfr = workbook.createCellXF();,         short index = (short) (getNumCellStyles() - 1);,         HSSFCellStyle style = new HSSFCellStyle(index, xfr, this);, ,         return style;,     }, ,     /**,      * get the number of styles the workbook contains,      * @return count of cell styles,      */, ,     public short getNumCellStyles(),     {,         return (short) workbook.getNumExFormats();,     }, ,     /**,      * get the cell style object at the given index,      * @param idx  index within the set of styles,      * @return HSSFCellStyle object at the index,      */,     public HSSFCellStyle getCellStyleAt(short idx),     {,         ExtendedFormatRecord xfr = workbook.getExFormatAt(idx);,         HSSFCellStyle style = new HSSFCellStyle(idx, xfr, this);, ,         return style;,     }, ,     /**,      * Method write - write out this workbook to an Outputstream.  Constructs,      * a new POI POIFSFileSystem, passes in the workbook binary representation  and,      * writes it out.,      *,      * @param stream - the java OutputStream you wish to write the XLS to,      *,      * @exception IOException if anything can't be written.,      * @see org.apache.poi.poifs.filesystem.POIFSFileSystem,      */, ,     public void write(OutputStream stream),             throws IOException,     {,         byte[] bytes = getBytes();,         POIFSFileSystem fs = new POIFSFileSystem();, ,         // For tracking what we've written out, used if we're,         //  going to be preserving nodes,         List<String> excepts = new ArrayList<String>(1);, ,         // Write out the Workbook stream,         fs.createDocument(new ByteArrayInputStream(bytes), "Workbook");, ,         // Write out our HPFS properties, if we have them,         writeProperties(fs, excepts);, ,         if (preserveNodes) {,             // Don't write out the old Workbook, we'll be doing our new one,             excepts.add("Workbook");,             // If the file had WORKBOOK instead of Workbook, we'll write it,             //  out correctly shortly, so don't include the old one,             excepts.add("WORKBOOK");, ,             // Copy over all the other nodes to our new poifs,             copyNodes(this.directory, fs.getRoot(), excepts);, ,             // YK: preserve StorageClsid, it is important for embedded workbooks,,             // see Bugzilla 47920,             fs.getRoot().setStorageClsid(this.directory.getStorageClsid());,         },         fs.writeFilesystem(stream);,     }, ,     /**,      * Totals the sizes of all sheet records and eventually serializes them,      */,     private static final class SheetRecordCollector implements RecordVisitor {, ,         private List _list;,         private int _totalSize;, ,         public SheetRecordCollector() {,             _totalSize = 0;,             _list = new ArrayList(128);,         },         public int getTotalSize() {,             return _totalSize;,         },         public void visitRecord(Record r) {,             _list.add(r);,             _totalSize+=r.getRecordSize();,         },         public int serialize(int offset, byte[] data) {,             int result = 0;,             int nRecs = _list.size();,             for(int i=0; i<nRecs; i++) {,                 Record rec = (Record)_list.get(i);,                 result += rec.serialize(offset + result, data);,             },             return result;,         },     }, , ,     /**,      * Method getBytes - get the bytes of just the HSSF portions of the XLS file.,      * Use this to construct a POI POIFSFileSystem yourself.,      *,      *,      * @return byte[] array containing the binary representation of this workbook and all contained,      *         sheets, rows, cells, etc.,      */,     public byte[] getBytes() {,         if (log.check( POILogger.DEBUG )) {,             log.log(DEBUG, "HSSFWorkbook.getBytes()");,         }, ,         HSSFSheet[] sheets = getSheets();,         int nSheets = sheets.length;, ,         // before getting the workbook size we must tell the sheets that,         // serialization is about to occur.,         for (int i = 0; i < nSheets; i++) {,             sheets[i].getSheet().preSerialize();,         }, ,         int totalsize = workbook.getSize();, ,         // pre-calculate all the sheet sizes and set BOF indexes,         SheetRecordCollector[] srCollectors = new SheetRecordCollector[nSheets];,         for (int k = 0; k < nSheets; k++) {,             workbook.setSheetBof(k, totalsize);,             SheetRecordCollector src = new SheetRecordCollector();,             sheets[k].getSheet().visitContainedRecords(src, totalsize);,             totalsize += src.getTotalSize();,             srCollectors[k] = src;,         }, ,         byte[] retval = new byte[totalsize];,         int pos = workbook.serialize(0, retval);, ,         for (int k = 0; k < nSheets; k++) {,             SheetRecordCollector src = srCollectors[k];,             int serializedSize = src.serialize(pos, retval);,             if (serializedSize != src.getTotalSize()) {,                 // Wrong offset values have been passed in the call to setSheetBof() above.,                 // For books with more than one sheet, this discrepancy would cause excel,                 // to report errors and loose data while reading the workbook,                 throw new IllegalStateException("Actual serialized sheet size (" + serializedSize,                         + ") differs from pre-calculated size (" + src.getTotalSize(),                         + ") for sheet (" + k + ")");,                 // TODO - add similar sanity check to ensure that Sheet.serializeIndexRecord() does not write mis-aligned offsets either,             },             pos += serializedSize;,         },         return retval;,     }, ,     /** @deprecated Do not call this method from your applications. Use the methods,      *  available in the HSSFRow to add string HSSFCells,      */,     public int addSSTString(String string),     {,         return workbook.addSSTString(new UnicodeString(string));,     }, ,     /** @deprecated Do not call this method from your applications. Use the methods,      *  available in the HSSFRow to get string HSSFCells,      */,     public String getSSTString(int index),     {,         return workbook.getSSTString(index).getString();,     }, ,     InternalWorkbook getWorkbook() {,         return workbook;,     }, ,     public int getNumberOfNames(){,         int result = names.size();,         return result;,     }, ,     public HSSFName getName(String name) {,         int nameIndex = getNameIndex(name);,         if (nameIndex < 0) {,             return null;,         },         return (HSSFName) names.get(nameIndex);,     }, ,     public HSSFName getNameAt(int nameIndex) {,         int nNames = names.size();,         if (nNames < 1) {,             throw new IllegalStateException("There are no defined names in this workbook");,         },         if (nameIndex < 0 || nameIndex > nNames) {,             throw new IllegalArgumentException("Specified name index " + nameIndex,                     + " is outside the allowable range (0.." + (nNames-1) + ").");,         },         return (HSSFName) names.get(nameIndex);,     }, ,     public NameRecord getNameRecord(int nameIndex) {,         return getWorkbook().getNameRecord(nameIndex);,     }, ,     /** gets the named range name,      * @param index the named range index (0 based),      * @return named range name,      */,     public String getNameName(int index){,         String result = getNameAt(index).getNameName();, ,         return result;,     }, ,     /**,      * Sets the printarea for the sheet provided,      * <p>,      * i.e. Reference = $A$1:$B$2,      * @param sheetIndex Zero-based sheet index (0 Represents the first sheet to keep consistent with java),      * @param reference Valid name Reference for the Print Area,      */,     public void setPrintArea(int sheetIndex, String reference),     {,         NameRecord name = workbook.getSpecificBuiltinRecord(NameRecord.BUILTIN_PRINT_AREA, sheetIndex+1);, , ,         if (name == null) {,             name = workbook.createBuiltInName(NameRecord.BUILTIN_PRINT_AREA, sheetIndex+1);,             // adding one here because 0 indicates a global named region; doesn't make sense for print areas,         },         String[] parts = COMMA_PATTERN.split(reference);,         StringBuffer sb = new StringBuffer(32);,         for (int i = 0; i < parts.length; i++) {,             if(i>0) {,                 sb.append(",");,             },             SheetNameFormatter.appendFormat(sb, getSheetName(sheetIndex));,             sb.append("!");,             sb.append(parts[i]);,         },         name.setNameDefinition(HSSFFormulaParser.parse(sb.toString(), this, FormulaType.NAMEDRANGE, sheetIndex));,     }, ,     /**,      * For the Convenience of Java Programmers maintaining pointers.,      * @see #setPrintArea(int, String),      * @param sheetIndex Zero-based sheet index (0 = First Sheet),      * @param startColumn Column to begin printarea,      * @param endColumn Column to end the printarea,      * @param startRow Row to begin the printarea,      * @param endRow Row to end the printarea,      */,     public void setPrintArea(int sheetIndex, int startColumn, int endColumn,,                               int startRow, int endRow) {, ,         //using absolute references because they don't get copied and pasted anyway,         CellReference cell = new CellReference(startRow, startColumn, true, true);,         String reference = cell.formatAsString();, ,         cell = new CellReference(endRow, endColumn, true, true);,         reference = reference+":"+cell.formatAsString();, ,         setPrintArea(sheetIndex, reference);,     }, , ,     /**,      * Retrieves the reference for the printarea of the specified sheet, the sheet name is appended to the reference even if it was not specified.,      * @param sheetIndex Zero-based sheet index (0 Represents the first sheet to keep consistent with java),      * @return String Null if no print area has been defined,      */,     public String getPrintArea(int sheetIndex) {,         NameRecord name = workbook.getSpecificBuiltinRecord(NameRecord.BUILTIN_PRINT_AREA, sheetIndex+1);,         //adding one here because 0 indicates a global named region; doesn't make sense for print areas,         if (name == null) {,             return null;,         }, ,         return HSSFFormulaParser.toFormulaString(this, name.getNameDefinition());,     }, ,     /**,      * Delete the printarea for the sheet specified,      * @param sheetIndex Zero-based sheet index (0 = First Sheet),      */,     public void removePrintArea(int sheetIndex) {,         getWorkbook().removeBuiltinRecord(NameRecord.BUILTIN_PRINT_AREA, sheetIndex+1);,     }, ,     /** creates a new named range and add it to the model,      * @return named range high level,      */,     public HSSFName createName(){,         NameRecord nameRecord = workbook.createName();, ,         HSSFName newName = new HSSFName(this, nameRecord);, ,         names.add(newName);, ,         return newName;,     }, ,     public int getNameIndex(String name) {, ,         for (int k = 0; k < names.size(); k++) {,             String nameName = getNameName(k);, ,             if (nameName.equalsIgnoreCase(name)) {,                 return k;,             },         },         return -1;,     }, , ,     public void removeName(int index){,         names.remove(index);,         workbook.removeName(index);,     }, ,     /**,      * Returns the instance of HSSFDataFormat for this workbook.,      * @return the HSSFDataFormat object,      * @see org.apache.poi.hssf.record.FormatRecord,      * @see org.apache.poi.hssf.record.Record,      */,     public HSSFDataFormat createDataFormat() {,     if (formatter == null),         formatter = new HSSFDataFormat(workbook);,     return formatter;,     }, , ,     public void removeName(String name) {,         int index = getNameIndex(name);, ,         removeName(index);,     }, ,     public HSSFPalette getCustomPalette(),     {,         return new HSSFPalette(workbook.getCustomPalette());,     }, ,     /** Test only. Do not use */,     public void insertChartRecord(),     {,         int loc = workbook.findFirstRecordLocBySid(SSTRecord.sid);,         byte[] data = {,            (byte)0x0F, (byte)0x00, (byte)0x00, (byte)0xF0, (byte)0x52,,            (byte)0x00, (byte)0x00, (byte)0x00, (byte)0x00, (byte)0x00,,            (byte)0x06, (byte)0xF0, (byte)0x18, (byte)0x00, (byte)0x00,,            (byte)0x00, (byte)0x01, (byte)0x08, (byte)0x00, (byte)0x00,,            (byte)0x02, (byte)0x00, (byte)0x00, (byte)0x00, (byte)0x02,,            (byte)0x00, (byte)0x00, (byte)0x00, (byte)0x01, (byte)0x00,,            (byte)0x00, (byte)0x00, (byte)0x01, (byte)0x00, (byte)0x00,,            (byte)0x00, (byte)0x03, (byte)0x00, (byte)0x00, (byte)0x00,,            (byte)0x33, (byte)0x00, (byte)0x0B, (byte)0xF0, (byte)0x12,,            (byte)0x00, (byte)0x00, (byte)0x00, (byte)0xBF, (byte)0x00,,            (byte)0x08, (byte)0x00, (byte)0x08, (byte)0x00, (byte)0x81,,            (byte)0x01, (byte)0x09, (byte)0x00, (byte)0x00, (byte)0x08,,            (byte)0xC0, (byte)0x01, (byte)0x40, (byte)0x00, (byte)0x00,,            (byte)0x08, (byte)0x40, (byte)0x00, (byte)0x1E, (byte)0xF1,,            (byte)0x10, (byte)0x00, (byte)0x00, (byte)0x00, (byte)0x0D,,            (byte)0x00, (byte)0x00, (byte)0x08, (byte)0x0C, (byte)0x00,,            (byte)0x00, (byte)0x08, (byte)0x17, (byte)0x00, (byte)0x00,,            (byte)0x08, (byte)0xF7, (byte)0x00, (byte)0x00, (byte)0x10,,         };,         UnknownRecord r = new UnknownRecord((short)0x00EB, data);,         workbook.getRecords().add(loc, r);,     }, ,     /**,      * Spits out a list of all the drawing records in the workbook.,      */,     public void dumpDrawingGroupRecords(boolean fat),     {,         DrawingGroupRecord r = (DrawingGroupRecord) workbook.findFirstRecordBySid( DrawingGroupRecord.sid );,         r.decode();,         List escherRecords = r.getEscherRecords();,         PrintWriter w = new PrintWriter(System.out);,         for ( Iterator iterator = escherRecords.iterator(); iterator.hasNext(); ),         {,             EscherRecord escherRecord = (EscherRecord) iterator.next();,             if (fat),                 System.out.println(escherRecord.toString());,             else,                 escherRecord.display(w, 0);,         },         w.flush();,     }, ,     void initDrawings(){,         DrawingManager2 mgr = workbook.findDrawingGroup();,         if(mgr != null) {,             for(int i=0; i < getNumberOfSheets(); i++)  {,                 getSheetAt(i).getDrawingPatriarch();,             },         } else {,             workbook.createDrawingGroup();,         },     }, ,     /**,      * Adds a picture to the workbook.,      *,      * @param pictureData       The bytes of the picture,      * @param format            The format of the picture.  One of <code>PICTURE_TYPE_*</code>,      *,      * @return the index to this picture (1 based).,      */,     public int addPicture(byte[] pictureData, int format),     {,         initDrawings();,         ,         byte[] uid = DigestUtils.md5(pictureData);,         EscherBitmapBlip blipRecord = new EscherBitmapBlip();,         blipRecord.setRecordId( (short) ( EscherBitmapBlip.RECORD_ID_START + format ) );,         switch (format),         {,             case PICTURE_TYPE_EMF:,                 blipRecord.setOptions(HSSFPictureData.MSOBI_EMF);,                 break;,             case PICTURE_TYPE_WMF:,                 blipRecord.setOptions(HSSFPictureData.MSOBI_WMF);,                 break;,             case PICTURE_TYPE_PICT:,                 blipRecord.setOptions(HSSFPictureData.MSOBI_PICT);,                 break;,             case PICTURE_TYPE_PNG:,                 blipRecord.setOptions(HSSFPictureData.MSOBI_PNG);,                 break;,             case HSSFWorkbook.PICTURE_TYPE_JPEG:,                 blipRecord.setOptions(HSSFPictureData.MSOBI_JPEG);,                 break;,             case HSSFWorkbook.PICTURE_TYPE_DIB:,                 blipRecord.setOptions(HSSFPictureData.MSOBI_DIB);,                 break;,         }, ,         blipRecord.setUID( uid );,         blipRecord.setMarker( (byte) 0xFF );,         blipRecord.setPictureData( pictureData );, ,         EscherBSERecord r = new EscherBSERecord();,         r.setRecordId( EscherBSERecord.RECORD_ID );,         r.setOptions( (short) ( 0x0002 | ( format << 4 ) ) );,         r.setBlipTypeMacOS( (byte) format );,         r.setBlipTypeWin32( (byte) format );,         r.setUid( uid );,         r.setTag( (short) 0xFF );,         r.setSize( pictureData.length + 25 );,         r.setRef( 1 );,         r.setOffset( 0 );,         r.setBlipRecord( blipRecord );, ,         return workbook.addBSERecord( r );,     }, ,     /**,      * Gets all pictures from the Workbook.,      *,      * @return the list of pictures (a list of {@link HSSFPictureData} objects.),      */,     public List<HSSFPictureData> getAllPictures(),     {,         // The drawing group record always exists at the top level, so we won't need to do this recursively.,         List<HSSFPictureData> pictures = new ArrayList<HSSFPictureData>();,         Iterator<Record> recordIter = workbook.getRecords().iterator();,         while (recordIter.hasNext()),         {,             Record r = recordIter.next();,             if (r instanceof AbstractEscherHolderRecord),             {,                 ((AbstractEscherHolderRecord) r).decode();,                 List<EscherRecord> escherRecords = ((AbstractEscherHolderRecord) r).getEscherRecords();,                 searchForPictures(escherRecords, pictures);,             },         },         return pictures;,     }, ,     /**,      * Performs a recursive search for pictures in the given list of escher records.,      *,      * @param escherRecords the escher records.,      * @param pictures the list to populate with the pictures.,      */,     private void searchForPictures(List<EscherRecord> escherRecords, List<HSSFPictureData> pictures),     {,         for(EscherRecord escherRecord : escherRecords) {, ,             if (escherRecord instanceof EscherBSERecord),             {,                 EscherBlipRecord blip = ((EscherBSERecord) escherRecord).getBlipRecord();,                 if (blip != null),                 {,                     // TODO: Some kind of structure.,                     HSSFPictureData picture = new HSSFPictureData(blip);, 					pictures.add(picture);,                 },                 ,                 ,             }, ,             // Recursive call.,             searchForPictures(escherRecord.getChildRecords(), pictures);,         },         ,     }, ,     /**,      * Is the workbook protected with a password (not encrypted)?,      */,     public boolean isWriteProtected() {,         return this.workbook.isWriteProtected();,     }, ,     /**,      * protect a workbook with a password (not encypted, just sets writeprotect,      * flags and the password.,      * @param password to set,      */,     public void writeProtectWorkbook( String password, String username ) {,        this.workbook.writeProtectWorkbook(password, username);,     }, ,     /**,      * removes the write protect flag,      */,     public void unwriteProtectWorkbook() {,        this.workbook.unwriteProtectWorkbook();,     }, ,     /**,      * Gets all embedded OLE2 objects from the Workbook.,      *,      * @return the list of embedded objects (a list of {@link HSSFObjectData} objects.),      */,     public List<HSSFObjectData> getAllEmbeddedObjects(),     {,         List<HSSFObjectData> objects = new ArrayList<HSSFObjectData>();,         for (int i = 0; i < getNumberOfSheets(); i++),         {,             getAllEmbeddedObjects(getSheetAt(i).getSheet().getRecords(), objects);,         },         return objects;,     }, ,     /**,      * Gets all embedded OLE2 objects from the Workbook.,      *,      * @param records the list of records to search.,      * @param objects the list of embedded objects to populate.,      */,     private void getAllEmbeddedObjects(List<RecordBase> records, List<HSSFObjectData> objects),     {,        for (RecordBase obj : records) {,           if (obj instanceof ObjRecord),           {,              // TODO: More convenient way of determining if there is stored binary.,              // TODO: Link to the data stored in the other stream.,              Iterator<SubRecord> subRecordIter = ((ObjRecord) obj).getSubRecords().iterator();,              while (subRecordIter.hasNext()),              {,                 SubRecord sub = subRecordIter.next();,                 if (sub instanceof EmbeddedObjectRefSubRecord),                 {,                    objects.add(new HSSFObjectData((ObjRecord) obj, directory));,                 },              },           },        },     }, ,     public HSSFCreationHelper getCreationHelper() {,         return new HSSFCreationHelper(this);,     }, ,     /**,      *,      * Returns the locator of user-defined functions.,      * The default instance extends the built-in functions with the Analysis Tool Pack,      *,      * @return the locator of user-defined functions,      */,     /*package*/ UDFFinder getUDFFinder(){,         return _udfFinder;,     }, ,     /**,      * Register a new toolpack in this workbook.,      *,      * @param toopack the toolpack to register,      */,     public void addToolPack(UDFFinder toopack){,         AggregatingUDFFinder udfs = (AggregatingUDFFinder)_udfFinder;,         udfs.add(toopack);,     }, ,     /**,      * Whether the application shall perform a full recalculation when the workbook is opened.,      * <p>,      * Typically you want to force formula recalculation when you modify cell formulas or values,      * of a workbook previously created by Excel. When set to true, this flag will tell Excel,      * that it needs to recalculate all formulas in the workbook the next time the file is opened.,      * </p>,      * <p>,      * Note, that recalculation updates cached formula results and, thus, modifies the workbook.,      * Depending on the version, Excel may prompt you with "Do you want to save the changes in <em>filename</em>?",      * on close.,      * </p>,      *,      * @param value true if the application will perform a full recalculation of,      * workbook values when the workbook is opened,      * @since 3.8,      */,     public void setForceFormulaRecalculation(boolean value){,         InternalWorkbook iwb = getWorkbook();,         RecalcIdRecord recalc = iwb.getRecalcId();,         recalc.setEngineId(0);,     }, ,     /**,      * Whether Excel will be asked to recalculate all formulas when the  workbook is opened.,      *,      * @since 3.8,      */,     public boolean getForceFormulaRecalculation(){,         InternalWorkbook iwb = getWorkbook();,         RecalcIdRecord recalc = (RecalcIdRecord)iwb.findFirstRecordBySid(RecalcIdRecord.sid);,         return recalc != null && recalc.getEngineId() != 0;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/poi/hssf/view/SVTableCellRenderer.java,,56-125,[      private DecimalFormat generalNumberFormat = new DecimalFormat("0");, ,       public CellFormatter() {,         textFormatter = new Format[0x31];, ,         textFormatter[0x01] = new DecimalFormat("0");,         textFormatter[0x02] = new DecimalFormat("0.00");,         textFormatter[0x03] = new DecimalFormat("#,##0");,         textFormatter[0x04] = new DecimalFormat("#,##0.00");,         textFormatter[0x05] = new DecimalFormat("$#,##0;$#,##0");,         textFormatter[0x06] = new DecimalFormat("$#,##0;$#,##0");,         textFormatter[0x07] = new DecimalFormat("$#,##0.00;$#,##0.00");,         textFormatter[0x08] = new DecimalFormat("$#,##0.00;$#,##0.00");,         textFormatter[0x09] = new DecimalFormat("0%");,         textFormatter[0x0A] = new DecimalFormat("0.00%");,         textFormatter[0x0B] = new DecimalFormat("0.00E0");,         textFormatter[0x0C] = new SVFractionalFormat("# ?/?");,         textFormatter[0x0D] = new SVFractionalFormat("# ??/??");,         textFormatter[0x0E] = new SimpleDateFormat("M/d/yy");,         textFormatter[0x0F] = new SimpleDateFormat("d-MMM-yy");,         textFormatter[0x10] = new SimpleDateFormat("d-MMM");,         textFormatter[0x11] = new SimpleDateFormat("MMM-yy");,         textFormatter[0x12] = new SimpleDateFormat("h:mm a");,         textFormatter[0x13] = new SimpleDateFormat("h:mm:ss a");,         textFormatter[0x14] = new SimpleDateFormat("h:mm");,         textFormatter[0x15] = new SimpleDateFormat("h:mm:ss");,         textFormatter[0x16] = new SimpleDateFormat("M/d/yy h:mm");,         // 0x17 - 0x24 reserved for international and undocumented 0x25, "(#,##0_);(#,##0)",         //start at 0x26,         //jmh need to do colour,         //"(#,##0_);[Red](#,##0)",         textFormatter[0x26] = new DecimalFormat("#,##0;#,##0");,         //jmh need to do colour,         //(#,##0.00_);(#,##0.00),         textFormatter[0x27] = new DecimalFormat("#,##0.00;#,##0.00");,         textFormatter[0x28] = new DecimalFormat("#,##0.00;#,##0.00");, //??        textFormatter[0x29] = new DecimalFormat("_(*#,##0_);_(*(#,##0);_(* \"-\"_);_(@_)");, //??        textFormatter[0x2A] = new DecimalFormat("_($*#,##0_);_($*(#,##0);_($* \"-\"_);_(@_)");, //??        textFormatter[0x2B] = new DecimalFormat("_(*#,##0.00_);_(*(#,##0.00);_(*\"-\"??_);_(@_)");, //??        textFormatter[0x2C] = new DecimalFormat("_($*#,##0.00_);_($*(#,##0.00);_($*\"-\"??_);_(@_)");,         textFormatter[0x2D] = new SimpleDateFormat("mm:ss");, //??        textFormatter[0x2E] = new SimpleDateFormat("[h]:mm:ss");,         textFormatter[0x2F] = new SimpleDateFormat("mm:ss.0");,         textFormatter[0x30] = new DecimalFormat("##0.0E0");,       }, ,       public String format(short index, Object value) {,         if (index == 0),           return value.toString();,         if (textFormatter[index] == null),           throw new RuntimeException("Sorry. I cant handle the format code :"+Integer.toHexString(index));,         return textFormatter[index].format(value);,       }, ,       public String format(short index, double value) {,         if ( index <= 0 ),           return generalNumberFormat.format(value);,         if (textFormatter[index] == null),           throw new RuntimeException("Sorry. I cant handle the format code :"+Integer.toHexString(index));,         if (textFormatter[index] instanceof DecimalFormat) {,           return ((DecimalFormat)textFormatter[index]).format(value);,         },         if (textFormatter[index] instanceof SVFractionalFormat) {,           return ((SVFractionalFormat)textFormatter[index]).format(value);,         },         throw new RuntimeException("Sorry. I cant handle a non decimal formatter for a decimal value :"+Integer.toHexString(index));,       }, ,       public boolean useRedColor(short index, double value) {,         return (((index == 0x06)||(index == 0x08)||(index == 0x26) || (index == 0x27)) && (value < 0));],,
BAD_PRACTICE,SE_BAD_FIELD,org/apache/poi/hssf/usermodel/HSSFSheet.java,,65-1986,[public final class HSSFSheet implements org.apache.poi.ss.usermodel.Sheet {,     private static final POILogger log = POILogFactory.getLogger(HSSFSheet.class);,     private static final int DEBUG = POILogger.DEBUG;, ,     /**,      * Used for compile-time optimization.  This is the initial size for the collection of,      * rows.  It is currently set to 20.  If you generate larger sheets you may benefit,      * by setting this to a higher number and recompiling a custom edition of HSSFSheet.,      */,     public final static int INITIAL_CAPACITY = 20;, ,     /**,      * reference to the low level {@link InternalSheet} object,      */,     private final InternalSheet _sheet;,     /** stores rows by zero-based row number */,     private final TreeMap<Integer, HSSFRow> _rows;,     protected final InternalWorkbook _book;,     protected final HSSFWorkbook _workbook;,     private HSSFPatriarch _patriarch;,     private int _firstrow;,     private int _lastrow;, ,     /**,      * Creates new HSSFSheet   - called by HSSFWorkbook to create a sheet from,      * scratch.  You should not be calling this from application code (its protected anyhow).,      *,      * @param workbook - The HSSF Workbook object associated with the sheet.,      * @see org.apache.poi.hssf.usermodel.HSSFWorkbook#createSheet(),      */,     protected HSSFSheet(HSSFWorkbook workbook) {,         _sheet = InternalSheet.createSheet();,         _rows = new TreeMap<Integer, HSSFRow>();,         this._workbook = workbook;,         this._book = workbook.getWorkbook();,     }, ,     /**,      * Creates an HSSFSheet representing the given Sheet object.  Should only be,      * called by HSSFWorkbook when reading in an exisiting file.,      *,      * @param workbook - The HSSF Workbook object associated with the sheet.,      * @param sheet - lowlevel Sheet object this sheet will represent,      * @see org.apache.poi.hssf.usermodel.HSSFWorkbook#createSheet(),      */,     protected HSSFSheet(HSSFWorkbook workbook, InternalSheet sheet) {,         this._sheet = sheet;,         _rows = new TreeMap<Integer, HSSFRow>();,         this._workbook = workbook;,         this._book = workbook.getWorkbook();,         setPropertiesFromSheet(sheet);,     }, ,     HSSFSheet cloneSheet(HSSFWorkbook workbook) {,       return new HSSFSheet(workbook, _sheet.cloneSheet());,     }, ,     /**,      * Return the parent workbook,      *,      * @return the parent workbook,      */,     public HSSFWorkbook getWorkbook(){,         return _workbook;,     }, ,     /**,      * used internally to set the properties given a Sheet object,      */,     private void setPropertiesFromSheet(InternalSheet sheet) {, ,         RowRecord row = sheet.getNextRow();,         boolean rowRecordsAlreadyPresent = row!=null;, ,         while (row != null) {,             createRowFromRecord(row);, ,             row = sheet.getNextRow();,         }, ,         Iterator<CellValueRecordInterface> iter = sheet.getCellValueIterator();,         long timestart = System.currentTimeMillis();, ,         if (log.check( POILogger.DEBUG )),             log.log(DEBUG, "Time at start of cell creating in HSSF sheet = ",,                 Long.valueOf(timestart));,         HSSFRow lastrow = null;, ,         // Add every cell to its row,         while (iter.hasNext()) {,             CellValueRecordInterface cval = iter.next();, ,             long cellstart = System.currentTimeMillis();,             HSSFRow hrow = lastrow;, ,             if (hrow == null || hrow.getRowNum() != cval.getRow()) {,                 hrow = getRow( cval.getRow() );,                 lastrow = hrow;,                 if (hrow == null) {,                     // Some tools (like Perl module Spreadsheet::WriteExcel - bug 41187) skip the RowRecords,                     // Excel, OpenOffice.org and GoogleDocs are all OK with this, so POI should be too.,                     if (rowRecordsAlreadyPresent) {,                         // if at least one row record is present, all should be present.,                         throw new RuntimeException("Unexpected missing row when some rows already present");,                     },                     // create the row record on the fly now.,                     RowRecord rowRec = new RowRecord(cval.getRow());,                     sheet.addRow(rowRec);,                     hrow = createRowFromRecord(rowRec);,                 },             },             if (log.check( POILogger.DEBUG )),                 log.log( DEBUG, "record id = " + Integer.toHexString( ( (Record) cval ).getSid() ) );,             hrow.createCellFromRecord( cval );,             if (log.check( POILogger.DEBUG )),                 log.log( DEBUG, "record took ",,                     Long.valueOf( System.currentTimeMillis() - cellstart ) );, ,         },         if (log.check( POILogger.DEBUG )),             log.log(DEBUG, "total sheet cell creation took ",,                 Long.valueOf(System.currentTimeMillis() - timestart));,     }, ,     /**,      * Create a new row within the sheet and return the high level representation,      *,      * @param rownum  row number,      * @return High level HSSFRow object representing a row in the sheet,      * @see org.apache.poi.hssf.usermodel.HSSFRow,      * @see #removeRow(org.apache.poi.ss.usermodel.Row),      */,     public HSSFRow createRow(int rownum),     {,         HSSFRow row = new HSSFRow(_workbook, this, rownum);, ,         addRow(row, true);,         return row;,     }, ,     /**,      * Used internally to create a high level Row object from a low level row object.,      * USed when reading an existing file,      * @param row  low level record to represent as a high level Row and add to sheet,      * @return HSSFRow high level representation,      */, ,     private HSSFRow createRowFromRecord(RowRecord row),     {,         HSSFRow hrow = new HSSFRow(_workbook, this, row);, ,         addRow(hrow, false);,         return hrow;,     }, ,     /**,      * Remove a row from this sheet.  All cells contained in the row are removed as well,      *,      * @param row   representing a row to remove.,      */,     public void removeRow(Row row) {,         HSSFRow hrow = (HSSFRow) row;,         if (row.getSheet() != this) {,             throw new IllegalArgumentException("Specified row does not belong to this sheet");,         },         for(Cell cell : row) {,             HSSFCell xcell = (HSSFCell)cell;,             if(xcell.isPartOfArrayFormulaGroup()){,                 String msg = "Row[rownum="+row.getRowNum()+"] contains cell(s) included in a multi-cell array formula. You cannot change part of an array.";,                 xcell.notifyArrayFormulaChanging(msg);,             },         }, ,         if (_rows.size() > 0) {,             Integer key = Integer.valueOf(row.getRowNum());,             HSSFRow removedRow = _rows.remove(key);,             if (removedRow != row) {,                 //should not happen if the input argument is valid,                 throw new IllegalArgumentException("Specified row does not belong to this sheet");,             },             if (hrow.getRowNum() == getLastRowNum()),             {,                 _lastrow = findLastRow(_lastrow);,             },             if (hrow.getRowNum() == getFirstRowNum()),             {,                 _firstrow = findFirstRow(_firstrow);,             },             _sheet.removeRow(hrow.getRowRecord());,         },     }, ,     /**,      * used internally to refresh the "last row" when the last row is removed.,      */,     private int findLastRow(int lastrow) {,         if (lastrow < 1) {,             return 0;,         },         int rownum = lastrow - 1;,         HSSFRow r = getRow(rownum);, ,         while (r == null && rownum > 0) {,             r = getRow(--rownum);,         },         if (r == null) {,             return 0;,         },         return rownum;,     }, ,     /**,      * used internally to refresh the "first row" when the first row is removed.,      */, ,     private int findFirstRow(int firstrow),     {,         int rownum = firstrow + 1;,         HSSFRow r = getRow(rownum);, ,         while (r == null && rownum <= getLastRowNum()),         {,             r = getRow(++rownum);,         }, ,         if (rownum > getLastRowNum()),             return 0;, ,         return rownum;,     }, ,     /**,      * add a row to the sheet,      *,      * @param addLow whether to add the row to the low level model - false if its already there,      */, ,     private void addRow(HSSFRow row, boolean addLow),     {,         _rows.put(Integer.valueOf(row.getRowNum()), row);,         if (addLow),         {,             _sheet.addRow(row.getRowRecord());,         },         boolean firstRow = _rows.size() == 1;,         if (row.getRowNum() > getLastRowNum() || firstRow),         {,             _lastrow = row.getRowNum();,         },         if (row.getRowNum() < getFirstRowNum() || firstRow),         {,             _firstrow = row.getRowNum();,         },     }, ,     /**,      * Returns the logical row (not physical) 0-based.  If you ask for a row that is not,      * defined you get a null.  This is to say row 4 represents the fifth row on a sheet.,      * @param rowIndex  row to get,      * @return HSSFRow representing the row number or null if its not defined on the sheet,      */,     public HSSFRow getRow(int rowIndex) {,         return _rows.get(Integer.valueOf(rowIndex));,     }, ,     /**,      * Returns the number of physically defined rows (NOT the number of rows in the sheet),      */,     public int getPhysicalNumberOfRows() {,         return _rows.size();,     }, ,     /**,      * Gets the first row on the sheet,      * @return the number of the first logical row on the sheet, zero based,      */,     public int getFirstRowNum() {,         return _firstrow;,     }, ,     /**,      * Gets the number last row on the sheet.,      * Owing to idiosyncrasies in the excel file,      *  format, if the result of calling this method,      *  is zero, you can't tell if that means there,      *  are zero rows on the sheet, or one at,      *  position zero. For that case, additionally,      *  call {@link #getPhysicalNumberOfRows()} to,      *  tell if there is a row at position zero,      *  or not.,      * @return the number of the last row contained in this sheet, zero based.,      */,     public int getLastRowNum() {,         return _lastrow;,     }, ,     /**,      * Creates a data validation object,      * @param dataValidation The Data validation object settings,      */,     public void addValidationData(DataValidation dataValidation) {,        if (dataValidation == null) {,            throw new IllegalArgumentException("objValidation must not be null");,        },        HSSFDataValidation hssfDataValidation = (HSSFDataValidation)dataValidation;,        DataValidityTable dvt = _sheet.getOrCreateDataValidityTable();, ,        DVRecord dvRecord = hssfDataValidation.createDVRecord(this);,        dvt.addDataValidation(dvRecord);,     }, , ,     /**,      * @deprecated (Sep 2008) use {@link #setColumnHidden(int, boolean)},      */,     public void setColumnHidden(short columnIndex, boolean hidden) {,         setColumnHidden(columnIndex & 0xFFFF, hidden);,     }, ,     /**,      * @deprecated (Sep 2008) use {@link #isColumnHidden(int)},      */,     public boolean isColumnHidden(short columnIndex) {,         return isColumnHidden(columnIndex & 0xFFFF);,     }, ,     /**,      * @deprecated (Sep 2008) use {@link #setColumnWidth(int, int)},      */,     public void setColumnWidth(short columnIndex, short width) {,         setColumnWidth(columnIndex & 0xFFFF, width & 0xFFFF);,     }, ,     /**,      * @deprecated (Sep 2008) use {@link #getColumnWidth(int)},      */,     public short getColumnWidth(short columnIndex) {,         return (short)getColumnWidth(columnIndex & 0xFFFF);,     }, ,     /**,      * @deprecated (Sep 2008) use {@link #setDefaultColumnWidth(int)},      */,     public void setDefaultColumnWidth(short width) {,         setDefaultColumnWidth(width & 0xFFFF);,     }, ,     /**,      * Get the visibility state for a given column.,      * @param columnIndex - the column to get (0-based),      * @param hidden - the visiblity state of the column,      */,     public void setColumnHidden(int columnIndex, boolean hidden) {,         _sheet.setColumnHidden(columnIndex, hidden);,     }, ,     /**,      * Get the hidden state for a given column.,      * @param columnIndex - the column to set (0-based),      * @return hidden - <code>false</code> if the column is visible,      */,     public boolean isColumnHidden(int columnIndex) {,         return _sheet.isColumnHidden(columnIndex);,     }, ,     /**,      * Set the width (in units of 1/256th of a character width),      *,      * <p>,      * The maximum column width for an individual cell is 255 characters.,      * This value represents the number of characters that can be displayed,      * in a cell that is formatted with the standard font (first font in the workbook).,      * </p>,      *,      * <p>,      * Character width is defined as the maximum digit width,      * of the numbers <code>0, 1, 2, ... 9</code> as rendered,      * using the default font (first font in the workbook).,      * <br/>,      * Unless you are using a very special font, the default character is '0' (zero),,      * this is true for Arial (default font font in HSSF) and Calibri (default font in XSSF),      * </p>,      *,      * <p>,      * Please note, that the width set by this method includes 4 pixels of margin padding (two on each side),,      * plus 1 pixel padding for the gridlines (Section 3.3.1.12 of the OOXML spec).,      * This results is a slightly less value of visible characters than passed to this method (approx. 1/2 of a character).,      * </p>,      * <p>,      * To compute the actual number of visible characters,,      *  Excel uses the following formula (Section 3.3.1.12 of the OOXML spec):,      * </p>,      * <code>,      *     width = Truncate([{Number of Visible Characters} *,      *      {Maximum Digit Width} + {5 pixel padding}]/{Maximum Digit Width}*256)/256,      * </code>,      * <p>Using the Calibri font as an example, the maximum digit width of 11 point font size is 7 pixels (at 96 dpi).,      *  If you set a column width to be eight characters wide, e.g. <code>setColumnWidth(columnIndex, 8*256)</code>,,      *  then the actual value of visible characters (the value shown in Excel) is derived from the following equation:,      *  <code>,             Truncate([numChars*7+5]/7*256)/256 = 8;,      *  </code>,      *,      *  which gives <code>7.29</code>.,      *,      * @param columnIndex - the column to set (0-based),      * @param width - the width in units of 1/256th of a character width,      * @throws IllegalArgumentException if width > 255*256 (the maximum column width in Excel is 255 characters),      */,     public void setColumnWidth(int columnIndex, int width) {,         _sheet.setColumnWidth(columnIndex, width);,     }, ,     /**,      * get the width (in units of 1/256th of a character width ),      * @param columnIndex - the column to set (0-based),      * @return width - the width in units of 1/256th of a character width,      */,     public int getColumnWidth(int columnIndex) {,         return _sheet.getColumnWidth(columnIndex);,     }, ,     /**,      * get the default column width for the sheet (if the columns do not define their own width) in,      * characters,      * @return default column width,      */,     public int getDefaultColumnWidth() {,         return _sheet.getDefaultColumnWidth();,     },     /**,      * set the default column width for the sheet (if the columns do not define their own width) in,      * characters,      * @param width default column width,      */,     public void setDefaultColumnWidth(int width) {,         _sheet.setDefaultColumnWidth(width);,     }, , ,     /**,      * get the default row height for the sheet (if the rows do not define their own height) in,      * twips (1/20 of  a point),      * @return  default row height,      */,     public short getDefaultRowHeight() {,         return _sheet.getDefaultRowHeight();,     }, ,     /**,      * get the default row height for the sheet (if the rows do not define their own height) in,      * points.,      * @return  default row height in points,      */, ,     public float getDefaultRowHeightInPoints(),     {,         return ((float)_sheet.getDefaultRowHeight() / 20);,     }, ,     /**,      * set the default row height for the sheet (if the rows do not define their own height) in,      * twips (1/20 of  a point),      * @param  height default row height,      */, ,     public void setDefaultRowHeight(short height),     {,         _sheet.setDefaultRowHeight(height);,     }, ,     /**,      * set the default row height for the sheet (if the rows do not define their own height) in,      * points,      * @param height default row height,      */, ,     public void setDefaultRowHeightInPoints(float height),     {,         _sheet.setDefaultRowHeight((short) (height * 20));,     }, ,     /**,      * Returns the HSSFCellStyle that applies to the given,      *  (0 based) column, or null if no style has been,      *  set for that column,      */,     public HSSFCellStyle getColumnStyle(int column) {,         short styleIndex = _sheet.getXFIndexForColAt((short)column);, ,         if(styleIndex == 0xf) {,             // None set,             return null;,         }, ,         ExtendedFormatRecord xf = _book.getExFormatAt(styleIndex);,         return new HSSFCellStyle(styleIndex, xf, _book);,     }, ,     /**,      * get whether gridlines are printed.,      * @return true if printed,      */, ,     public boolean isGridsPrinted(),     {,         return _sheet.isGridsPrinted();,     }, ,     /**,      * set whether gridlines printed.,      * @param value  false if not printed.,      */, ,     public void setGridsPrinted(boolean value),     {,         _sheet.setGridsPrinted(value);,     }, ,     /**,      * @deprecated (Aug-2008) use <tt>CellRangeAddress</tt> instead of <tt>Region</tt>,      */,     public int addMergedRegion(org.apache.poi.ss.util.Region region),     {,         return _sheet.addMergedRegion( region.getRowFrom(),,                 region.getColumnFrom(),,                 //(short) region.getRowTo(),,                 region.getRowTo(),,                 region.getColumnTo());,     },     /**,      * adds a merged region of cells (hence those cells form one),      * @param region (rowfrom/colfrom-rowto/colto) to merge,      * @return index of this region,      */,     public int addMergedRegion(CellRangeAddress region),     {,         region.validate(SpreadsheetVersion.EXCEL97);, ,         // throw IllegalStateException if the argument CellRangeAddress intersects with,         // a multi-cell array formula defined in this sheet,         validateArrayFormulas(region);, ,         return _sheet.addMergedRegion( region.getFirstRow(),,                 region.getFirstColumn(),,                 region.getLastRow(),,                 region.getLastColumn());,     }, ,     private void validateArrayFormulas(CellRangeAddress region){,         int firstRow = region.getFirstRow();,         int firstColumn = region.getFirstColumn();,         int lastRow = region.getLastRow();,         int lastColumn = region.getLastColumn();,         for (int rowIn = firstRow; rowIn <= lastRow; rowIn++) {,             for (int colIn = firstColumn; colIn <= lastColumn; colIn++) {,                 HSSFRow row = getRow(rowIn);,                 if (row == null) continue;, ,                 HSSFCell cell = row.getCell(colIn);,                 if(cell == null) continue;, ,                 if(cell.isPartOfArrayFormulaGroup()){,                     CellRangeAddress arrayRange = cell.getArrayFormulaRange();,                     if (arrayRange.getNumberOfCells() > 1 &&,                             ( arrayRange.isInRange(region.getFirstRow(), region.getFirstColumn()) ||,                               arrayRange.isInRange(region.getFirstRow(), region.getFirstColumn()))  ){,                         String msg = "The range " + region.formatAsString() + " intersects with a multi-cell array formula. " +,                                 "You cannot merge cells of an array.";,                         throw new IllegalStateException(msg);,                     },                 },             },         }, ,     }, ,     /**,      * Control if Excel should be asked to recalculate all formulas on this sheet,      * when the workbook is opened.,      *,      *  <p>,      *  Calculating the formula values with {@link org.apache.poi.ss.usermodel.FormulaEvaluator} is the,      *  recommended solution, but this may be used for certain cases where,      *  evaluation in POI is not possible.,      *  </p>,      *,      *  <p>,      *  It is recommended to force recalcuation of formulas on workbook level using,      *  {@link org.apache.poi.ss.usermodel.Workbook#setForceFormulaRecalculation(boolean)},      *  to ensure that all cross-worksheet formuals and external dependencies are updated.,      *  </p>,      * @param value true if the application will perform a full recalculation of,      * this worksheet values when the workbook is opened,      *,      * @see org.apache.poi.ss.usermodel.Workbook#setForceFormulaRecalculation(boolean),      */,     public void setForceFormulaRecalculation(boolean value),     {,         _sheet.setUncalced(value);,     },     /**,      * Whether a record must be inserted or not at generation to indicate that,      * formula must be recalculated when workbook is opened.,      * @return true if an uncalced record must be inserted or not at generation,      */,     public boolean getForceFormulaRecalculation(),     {,         return _sheet.getUncalced();,     }, , ,     /**,      * determines whether the output is vertically centered on the page.,      * @param value true to vertically center, false otherwise.,      */, ,     public void setVerticallyCenter(boolean value),     {,         _sheet.getPageSettings().getVCenter().setVCenter(value);,     }, ,     /**,      * TODO: Boolean not needed, remove after next release,      * @deprecated (Mar-2008) use getVerticallyCenter() instead,      */,     public boolean getVerticallyCenter(boolean value) {,         return getVerticallyCenter();,     }, ,     /**,      * Determine whether printed output for this sheet will be vertically centered.,      */,     public boolean getVerticallyCenter(),     {,         return _sheet.getPageSettings().getVCenter().getVCenter();,     }, ,     /**,      * determines whether the output is horizontally centered on the page.,      * @param value true to horizontally center, false otherwise.,      */, ,     public void setHorizontallyCenter(boolean value),     {,         _sheet.getPageSettings().getHCenter().setHCenter(value);,     }, ,     /**,      * Determine whether printed output for this sheet will be horizontally centered.,      */, ,     public boolean getHorizontallyCenter(),     {, ,         return _sheet.getPageSettings().getHCenter().getHCenter();,     }, ,     /**,      * Sets whether the worksheet is displayed from right to left instead of from left to right.,      *,      * @param value true for right to left, false otherwise.,      */,     public void setRightToLeft(boolean value),     {,         _sheet.getWindowTwo().setArabic(value);,     }, ,     /**,      * Whether the text is displayed in right-to-left mode in the window,      *,      * @return whether the text is displayed in right-to-left mode in the window,      */,     public boolean isRightToLeft(),     {,         return _sheet.getWindowTwo().getArabic();,     }, ,     /**,      * removes a merged region of cells (hence letting them free),      * @param index of the region to unmerge,      */, ,     public void removeMergedRegion(int index),     {,         _sheet.removeMergedRegion(index);,     }, ,     /**,      * returns the number of merged regions,      * @return number of merged regions,      */, ,     public int getNumMergedRegions(),     {,         return _sheet.getNumMergedRegions();,     }, ,     /**,      * @deprecated (Aug-2008) use {@link HSSFSheet#getMergedRegion(int)},      */,     public Region getMergedRegionAt(int index) {,         CellRangeAddress cra = getMergedRegion(index);, ,         return new Region(cra.getFirstRow(), (short)cra.getFirstColumn(),,                 cra.getLastRow(), (short)cra.getLastColumn());,     },     /**,      * @return the merged region at the specified index,      */,     public CellRangeAddress getMergedRegion(int index) {,         return _sheet.getMergedRegionAt(index);,     }, ,     /**,      * @return an iterator of the PHYSICAL rows.  Meaning the 3rd element may not,      * be the third row if say for instance the second row is undefined.,      * Call getRowNum() on each row if you care which one it is.,      */,     public Iterator<Row> rowIterator() {,         @SuppressWarnings("unchecked") // can this clumsy generic syntax be improved?,         Iterator<Row> result = (Iterator<Row>)(Iterator<? extends Row>)_rows.values().iterator();,         return result;,     },     /**,      * Alias for {@link #rowIterator()} to allow,      *  foreach loops,      */,     public Iterator<Row> iterator() {,         return rowIterator();,     }, , ,     /**,      * used internally in the API to get the low level Sheet record represented by this,      * Object.,      * @return Sheet - low level representation of this HSSFSheet.,      */,     InternalSheet getSheet() {,         return _sheet;,     }, ,     /**,      * whether alternate expression evaluation is on,      * @param b  alternative expression evaluation or not,      */,     public void setAlternativeExpression(boolean b) {,         WSBoolRecord record =,                 (WSBoolRecord) _sheet.findFirstRecordBySid(WSBoolRecord.sid);, ,         record.setAlternateExpression(b);,     }, ,     /**,      * whether alternative formula entry is on,      * @param b  alternative formulas or not,      */,     public void setAlternativeFormula(boolean b) {,         WSBoolRecord record =,                 (WSBoolRecord) _sheet.findFirstRecordBySid(WSBoolRecord.sid);, ,         record.setAlternateFormula(b);,     }, ,     /**,      * show automatic page breaks or not,      * @param b  whether to show auto page breaks,      */,     public void setAutobreaks(boolean b) {,         WSBoolRecord record =,                 (WSBoolRecord) _sheet.findFirstRecordBySid(WSBoolRecord.sid);, ,         record.setAutobreaks(b);,     }, ,     /**,      * set whether sheet is a dialog sheet or not,      * @param b  isDialog or not,      */,     public void setDialog(boolean b) {,         WSBoolRecord record =,                 (WSBoolRecord) _sheet.findFirstRecordBySid(WSBoolRecord.sid);, ,         record.setDialog(b);,     }, ,     /**,      * set whether to display the guts or not,      *,      * @param b  guts or no guts (or glory),      */,     public void setDisplayGuts(boolean b) {,         WSBoolRecord record =,                 (WSBoolRecord) _sheet.findFirstRecordBySid(WSBoolRecord.sid);, ,         record.setDisplayGuts(b);,     }, ,     /**,      * fit to page option is on,      * @param b  fit or not,      */,     public void setFitToPage(boolean b) {,         WSBoolRecord record =,                 (WSBoolRecord) _sheet.findFirstRecordBySid(WSBoolRecord.sid);, ,         record.setFitToPage(b);,     }, ,     /**,      * set if row summaries appear below detail in the outline,      * @param b  below or not,      */,     public void setRowSumsBelow(boolean b) {,         WSBoolRecord record =,                 (WSBoolRecord) _sheet.findFirstRecordBySid(WSBoolRecord.sid);, ,         record.setRowSumsBelow(b);,         //setAlternateExpression must be set in conjuction with setRowSumsBelow,         record.setAlternateExpression(b);,     }, ,     /**,      * set if col summaries appear right of the detail in the outline,      * @param b  right or not,      */,     public void setRowSumsRight(boolean b) {,         WSBoolRecord record =,                 (WSBoolRecord) _sheet.findFirstRecordBySid(WSBoolRecord.sid);, ,         record.setRowSumsRight(b);,     }, ,     /**,      * whether alternate expression evaluation is on,      * @return alternative expression evaluation or not,      */,     public boolean getAlternateExpression() {,         return ((WSBoolRecord) _sheet.findFirstRecordBySid(WSBoolRecord.sid)),                 .getAlternateExpression();,     }, ,     /**,      * whether alternative formula entry is on,      * @return alternative formulas or not,      */,     public boolean getAlternateFormula() {,         return ((WSBoolRecord) _sheet.findFirstRecordBySid(WSBoolRecord.sid)),                 .getAlternateFormula();,     }, ,     /**,      * show automatic page breaks or not,      * @return whether to show auto page breaks,      */,     public boolean getAutobreaks() {,         return ((WSBoolRecord) _sheet.findFirstRecordBySid(WSBoolRecord.sid)),                 .getAutobreaks();,     }, ,     /**,      * get whether sheet is a dialog sheet or not,      * @return isDialog or not,      */,     public boolean getDialog() {,         return ((WSBoolRecord) _sheet.findFirstRecordBySid(WSBoolRecord.sid)),                 .getDialog();,     }, ,     /**,      * get whether to display the guts or not,      *,      * @return guts or no guts (or glory),      */,     public boolean getDisplayGuts() {,         return ((WSBoolRecord) _sheet.findFirstRecordBySid(WSBoolRecord.sid)),                 .getDisplayGuts();,     }, , ,     /**,      * Gets the flag indicating whether the window should show 0 (zero) in cells containing zero value.,      * When false, cells with zero value appear blank instead of showing the number zero.,      * <p>,      * In Excel 2003 this option can be changed in the Options dialog on the View tab.,      * </p>,      * @return whether all zero values on the worksheet are displayed,      */,     public boolean isDisplayZeros(){,         return _sheet.getWindowTwo().getDisplayZeros();,     }, ,     /**,      * Set whether the window should show 0 (zero) in cells containing zero value.,      * When false, cells with zero value appear blank instead of showing the number zero.,      * <p>,      * In Excel 2003 this option can be set in the Options dialog on the View tab.,      * </p>,      * @param value whether to display or hide all zero values on the worksheet,      */,     public void setDisplayZeros(boolean value){,         _sheet.getWindowTwo().setDisplayZeros(value);,     }, ,     /**,      * fit to page option is on,      * @return fit or not,      */,     public boolean getFitToPage() {,         return ((WSBoolRecord) _sheet.findFirstRecordBySid(WSBoolRecord.sid)),                 .getFitToPage();,     }, ,     /**,      * get if row summaries appear below detail in the outline,      * @return below or not,      */,     public boolean getRowSumsBelow() {,         return ((WSBoolRecord) _sheet.findFirstRecordBySid(WSBoolRecord.sid)),                 .getRowSumsBelow();,     }, ,     /**,      * get if col summaries appear right of the detail in the outline,      * @return right or not,      */,     public boolean getRowSumsRight() {,         return ((WSBoolRecord) _sheet.findFirstRecordBySid(WSBoolRecord.sid)),                 .getRowSumsRight();,     }, ,     /**,      * Returns whether gridlines are printed.,      * @return Gridlines are printed,      */,     public boolean isPrintGridlines() {,         return getSheet().getPrintGridlines().getPrintGridlines();,     }, ,     /**,      * Turns on or off the printing of gridlines.,      * @param newPrintGridlines boolean to turn on or off the printing of,      * gridlines,      */,     public void setPrintGridlines(boolean newPrintGridlines) {,         getSheet().getPrintGridlines().setPrintGridlines(newPrintGridlines);,     }, ,     /**,      * Gets the print setup object.,      * @return The user model for the print setup object.,      */,     public HSSFPrintSetup getPrintSetup() {,         return new HSSFPrintSetup(_sheet.getPageSettings().getPrintSetup());,     }, ,     public HSSFHeader getHeader() {,         return new HSSFHeader(_sheet.getPageSettings());,     }, ,     public HSSFFooter getFooter() {,         return new HSSFFooter(_sheet.getPageSettings());,     }, ,     /**,      * Note - this is not the same as whether the sheet is focused (isActive),      * @return <code>true</code> if this sheet is currently selected,      */,     public boolean isSelected() {,         return getSheet().getWindowTwo().getSelected();,     },     /**,      * Sets whether sheet is selected.,      * @param sel Whether to select the sheet or deselect the sheet.,      */,     public void setSelected(boolean sel) {,         getSheet().getWindowTwo().setSelected(sel);,     },     /**,      * @return <code>true</code> if this sheet is currently focused,      */,     public boolean isActive() {,         return getSheet().getWindowTwo().isActive();,     },     /**,      * Sets whether sheet is selected.,      * @param sel Whether to select the sheet or deselect the sheet.,      */,     public void setActive(boolean sel) {,         getSheet().getWindowTwo().setActive(sel);,     }, ,     /**,      * Gets the size of the margin in inches.,      * @param margin which margin to get,      * @return the size of the margin,      */,     public double getMargin(short margin) {,         return _sheet.getPageSettings().getMargin(margin);,     }, ,     /**,      * Sets the size of the margin in inches.,      * @param margin which margin to get,      * @param size the size of the margin,      */,     public void setMargin(short margin, double size) {,         _sheet.getPageSettings().setMargin(margin, size);,     }, ,     private WorksheetProtectionBlock getProtectionBlock() {,         return _sheet.getProtectionBlock();,     },     /**,      * Answer whether protection is enabled or disabled,      * @return true => protection enabled; false => protection disabled,      */,     public boolean getProtect() {,         return getProtectionBlock().isSheetProtected();,     }, ,     /**,      * @return hashed password,      */,     public short getPassword() {,         return (short)getProtectionBlock().getPasswordHash();,     }, ,     /**,      * Answer whether object protection is enabled or disabled,      * @return true => protection enabled; false => protection disabled,      */,     public boolean getObjectProtect() {,         return getProtectionBlock().isObjectProtected();,     }, ,     /**,      * Answer whether scenario protection is enabled or disabled,      * @return true => protection enabled; false => protection disabled,      */,     public boolean getScenarioProtect() {,         return getProtectionBlock().isScenarioProtected();,     },     /**,      * Sets the protection enabled as well as the password,      * @param password to set for protection. Pass <code>null</code> to remove protection,      */,     public void protectSheet(String password) {,         getProtectionBlock().protectSheet(password, true, true); //protect objs&scenarios(normal),     }, ,     /**,      * Sets the zoom magnification for the sheet.  The zoom is expressed as a,      * fraction.  For example to express a zoom of 75% use 3 for the numerator,      * and 4 for the denominator.,      *,      * @param numerator     The numerator for the zoom magnification.,      * @param denominator   The denominator for the zoom magnification.,      */,     public void setZoom( int numerator, int denominator),     {,         if (numerator < 1 || numerator > 65535),             throw new IllegalArgumentException("Numerator must be greater than 1 and less than 65536");,         if (denominator < 1 || denominator > 65535),             throw new IllegalArgumentException("Denominator must be greater than 1 and less than 65536");, ,         SCLRecord sclRecord = new SCLRecord();,         sclRecord.setNumerator((short)numerator);,         sclRecord.setDenominator((short)denominator);,         getSheet().setSCLRecord(sclRecord);,     }, ,     /**,      * The top row in the visible view when the sheet is,      * first viewed after opening it in a viewer,      * @return short indicating the rownum (0 based) of the top row,      */,     public short getTopRow() {,         return _sheet.getTopRow();,     }, ,     /**,      * The left col in the visible view when the sheet is,      * first viewed after opening it in a viewer,      * @return short indicating the rownum (0 based) of the top row,      */,     public short getLeftCol() {,         return _sheet.getLeftCol();,     }, ,     /**,      * Sets desktop window pane display area, when the,      * file is first opened in a viewer.,      * @param toprow the top row to show in desktop window pane,      * @param leftcol the left column to show in desktop window pane,      */,     public void showInPane(short toprow, short leftcol){,         _sheet.setTopRow(toprow);,         _sheet.setLeftCol(leftcol);,     }, ,     /**,      * Shifts the merged regions left or right depending on mode,      * <p>,      * TODO: MODE , this is only row specific,      * @param startRow,      * @param endRow,      * @param n,      * @param isRow,      */,     protected void shiftMerged(int startRow, int endRow, int n, boolean isRow) {,         List<CellRangeAddress> shiftedRegions = new ArrayList<CellRangeAddress>();,         //move merged regions completely if they fall within the new region boundaries when they are shifted,         for (int i = 0; i < getNumMergedRegions(); i++) {,              CellRangeAddress merged = getMergedRegion(i);, ,              boolean inStart= (merged.getFirstRow() >= startRow || merged.getLastRow() >= startRow);,              boolean inEnd  = (merged.getFirstRow() <= endRow   || merged.getLastRow() <= endRow);, ,              //don't check if it's not within the shifted area,              if (!inStart || !inEnd) {,                 continue;,              }, ,              //only shift if the region outside the shifted rows is not merged too,              if (!SheetUtil.containsCell(merged, startRow-1, 0) &&,                  !SheetUtil.containsCell(merged, endRow+1, 0)){,                  merged.setFirstRow(merged.getFirstRow()+n);,                  merged.setLastRow(merged.getLastRow()+n);,                  //have to remove/add it back,                  shiftedRegions.add(merged);,                  removeMergedRegion(i);,                  i = i -1; // we have to back up now since we removed one,              },         }, ,         //read so it doesn't get shifted again,         Iterator<CellRangeAddress> iterator = shiftedRegions.iterator();,         while (iterator.hasNext()) {,             CellRangeAddress region = iterator.next();, ,             this.addMergedRegion(region);,         },     }, ,     /**,      * Shifts rows between startRow and endRow n number of rows.,      * If you use a negative number, it will shift rows up.,      * Code ensures that rows don't wrap around.,      *,      * Calls shiftRows(startRow, endRow, n, false, false);,      *,      * <p>,      * Additionally shifts merged regions that are completely defined in these,      * rows (ie. merged 2 cells on a row to be shifted).,      * @param startRow the row to start shifting,      * @param endRow the row to end shifting,      * @param n the number of rows to shift,      */,     public void shiftRows( int startRow, int endRow, int n ) {,         shiftRows(startRow, endRow, n, false, false);,     }, ,     /**,      * Shifts rows between startRow and endRow n number of rows.,      * If you use a negative number, it will shift rows up.,      * Code ensures that rows don't wrap around,      *,      * <p>,      * Additionally shifts merged regions that are completely defined in these,      * rows (ie. merged 2 cells on a row to be shifted).,      * <p>,      * TODO Might want to add bounds checking here,      * @param startRow the row to start shifting,      * @param endRow the row to end shifting,      * @param n the number of rows to shift,      * @param copyRowHeight whether to copy the row height during the shift,      * @param resetOriginalRowHeight whether to set the original row's height to the default,      */,     public void shiftRows( int startRow, int endRow, int n, boolean copyRowHeight, boolean resetOriginalRowHeight) {,         shiftRows(startRow, endRow, n, copyRowHeight, resetOriginalRowHeight, true);,     }, ,     /**,      * Shifts rows between startRow and endRow n number of rows.,      * If you use a negative number, it will shift rows up.,      * Code ensures that rows don't wrap around,      *,      * <p>,      * Additionally shifts merged regions that are completely defined in these,      * rows (ie. merged 2 cells on a row to be shifted).,      * <p>,      * TODO Might want to add bounds checking here,      * @param startRow the row to start shifting,      * @param endRow the row to end shifting,      * @param n the number of rows to shift,      * @param copyRowHeight whether to copy the row height during the shift,      * @param resetOriginalRowHeight whether to set the original row's height to the default,      * @param moveComments whether to move comments at the same time as the cells they are attached to,      */,     public void shiftRows(int startRow, int endRow, int n,,             boolean copyRowHeight, boolean resetOriginalRowHeight, boolean moveComments) {,         int s, inc;,         if (n < 0) {,             s = startRow;,             inc = 1;,         } else if (n > 0) {,             s = endRow;,             inc = -1;,         } else {,            // Nothing to do,            return;,         },         ,         NoteRecord[] noteRecs;,         if (moveComments) {,             noteRecs = _sheet.getNoteRecords();,         } else {,             noteRecs = NoteRecord.EMPTY_ARRAY;,         }, ,         shiftMerged(startRow, endRow, n, true);,         _sheet.getPageSettings().shiftRowBreaks(startRow, endRow, n);, ,         for ( int rowNum = s; rowNum >= startRow && rowNum <= endRow && rowNum >= 0 && rowNum < 65536; rowNum += inc ) {,             HSSFRow row = getRow( rowNum );,             // notify all cells in this row that we are going to shift them,,             // it can throw IllegalStateException if the operation is not allowed, for example,,             // if the row contains cells included in a multi-cell array formula,             if(row != null) notifyRowShifting(row);, ,             HSSFRow row2Replace = getRow( rowNum + n );,             if ( row2Replace == null ),                 row2Replace = createRow( rowNum + n );, , ,             // Remove all the old cells from the row we'll,             //  be writing too, before we start overwriting,             //  any cells. This avoids issues with cells,             //  changing type, and records not being correctly,             //  overwritten,             row2Replace.removeAllCells();, ,             // If this row doesn't exist, nothing needs to,             //  be done for the now empty destination row,             if (row == null) continue; // Nothing to do for this row, ,             // Fix up row heights if required,             if (copyRowHeight) {,                 row2Replace.setHeight(row.getHeight());,             },             if (resetOriginalRowHeight) {,                 row.setHeight((short)0xff);,             }, ,             // Copy each cell from the source row to,             //  the destination row,             for(Iterator<Cell> cells = row.cellIterator(); cells.hasNext(); ) {,                 HSSFCell cell = (HSSFCell)cells.next();,                 row.removeCell( cell );,                 CellValueRecordInterface cellRecord = cell.getCellValueRecord();,                 cellRecord.setRow( rowNum + n );,                 row2Replace.createCellFromRecord( cellRecord );,                 _sheet.addValueRecord( rowNum + n, cellRecord );, ,                 HSSFHyperlink link = cell.getHyperlink();,                 if(link != null){,                     link.setFirstRow(link.getFirstRow() + n);,                     link.setLastRow(link.getLastRow() + n);,                 },             },             // Now zap all the cells in the source row,             row.removeAllCells();, ,             // Move comments from the source row to the,             //  destination row. Note that comments can,             //  exist for cells which are null,             if(moveComments) {,                 // This code would get simpler if NoteRecords could be organised by HSSFRow.,                 for(int i=noteRecs.length-1; i>=0; i--) {,                     NoteRecord nr = noteRecs[i];,                     if (nr.getRow() != rowNum) {,                         continue;,                     },                     HSSFComment comment = getCellComment(rowNum, nr.getColumn());,                     if (comment != null) {,                        comment.setRow(rowNum + n);,                     },                 },             },         },         ,         // Re-compute the first and last rows of the sheet as needed,         if(n > 0) {,            // Rows are moving down,            if ( startRow == _firstrow ) {,               // Need to walk forward to find the first non-blank row,               _firstrow = Math.max( startRow + n, 0 );,               for( int i=startRow+1; i < startRow+n; i++ ) {,                  if (getRow(i) != null) {,                     _firstrow = i;,                     break;,                  },               },            },            if ( endRow + n > _lastrow ) {,               _lastrow = Math.min( endRow + n, SpreadsheetVersion.EXCEL97.getLastRowIndex() );,            },         } else {,            // Rows are moving up,            if ( startRow + n < _firstrow ) {,               _firstrow = Math.max( startRow + n, 0 );,            },            if ( endRow == _lastrow  ) {,               // Need to walk backward to find the last non-blank row,               _lastrow = Math.min( endRow + n, SpreadsheetVersion.EXCEL97.getLastRowIndex() );,               for (int i=endRow-1; i > endRow+n; i++) {,                  if (getRow(i) != null) {,                     _lastrow = i;,                     break;,                  },               },            },         }, ,         // Update any formulas on this sheet that point to,         //  rows which have been moved,         int sheetIndex = _workbook.getSheetIndex(this);,         short externSheetIndex = _book.checkExternSheet(sheetIndex);,         FormulaShifter shifter = FormulaShifter.createForRowShift(externSheetIndex, startRow, endRow, n);,         _sheet.updateFormulasAfterCellShift(shifter, externSheetIndex);, ,         int nSheets = _workbook.getNumberOfSheets();,         for(int i=0; i<nSheets; i++) {,             InternalSheet otherSheet = _workbook.getSheetAt(i).getSheet();,             if (otherSheet == this._sheet) {,                 continue;,             },             short otherExtSheetIx = _book.checkExternSheet(i);,             otherSheet.updateFormulasAfterCellShift(shifter, otherExtSheetIx);,         },         _workbook.getWorkbook().updateNamesAfterCellShift(shifter);,     }, ,     protected void insertChartRecords(List<Record> records) {,         int window2Loc = _sheet.findFirstRecordLocBySid(WindowTwoRecord.sid);,         _sheet.getRecords().addAll(window2Loc, records);,     }, ,     private void notifyRowShifting(HSSFRow row){,         String msg = "Row[rownum="+row.getRowNum()+"] contains cell(s) included in a multi-cell array formula. " +,                 "You cannot change part of an array.";,         for(Cell cell : row){,             HSSFCell hcell = (HSSFCell)cell;,             if(hcell.isPartOfArrayFormulaGroup()){,                 hcell.notifyArrayFormulaChanging(msg);,             },         },     }, ,     /**,      * Creates a split (freezepane). Any existing freezepane or split pane is overwritten.,      *,      * <p>,      *     If both colSplit and rowSplit are zero then the existing freeze pane is removed,      * </p>,      *,      * @param colSplit      Horizonatal position of split.,      * @param rowSplit      Vertical position of split.,      * @param leftmostColumn   Left column visible in right pane.,      * @param topRow        Top row visible in bottom pane,      */,     public void createFreezePane(int colSplit, int rowSplit, int leftmostColumn, int topRow) {,         validateColumn(colSplit);,         validateRow(rowSplit);,         if (leftmostColumn < colSplit) throw new IllegalArgumentException("leftmostColumn parameter must not be less than colSplit parameter");,         if (topRow < rowSplit) throw new IllegalArgumentException("topRow parameter must not be less than leftmostColumn parameter");,         getSheet().createFreezePane( colSplit, rowSplit, topRow, leftmostColumn );,     }, ,     /**,      * Creates a split (freezepane). Any existing freezepane or split pane is overwritten.,      *,      * <p>,      *     If both colSplit and rowSplit are zero then the existing freeze pane is removed,      * </p>,      *,      * @param colSplit      Horizonatal position of split.,      * @param rowSplit      Vertical position of split.,      */,     public void createFreezePane(int colSplit, int rowSplit) {,         createFreezePane(colSplit, rowSplit, colSplit, rowSplit);,     }, ,     /**,      * Creates a split pane. Any existing freezepane or split pane is overwritten.,      * @param xSplitPos      Horizonatal position of split (in 1/20th of a point).,      * @param ySplitPos      Vertical position of split (in 1/20th of a point).,      * @param topRow        Top row visible in bottom pane,      * @param leftmostColumn   Left column visible in right pane.,      * @param activePane    Active pane.  One of: PANE_LOWER_RIGHT,,      *                      PANE_UPPER_RIGHT, PANE_LOWER_LEFT, PANE_UPPER_LEFT,      * @see #PANE_LOWER_LEFT,      * @see #PANE_LOWER_RIGHT,      * @see #PANE_UPPER_LEFT,      * @see #PANE_UPPER_RIGHT,      */,     public void createSplitPane(int xSplitPos, int ySplitPos, int leftmostColumn, int topRow, int activePane) {,         getSheet().createSplitPane( xSplitPos, ySplitPos, topRow, leftmostColumn, activePane );,     }, ,     /**,      * Returns the information regarding the currently configured pane (split or freeze).,      * @return null if no pane configured, or the pane information.,      */,     public PaneInformation getPaneInformation() {,         return getSheet().getPaneInformation();,     }, ,     /**,      * Sets whether the gridlines are shown in a viewer.,      * @param show whether to show gridlines or not,      */,     public void setDisplayGridlines(boolean show) {,         _sheet.setDisplayGridlines(show);,     }, ,     /**,      * Returns if gridlines are displayed.,      * @return whether gridlines are displayed,      */,     public boolean isDisplayGridlines() {,     return _sheet.isDisplayGridlines();,     }, ,     /**,      * Sets whether the formulas are shown in a viewer.,      * @param show whether to show formulas or not,      */,     public void setDisplayFormulas(boolean show) {,         _sheet.setDisplayFormulas(show);,     }, ,     /**,      * Returns if formulas are displayed.,      * @return whether formulas are displayed,      */,     public boolean isDisplayFormulas() {,         return _sheet.isDisplayFormulas();,     }, ,     /**,      * Sets whether the RowColHeadings are shown in a viewer.,      * @param show whether to show RowColHeadings or not,      */,     public void setDisplayRowColHeadings(boolean show) {,         _sheet.setDisplayRowColHeadings(show);,     }, ,     /**,      * Returns if RowColHeadings are displayed.,      * @return whether RowColHeadings are displayed,      */,     public boolean isDisplayRowColHeadings() {,         return _sheet.isDisplayRowColHeadings();,     }, ,     /**,      * Sets a page break at the indicated row,      * Breaks occur above the specified row and left of the specified column inclusive.,      *,      * For example, <code>sheet.setColumnBreak(2);</code> breaks the sheet into two parts,      * with columns A,B,C in the first and D,E,... in the second. Simuilar, <code>sheet.setRowBreak(2);</code>,      * breaks the sheet into two parts with first three rows (rownum=1...3) in the first part,      * and rows starting with rownum=4 in the second.,      *,      * @param row the row to break, inclusive,      */,     public void setRowBreak(int row) {,         validateRow(row);,         _sheet.getPageSettings().setRowBreak(row, (short)0, (short)255);,     }, ,     /**,      * @return <code>true</code> if there is a page break at the indicated row,      */,     public boolean isRowBroken(int row) {,         return _sheet.getPageSettings().isRowBroken(row);,     }, ,     /**,      * Removes the page break at the indicated row,      */,     public void removeRowBreak(int row) {,         _sheet.getPageSettings().removeRowBreak(row);,     }, ,     /**,      * @return row indexes of all the horizontal page breaks, never <code>null</code>,      */,     public int[] getRowBreaks() {,         //we can probably cache this information, but this should be a sparsely used function,         return _sheet.getPageSettings().getRowBreaks();,     }, ,     /**,      * @return column indexes of all the vertical page breaks, never <code>null</code>,      */,     public int[] getColumnBreaks() {,         //we can probably cache this information, but this should be a sparsely used function,         return _sheet.getPageSettings().getColumnBreaks();,     }, , ,     /**,      * Sets a page break at the indicated column.,      * Breaks occur above the specified row and left of the specified column inclusive.,      *,      * For example, <code>sheet.setColumnBreak(2);</code> breaks the sheet into two parts,      * with columns A,B,C in the first and D,E,... in the second. Simuilar, <code>sheet.setRowBreak(2);</code>,      * breaks the sheet into two parts with first three rows (rownum=1...3) in the first part,      * and rows starting with rownum=4 in the second.,      *,      * @param column the column to break, inclusive,      */,     public void setColumnBreak(int column) {,         validateColumn((short)column);,         _sheet.getPageSettings().setColumnBreak((short)column, (short)0, (short) SpreadsheetVersion.EXCEL97.getLastRowIndex());,     }, ,     /**,      * Determines if there is a page break at the indicated column,      * @param column FIXME: Document this!,      * @return FIXME: Document this!,      */,     public boolean isColumnBroken(int column) {,         return _sheet.getPageSettings().isColumnBroken(column);,     }, ,     /**,      * Removes a page break at the indicated column,      * @param column,      */,     public void removeColumnBreak(int column) {,         _sheet.getPageSettings().removeColumnBreak(column);,     }, ,     /**,      * Runs a bounds check for row numbers,      * @param row,      */,     protected void validateRow(int row) {,         int maxrow = SpreadsheetVersion.EXCEL97.getLastRowIndex();,         if (row > maxrow) throw new IllegalArgumentException("Maximum row number is " + maxrow);,         if (row < 0) throw new IllegalArgumentException("Minumum row number is 0");,     }, ,     /**,      * Runs a bounds check for column numbers,      * @param column,      */,     protected void validateColumn(int column) {,         int maxcol = SpreadsheetVersion.EXCEL97.getLastColumnIndex();,         if (column > maxcol) throw new IllegalArgumentException("Maximum column number is " + maxcol);,         if (column < 0)    throw new IllegalArgumentException("Minimum column number is 0");,     }, ,     /**,      * Aggregates the drawing records and dumps the escher record hierarchy,      * to the standard output.,      */,     public void dumpDrawingRecords(boolean fat) {,         _sheet.aggregateDrawingRecords(_book.getDrawingManager(), false);, ,         EscherAggregate r = (EscherAggregate) getSheet().findFirstRecordBySid(EscherAggregate.sid);,         List<EscherRecord> escherRecords = r.getEscherRecords();,         PrintWriter w = new PrintWriter(System.out);,         for (Iterator<EscherRecord> iterator = escherRecords.iterator(); iterator.hasNext();) {,             EscherRecord escherRecord = iterator.next();,             if (fat) {,                 System.out.println(escherRecord.toString());,             } else {,                 escherRecord.display(w, 0);,             },         },         w.flush();,     }, ,     /**,      * Creates the top-level drawing patriarch.  This will have,      *  the effect of removing any existing drawings on this,      *  sheet.,      * This may then be used to add graphics or charts,      * @return  The new patriarch.,      */,     public HSSFPatriarch createDrawingPatriarch() {,         if(_patriarch == null){,             // Create the drawing group if it doesn't already exist.,             _workbook.initDrawings();, ,             if(_patriarch == null){,                 _sheet.aggregateDrawingRecords(_book.getDrawingManager(), true);,                 EscherAggregate agg = (EscherAggregate) _sheet.findFirstRecordBySid(EscherAggregate.sid);,                 _patriarch = new HSSFPatriarch(this, agg);,                 agg.setPatriarch(_patriarch);,             },         },         return _patriarch;,     }, ,     /**,      * Returns the agregate escher records for this sheet,,      *  it there is one.,      * WARNING - calling this will trigger a parsing of the,      *  associated escher records. Any that aren't supported,      *  (such as charts and complex drawing types) will almost,      *  certainly be lost or corrupted when written out.,      */,     public EscherAggregate getDrawingEscherAggregate() {,         _book.findDrawingGroup();, ,         // If there's now no drawing manager, then there's,         //  no drawing escher records on the workbook,         if(_book.getDrawingManager() == null) {,             return null;,         }, ,         int found = _sheet.aggregateDrawingRecords(,                 _book.getDrawingManager(), false,         );,         if(found == -1) {,             // Workbook has drawing stuff, but this sheet doesn't,             return null;,         }, ,         // Grab our aggregate record, and wire it up,         EscherAggregate agg = (EscherAggregate) _sheet.findFirstRecordBySid(EscherAggregate.sid);,         return agg;,     }, ,     /**,      * Returns the top-level drawing patriach, if there is,      *  one.,      * This will hold any graphics or charts for the sheet.,      * WARNING - calling this will trigger a parsing of the,      *  associated escher records. Any that aren't supported,      *  (such as charts and complex drawing types) will almost,      *  certainly be lost or corrupted when written out. Only,      *  use this with simple drawings, otherwise call,      *  {@link HSSFSheet#createDrawingPatriarch()} and,      *  start from scratch!,      */,     public HSSFPatriarch getDrawingPatriarch() {,         if(_patriarch != null) return _patriarch;,         ,         EscherAggregate agg = getDrawingEscherAggregate();,         if(agg == null) return null;, ,         _patriarch = new HSSFPatriarch(this, agg);,         agg.setPatriarch(_patriarch);, ,         // Have it process the records into high level objects,         //  as best it can do (this step may eat anything,         //  that isn't supported, you were warned...),         agg.convertRecordsToUserModel();, ,         // Return what we could cope with,         return _patriarch;,     }, ,     /**,      * @deprecated (Sep 2008) use {@link #setColumnGroupCollapsed(int, boolean)},      */,     public void setColumnGroupCollapsed(short columnNumber, boolean collapsed) {,         setColumnGroupCollapsed(columnNumber & 0xFFFF, collapsed);,     },     /**,      * @deprecated (Sep 2008) use {@link #groupColumn(int, int)},      */,     public void groupColumn(short fromColumn, short toColumn) {,         groupColumn(fromColumn & 0xFFFF, toColumn & 0xFFFF);,     },     /**,      * @deprecated (Sep 2008) use {@link #ungroupColumn(int, int)},      */,     public void ungroupColumn(short fromColumn, short toColumn) {,         ungroupColumn(fromColumn & 0xFFFF, toColumn & 0xFFFF);,     }, ,     /**,      * Expands or collapses a column group.,      *,      * @param columnNumber      One of the columns in the group.,      * @param collapsed         true = collapse group, false = expand group.,      */,     public void setColumnGroupCollapsed(int columnNumber, boolean collapsed) {,         _sheet.setColumnGroupCollapsed(columnNumber, collapsed);,     }, ,     /**,      * Create an outline for the provided column range.,      *,      * @param fromColumn        beginning of the column range.,      * @param toColumn          end of the column range.,      */,     public void groupColumn(int fromColumn, int toColumn) {,         _sheet.groupColumnRange(fromColumn, toColumn, true);,     }, ,     public void ungroupColumn(int fromColumn, int toColumn) {,         _sheet.groupColumnRange(fromColumn, toColumn, false);,     }, ,     /**,      * Tie a range of cell together so that they can be collapsed or expanded,      *,      * @param fromRow   start row (0-based),      * @param toRow     end row (0-based),      */,     public void groupRow(int fromRow, int toRow) {,         _sheet.groupRowRange(fromRow, toRow, true);,     }, ,     public void ungroupRow(int fromRow, int toRow) {,         _sheet.groupRowRange(fromRow, toRow, false);,     }, ,     public void setRowGroupCollapsed(int rowIndex, boolean collapse) {,         if (collapse) {,             _sheet.getRowsAggregate().collapseRow(rowIndex);,         } else {,             _sheet.getRowsAggregate().expandRow(rowIndex);,         },     }, ,     /**,      * Sets the default column style for a given column.  POI will only apply this style to new cells added to the sheet.,      *,      * @param column the column index,      * @param style the style to set,      */,     public void setDefaultColumnStyle(int column, CellStyle style) {,         _sheet.setDefaultColumnStyle(column, ((HSSFCellStyle)style).getIndex());,     }, ,     /**,      * Adjusts the column width to fit the contents.,      *,      * This process can be relatively slow on large sheets, so this should,      *  normally only be called once per column, at the end of your,      *  processing.,      *,      * @param column the column index,      */,     public void autoSizeColumn(int column) {,         autoSizeColumn(column, false);,     }, ,     /**,      * Adjusts the column width to fit the contents.,      *,      * This process can be relatively slow on large sheets, so this should,      *  normally only be called once per column, at the end of your,      *  processing.,      *,      * You can specify whether the content of merged cells should be considered or ignored.,      *  Default is to ignore merged cells.,      *,      * @param column the column index,      * @param useMergedCells whether to use the contents of merged cells when calculating the width of the column,      */,     public void autoSizeColumn(int column, boolean useMergedCells) {,         double width = SheetUtil.getColumnWidth(this, column, useMergedCells);, ,         if (width != -1) {,             width *= 256;,             int maxColumnWidth = 255*256; // The maximum column width for an individual cell is 255 characters,             if (width > maxColumnWidth) {,                 width = maxColumnWidth;,             },             setColumnWidth(column, (int)(width));,         }, ,     }, ,     /**,      * Returns cell comment for the specified row and column,      *,      * @return cell comment or <code>null</code> if not found,      */,      public HSSFComment getCellComment(int row, int column) {,         // Don't call findCellComment directly, otherwise,         //  two calls to this method will result in two,         //  new HSSFComment instances, which is bad,         HSSFRow r = getRow(row);,         if(r != null) {,             HSSFCell c = r.getCell(column);,             if(c != null) {,                 return c.getCellComment();,             },             // No cell, so you will get new,             //  objects every time, sorry...,             return HSSFCell.findCellComment(_sheet, row, column);,         },         return null;,     }, ,     public HSSFSheetConditionalFormatting getSheetConditionalFormatting() {,         return new HSSFSheetConditionalFormatting(this);,     }, ,     /**,      * Returns the name of this sheet,      *,      * @return the name of this sheet,      */,     public String getSheetName() {,         HSSFWorkbook wb = getWorkbook();,         int idx = wb.getSheetIndex(this);,         return wb.getSheetName(idx);,     }, ,     /**,      * Also creates cells if they don't exist,      */,     private CellRange<HSSFCell> getCellRange(CellRangeAddress range) {,         int firstRow = range.getFirstRow();,         int firstColumn = range.getFirstColumn();,         int lastRow = range.getLastRow();,         int lastColumn = range.getLastColumn();,         int height = lastRow - firstRow + 1;,         int width = lastColumn - firstColumn + 1;,         List<HSSFCell> temp = new ArrayList<HSSFCell>(height*width);,         for (int rowIn = firstRow; rowIn <= lastRow; rowIn++) {,             for (int colIn = firstColumn; colIn <= lastColumn; colIn++) {,                 HSSFRow row = getRow(rowIn);,                 if (row == null) {,                     row = createRow(rowIn);,                 },                 HSSFCell cell = row.getCell(colIn);,                 if (cell == null) {,                     cell = row.createCell(colIn);,                 },                 temp.add(cell);,             },         },         return SSCellRange.create(firstRow, firstColumn, height, width, temp, HSSFCell.class);,     }, ,     public CellRange<HSSFCell> setArrayFormula(String formula, CellRangeAddress range) {,         // make sure the formula parses OK first,         int sheetIndex = _workbook.getSheetIndex(this);,         Ptg[] ptgs = HSSFFormulaParser.parse(formula, _workbook, FormulaType.ARRAY, sheetIndex);,         CellRange<HSSFCell> cells = getCellRange(range);, ,         for (HSSFCell c : cells) {,             c.setCellArrayFormula(range);,         },         HSSFCell mainArrayFormulaCell = cells.getTopLeftCell();,         FormulaRecordAggregate agg = (FormulaRecordAggregate)mainArrayFormulaCell.getCellValueRecord();,         agg.setArrayFormula(range, ptgs);,         return cells;,     }, , ,     public CellRange<HSSFCell> removeArrayFormula(Cell cell) {,         if (cell.getSheet() != this) {,             throw new IllegalArgumentException("Specified cell does not belong to this sheet.");,         },         CellValueRecordInterface rec = ((HSSFCell) cell).getCellValueRecord();,         if (!(rec instanceof FormulaRecordAggregate)) {,             String ref = new CellReference(cell).formatAsString();,             throw new IllegalArgumentException("Cell " + ref + " is not part of an array formula.");,         },         FormulaRecordAggregate fra = (FormulaRecordAggregate) rec;,         CellRangeAddress range = fra.removeArrayFormula(cell.getRowIndex(), cell.getColumnIndex());, ,         CellRange<HSSFCell> result = getCellRange(range);,         // clear all cells in the range,         for (Cell c : result) {,             c.setCellType(Cell.CELL_TYPE_BLANK);,         },         return result;,     }, , 	public DataValidationHelper getDataValidationHelper() {, 		return new HSSFDataValidationHelper(this);, 	},     ,     public HSSFAutoFilter setAutoFilter(CellRangeAddress range) {, , ,         InternalWorkbook workbook = _workbook.getWorkbook();,         int sheetIndex = _workbook.getSheetIndex(this);, ,         NameRecord name = workbook.getSpecificBuiltinRecord(NameRecord.BUILTIN_FILTER_DB, sheetIndex+1);, ,         if (name == null) {,             name = workbook.createBuiltInName(NameRecord.BUILTIN_FILTER_DB, sheetIndex+1);,         }, ,         // The built-in name must consist of a single Area3d Ptg.,         Area3DPtg ptg = new Area3DPtg(range.getFirstRow(), range.getLastRow(),,                 range.getFirstColumn(), range.getLastColumn(),,                 false, false, false, false, sheetIndex);,         name.setNameDefinition(new Ptg[]{ptg});, ,         AutoFilterInfoRecord r = new AutoFilterInfoRecord();,         // the number of columns that have AutoFilter enabled.,         int numcols = 1 + range.getLastColumn() - range.getFirstColumn();,         r.setNumEntries((short)numcols);,         int idx = _sheet.findFirstRecordLocBySid(DimensionsRecord.sid);,         _sheet.getRecords().add(idx, r);, ,         //create a combobox control for each column,         HSSFPatriarch p = createDrawingPatriarch();,         for(int col = range.getFirstColumn(); col <= range.getLastColumn(); col++){,             p.createComboBox(new HSSFClientAnchor(0,0,0,0,,                     (short)col, range.getFirstRow(), (short)(col+1), range.getFirstRow()+1));,         },         ,         return new HSSFAutoFilter(this);],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/poi/hssf/view/SVTableUtils.java,,40-40,[  public static Border noFocusBorder = new EmptyBorder(1, 1, 1, 1);],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/poi/hssf/view/SVTableUtils.java,,40-40,[  public static Border noFocusBorder = new EmptyBorder(1, 1, 1, 1);],,
BAD_PRACTICE,DM_EXIT,org/apache/poi/hssf/view/SViewer.java,init,63-63,[      System.exit(1);],,
BAD_PRACTICE,SE_BAD_FIELD,org/apache/poi/hssf/usermodel/HSSFWorkbook.java,,78-1798,[public final class HSSFWorkbook extends POIDocument implements org.apache.poi.ss.usermodel.Workbook {,     private static final Pattern COMMA_PATTERN = Pattern.compile(",");,     private static final int MAX_ROW = 0xFFFF;,     private static final short MAX_COLUMN = (short)0x00FF;, ,     /**,      * The maximum number of cell styles in a .xls workbook.,      * The 'official' limit is 4,000, but POI allows a slightly larger number.,      * This extra delta takes into account built-in styles that are automatically,      * created for new workbooks,      *,      * See http://office.microsoft.com/en-us/excel-help/excel-specifications-and-limits-HP005199291.aspx,      */,     private static final int MAX_STYLES = 4030;, ,     private static final int DEBUG = POILogger.DEBUG;, ,     /**,      * used for compile-time performance/memory optimization.  This determines the,      * initial capacity for the sheet collection.  Its currently set to 3.,      * Changing it in this release will decrease performance,      * since you're never allowed to have more or less than three sheets!,      */, ,     public final static int INITIAL_CAPACITY = 3;, ,     /**,      * this is the reference to the low level Workbook object,      */, ,     private InternalWorkbook workbook;, ,     /**,      * this holds the HSSFSheet objects attached to this workbook,      */, ,     protected List<HSSFSheet> _sheets;, ,     /**,      * this holds the HSSFName objects attached to this workbook,      */, ,     private ArrayList<HSSFName> names;, ,     /**,      * this holds the HSSFFont objects attached to this workbook.,      * We only create these from the low level records as required.,      */,     private Hashtable fonts;, ,     /**,      * holds whether or not to preserve other nodes in the POIFS.  Used,      * for macros and embedded objects.,      */,     private boolean   preserveNodes;, ,     /**,      * Used to keep track of the data formatter so that all,      * createDataFormatter calls return the same one for a given,      * book.  This ensures that updates from one places is visible,      * someplace else.,      */,     private HSSFDataFormat formatter;, ,     /**,      * The policy to apply in the event of missing or,      *  blank cells when fetching from a row.,      * See {@link MissingCellPolicy},      */,     private MissingCellPolicy missingCellPolicy = HSSFRow.RETURN_NULL_AND_BLANK;, ,     private static POILogger log = POILogFactory.getLogger(HSSFWorkbook.class);, ,     /**,      * The locator of user-defined functions.,      * By default includes functions from the Excel Analysis Toolpack,      */,     private UDFFinder _udfFinder = UDFFinder.DEFAULT;, ,     public static HSSFWorkbook create(InternalWorkbook book) {,     	return new HSSFWorkbook(book);,     },     /**,      * Creates new HSSFWorkbook from scratch (start here!),      *,      */,     public HSSFWorkbook() {,         this(InternalWorkbook.createWorkbook());,     }, , 	private HSSFWorkbook(InternalWorkbook book) {, 		super((DirectoryNode)null);, 		workbook = book;, 		_sheets = new ArrayList<HSSFSheet>(INITIAL_CAPACITY);, 		names = new ArrayList<HSSFName>(INITIAL_CAPACITY);, 	}, ,     public HSSFWorkbook(POIFSFileSystem fs) throws IOException {,         this(fs,true);,     }, ,     /**,      * given a POI POIFSFileSystem object, read in its Workbook and populate the high and,      * low level models.  If you're reading in a workbook...start here.,      *,      * @param fs the POI filesystem that contains the Workbook stream.,      * @param preserveNodes whether to preseve other nodes, such as,      *        macros.  This takes more memory, so only say yes if you,      *        need to. If set, will store all of the POIFSFileSystem,      *        in memory,      * @see org.apache.poi.poifs.filesystem.POIFSFileSystem,      * @exception IOException if the stream cannot be read,      */,     public HSSFWorkbook(POIFSFileSystem fs, boolean preserveNodes),             throws IOException,     {,         this(fs.getRoot(), fs, preserveNodes);,     }, ,     /**,      * Normally, the Workbook will be in a POIFS Stream,      * called "Workbook". However, some weird XLS generators use "WORKBOOK",      */,     private static final String[] WORKBOOK_DIR_ENTRY_NAMES = {,         "Workbook", // as per BIFF8 spec,         "WORKBOOK",,     };, , ,     private static String getWorkbookDirEntryName(DirectoryNode directory) {, ,         String[] potentialNames = WORKBOOK_DIR_ENTRY_NAMES;,         for (int i = 0; i < potentialNames.length; i++) {,             String wbName = potentialNames[i];,             try {,                 directory.getEntry(wbName);,                 return wbName;,             } catch (FileNotFoundException e) {,                 // continue - to try other options,             },         }, ,         // check for previous version of file format,         try {,             directory.getEntry("Book");,             throw new OldExcelFormatException("The supplied spreadsheet seems to be Excel 5.0/7.0 (BIFF5) format. ",                     + "POI only supports BIFF8 format (from Excel versions 97/2000/XP/2003)");,         } catch (FileNotFoundException e) {,             // fall through,         }, ,         throw new IllegalArgumentException("The supplied POIFSFileSystem does not contain a BIFF8 'Workbook' entry. ",             + "Is it really an excel file?");,     }, ,     /**,      * given a POI POIFSFileSystem object, and a specific directory,      *  within it, read in its Workbook and populate the high and,      *  low level models.  If you're reading in a workbook...start here.,      *,      * @param directory the POI filesystem directory to process from,      * @param fs the POI filesystem that contains the Workbook stream.,      * @param preserveNodes whether to preseve other nodes, such as,      *        macros.  This takes more memory, so only say yes if you,      *        need to. If set, will store all of the POIFSFileSystem,      *        in memory,      * @see org.apache.poi.poifs.filesystem.POIFSFileSystem,      * @exception IOException if the stream cannot be read,      */,     public HSSFWorkbook(DirectoryNode directory, POIFSFileSystem fs, boolean preserveNodes),             throws IOException,     {,        this(directory, preserveNodes);,     },     ,     /**,      * given a POI POIFSFileSystem object, and a specific directory,      *  within it, read in its Workbook and populate the high and,      *  low level models.  If you're reading in a workbook...start here.,      *,      * @param directory the POI filesystem directory to process from,      * @param preserveNodes whether to preseve other nodes, such as,      *        macros.  This takes more memory, so only say yes if you,      *        need to. If set, will store all of the POIFSFileSystem,      *        in memory,      * @see org.apache.poi.poifs.filesystem.POIFSFileSystem,      * @exception IOException if the stream cannot be read,      */,     public HSSFWorkbook(DirectoryNode directory, boolean preserveNodes),             throws IOException,     {,         super(directory);,         String workbookName = getWorkbookDirEntryName(directory);, ,         this.preserveNodes = preserveNodes;, ,         // If we're not preserving nodes, don't track the,         //  POIFS any more,         if(! preserveNodes) {,            this.directory = null;,         }, ,         _sheets = new ArrayList<HSSFSheet>(INITIAL_CAPACITY);,         names  = new ArrayList<HSSFName>(INITIAL_CAPACITY);, ,         // Grab the data from the workbook stream, however,         //  it happens to be spelled.,         InputStream stream = directory.createDocumentInputStream(workbookName);, ,         List<Record> records = RecordFactory.createRecords(stream);, ,         workbook = InternalWorkbook.createWorkbook(records);,         setPropertiesFromWorkbook(workbook);,         int recOffset = workbook.getNumRecords();,         int sheetNum = 0;, ,         // convert all LabelRecord records to LabelSSTRecord,         convertLabelRecords(records, recOffset);,         RecordStream rs = new RecordStream(records, recOffset);,         while (rs.hasNext()) {,             InternalSheet sheet = InternalSheet.createSheet(rs);,             _sheets.add(new HSSFSheet(this, sheet));,         }, ,         for (int i = 0 ; i < workbook.getNumNames() ; ++i){,             NameRecord nameRecord = workbook.getNameRecord(i);,             HSSFName name = new HSSFName(this, nameRecord, workbook.getNameCommentRecord(nameRecord));,             names.add(name);,         },     }, ,      public HSSFWorkbook(InputStream s) throws IOException {,          this(s,true);,      }, ,     /**,      * Companion to HSSFWorkbook(POIFSFileSystem), this constructs the POI filesystem around your,      * inputstream.,      *,      * @param s  the POI filesystem that contains the Workbook stream.,      * @param preserveNodes whether to preseve other nodes, such as,      *        macros.  This takes more memory, so only say yes if you,      *        need to.,      * @see org.apache.poi.poifs.filesystem.POIFSFileSystem,      * @see #HSSFWorkbook(POIFSFileSystem),      * @exception IOException if the stream cannot be read,      */, ,     public HSSFWorkbook(InputStream s, boolean preserveNodes),             throws IOException,     {,         this(new POIFSFileSystem(s), preserveNodes);,     }, ,     /**,      * used internally to set the workbook properties.,      */, ,     private void setPropertiesFromWorkbook(InternalWorkbook book),     {,         this.workbook = book;, ,         // none currently,     }, ,     /**,       * This is basically a kludge to deal with the now obsolete Label records.  If,       * you have to read in a sheet that contains Label records, be aware that the rest,       * of the API doesn't deal with them, the low level structure only provides read-only,       * semi-immutable structures (the sets are there for interface conformance with NO,       * impelmentation).  In short, you need to call this function passing it a reference,       * to the Workbook object.  All labels will be converted to LabelSST records and their,       * contained strings will be written to the Shared String tabel (SSTRecord) within,       * the Workbook.,       *,       * @param records a collection of sheet's records.,       * @param offset the offset to search at ,       * @see org.apache.poi.hssf.record.LabelRecord,       * @see org.apache.poi.hssf.record.LabelSSTRecord,       * @see org.apache.poi.hssf.record.SSTRecord,       */, ,      private void convertLabelRecords(List records, int offset),      {,          if (log.check( POILogger.DEBUG )),              log.log(POILogger.DEBUG, "convertLabelRecords called");,          for (int k = offset; k < records.size(); k++),          {,              Record rec = ( Record ) records.get(k);, ,              if (rec.getSid() == LabelRecord.sid),              {,                  LabelRecord oldrec = ( LabelRecord ) rec;, ,                  records.remove(k);,                  LabelSSTRecord newrec   = new LabelSSTRecord();,                  int            stringid =,                      workbook.addSSTString(new UnicodeString(oldrec.getValue()));, ,                  newrec.setRow(oldrec.getRow());,                  newrec.setColumn(oldrec.getColumn());,                  newrec.setXFIndex(oldrec.getXFIndex());,                  newrec.setSSTIndex(stringid);,                        records.add(k, newrec);,              },          },          if (log.check( POILogger.DEBUG )),              log.log(POILogger.DEBUG, "convertLabelRecords exit");,      }, ,     /**,      * Retrieves the current policy on what to do when,      *  getting missing or blank cells from a row.,      * The default is to return blank and null cells.,      *  {@link MissingCellPolicy},      */,     public MissingCellPolicy getMissingCellPolicy() {,         return missingCellPolicy;,     }, ,     /**,      * Sets the policy on what to do when,      *  getting missing or blank cells from a row.,      * This will then apply to all calls to,      *  {@link HSSFRow#getCell(int)}}. See,      *  {@link MissingCellPolicy}.,      * Note that this has no effect on any,      *  iterators, only on when fetching Cells,      *  by their column index.,      */,     public void setMissingCellPolicy(MissingCellPolicy missingCellPolicy) {,         this.missingCellPolicy = missingCellPolicy;,     }, ,     /**,      * sets the order of appearance for a given sheet.,      *,      * @param sheetname the name of the sheet to reorder,      * @param pos the position that we want to insert the sheet into (0 based),      */, ,     public void setSheetOrder(String sheetname, int pos ) {,         int oldSheetIndex = getSheetIndex(sheetname);,         _sheets.add(pos,_sheets.remove(oldSheetIndex));,         workbook.setSheetOrder(sheetname, pos);, ,         FormulaShifter shifter = FormulaShifter.createForSheetShift(oldSheetIndex, pos);,         for (HSSFSheet sheet : _sheets) {,             sheet.getSheet().updateFormulasAfterCellShift(shifter, /* not used */ -1 );,         }, ,         workbook.updateNamesAfterCellShift(shifter);, ,     }, ,     private void validateSheetIndex(int index) {,         int lastSheetIx = _sheets.size() - 1;,         if (index < 0 || index > lastSheetIx) {,             throw new IllegalArgumentException("Sheet index (",                     + index +") is out of range (0.." +    lastSheetIx + ")");,         },     }, ,     /**,      * Selects a single sheet. This may be different to,      * the 'active' sheet (which is the sheet with focus).,      */,     public void setSelectedTab(int index) {, ,         validateSheetIndex(index);,         int nSheets = _sheets.size();,         for (int i=0; i<nSheets; i++) {,                getSheetAt(i).setSelected(i == index);,         },         workbook.getWindowOne().setNumSelectedTabs((short)1);,     },     /**,      * deprecated May 2008,      * @deprecated use setSelectedTab(int),      */,     public void setSelectedTab(short index) {,         setSelectedTab((int)index);,     },     public void setSelectedTabs(int[] indexes) {, ,         for (int i = 0; i < indexes.length; i++) {,             validateSheetIndex(indexes[i]);,         },         int nSheets = _sheets.size();,         for (int i=0; i<nSheets; i++) {,             boolean bSelect = false;,             for (int j = 0; j < indexes.length; j++) {,                 if (indexes[j] == i) {,                     bSelect = true;,                     break;,                 }, ,             },                getSheetAt(i).setSelected(bSelect);,         },         workbook.getWindowOne().setNumSelectedTabs((short)indexes.length);,     },     /**,      * Convenience method to set the active sheet.  The active sheet is is the sheet,      * which is currently displayed when the workbook is viewed in Excel.,      * 'Selected' sheet(s) is a distinct concept.,      */,     public void setActiveSheet(int index) {, ,         validateSheetIndex(index);,         int nSheets = _sheets.size();,         for (int i=0; i<nSheets; i++) {,              getSheetAt(i).setActive(i == index);,         },         workbook.getWindowOne().setActiveSheetIndex(index);,     }, ,     /**,      * gets the tab whose data is actually seen when the sheet is opened.,      * This may be different from the "selected sheet" since excel seems to,      * allow you to show the data of one sheet when another is seen "selected",      * in the tabs (at the bottom).,      * @see org.apache.poi.hssf.usermodel.HSSFSheet#setSelected(boolean),      */,     public int getActiveSheetIndex() {,         return workbook.getWindowOne().getActiveSheetIndex();,     },     /**,      * deprecated May 2008,      * @deprecated - Misleading name - use getActiveSheetIndex(),      */,     public short getSelectedTab() {,         return (short) getActiveSheetIndex();,     }, , ,     /**,      * sets the first tab that is displayed in the list of tabs,      * in excel.,      * @param index,      */,     public void setFirstVisibleTab(int index) {,         workbook.getWindowOne().setFirstVisibleTab(index);,     },     /**,      * deprecated May 2008,      * @deprecated - Misleading name - use setFirstVisibleTab(),      */,     public void setDisplayedTab(short index) {,        setFirstVisibleTab(index);,     }, ,     /**,      * sets the first tab that is displayed in the list of tabs in excel.,      */,     public int getFirstVisibleTab() {,         return workbook.getWindowOne().getFirstVisibleTab();,     },     /**,      * deprecated May 2008,      * @deprecated - Misleading name - use getFirstVisibleTab(),      */,     public short getDisplayedTab() {,         return (short) getFirstVisibleTab();,     }, ,     /**,      * Set the sheet name.,      *,      * @param sheetIx number (0 based),      * @throws IllegalArgumentException if the name is null or invalid,      *  or workbook already contains a sheet with this name,      * @see #createSheet(String),      * @see org.apache.poi.ss.util.WorkbookUtil#createSafeSheetName(String nameProposal),      */,     public void setSheetName(int sheetIx, String name) {,         if (name == null) {,             throw new IllegalArgumentException("sheetName must not be null");,         }, ,         if (workbook.doesContainsSheetName(name, sheetIx)) {,             throw new IllegalArgumentException("The workbook already contains a sheet with this name");,         },         validateSheetIndex(sheetIx);,         workbook.setSheetName(sheetIx, name);,     }, ,     /**,      * @return Sheet name for the specified index,      */,     public String getSheetName(int sheetIndex) {,         validateSheetIndex(sheetIndex);,         return workbook.getSheetName(sheetIndex);,     }, ,     public boolean isHidden() {,         return workbook.getWindowOne().getHidden();,     }, ,     public void setHidden(boolean hiddenFlag) {,         workbook.getWindowOne().setHidden(hiddenFlag);,     }, ,     public boolean isSheetHidden(int sheetIx) {,         validateSheetIndex(sheetIx);,         return workbook.isSheetHidden(sheetIx);,     }, ,     public boolean isSheetVeryHidden(int sheetIx) {,         validateSheetIndex(sheetIx);,         return workbook.isSheetVeryHidden(sheetIx);,     }, , ,     public void setSheetHidden(int sheetIx, boolean hidden) {,         validateSheetIndex(sheetIx);,         workbook.setSheetHidden(sheetIx, hidden);,     }, ,     public void setSheetHidden(int sheetIx, int hidden) {,         validateSheetIndex(sheetIx);,         WorkbookUtil.validateSheetState(hidden);,         workbook.setSheetHidden(sheetIx, hidden);,     }, ,     /** Returns the index of the sheet by his name,      * @param name the sheet name,      * @return index of the sheet (0 based),      */,     public int getSheetIndex(String name){,         return workbook.getSheetIndex(name);,     }, ,     /** Returns the index of the given sheet,      * @param sheet the sheet to look up,      * @return index of the sheet (0 based). <tt>-1</tt> if not found,      */,     public int getSheetIndex(org.apache.poi.ss.usermodel.Sheet sheet) {,         for(int i=0; i<_sheets.size(); i++) {,             if(_sheets.get(i) == sheet) {,                 return i;,             },         },         return -1;,     }, ,     /**,      * Returns the external sheet index of the sheet,      *  with the given internal index, creating one,      *  if needed.,      * Used by some of the more obscure formula and,      *  named range things.,      * @deprecated for POI internal use only (formula parsing).  This method is likely to,      * be removed in future versions of POI.,      */,     public int getExternalSheetIndex(int internalSheetIndex) {,         return workbook.checkExternSheet(internalSheetIndex);,     },     /**,      * @deprecated for POI internal use only (formula rendering).  This method is likely to,      * be removed in future versions of POI.,      */,     public String findSheetNameFromExternSheet(int externSheetIndex){,         // TODO - don't expose internal ugliness like externSheet indexes to the user model API,         return workbook.findSheetNameFromExternSheet(externSheetIndex);,     },     /**,      * @deprecated for POI internal use only (formula rendering).  This method is likely to,      * be removed in future versions of POI.,      *,      * @param refIndex Index to REF entry in EXTERNSHEET record in the Link Table,      * @param definedNameIndex zero-based to DEFINEDNAME or EXTERNALNAME record,      * @return the string representation of the defined or external name,      */,     public String resolveNameXText(int refIndex, int definedNameIndex) {,         // TODO - make this less cryptic / move elsewhere,         return workbook.resolveNameXText(refIndex, definedNameIndex);,     }, , , , ,     /**,      * create an HSSFSheet for this HSSFWorkbook, adds it to the sheets and returns,      * the high level representation.  Use this to create new sheets.,      *,      * @return HSSFSheet representing the new sheet.,      */, ,     public HSSFSheet createSheet(),     {,         HSSFSheet sheet = new HSSFSheet(this);, ,         _sheets.add(sheet);,         workbook.setSheetName(_sheets.size() - 1, "Sheet" + (_sheets.size() - 1));,         boolean isOnlySheet = _sheets.size() == 1;,         sheet.setSelected(isOnlySheet);,         sheet.setActive(isOnlySheet);,         return sheet;,     }, ,     /**,      * create an HSSFSheet from an existing sheet in the HSSFWorkbook.,      *,      * @return HSSFSheet representing the cloned sheet.,      */, ,     public HSSFSheet cloneSheet(int sheetIndex) {,         validateSheetIndex(sheetIndex);,         HSSFSheet srcSheet = _sheets.get(sheetIndex);,         String srcName = workbook.getSheetName(sheetIndex);,         HSSFSheet clonedSheet = srcSheet.cloneSheet(this);,         clonedSheet.setSelected(false);,         clonedSheet.setActive(false);, ,         String name = getUniqueSheetName(srcName);,         int newSheetIndex = _sheets.size();,         _sheets.add(clonedSheet);,         workbook.setSheetName(newSheetIndex, name);, ,         // Check this sheet has an autofilter, (which has a built-in NameRecord at workbook level),         int filterDbNameIndex = findExistingBuiltinNameRecordIdx(sheetIndex, NameRecord.BUILTIN_FILTER_DB);,         if (filterDbNameIndex != -1) {,             NameRecord newNameRecord = workbook.cloneFilter(filterDbNameIndex, newSheetIndex);,             HSSFName newName = new HSSFName(this, newNameRecord);,             names.add(newName);,         },         // TODO - maybe same logic required for other/all built-in name records,         workbook.cloneDrawings(clonedSheet.getSheet());, ,         return clonedSheet;,     }, ,     private String getUniqueSheetName(String srcName) {,         int uniqueIndex = 2;,         String baseName = srcName;,         int bracketPos = srcName.lastIndexOf('(');,         if (bracketPos > 0 && srcName.endsWith(")")) {,             String suffix = srcName.substring(bracketPos + 1, srcName.length() - ")".length());,             try {,                 uniqueIndex = Integer.parseInt(suffix.trim());,                 uniqueIndex++;,                 baseName=srcName.substring(0, bracketPos).trim();,             } catch (NumberFormatException e) {,                 // contents of brackets not numeric,             },         },         while (true) {,             // Try and find the next sheet name that is unique,             String index = Integer.toString(uniqueIndex++);,             String name;,             if (baseName.length() + index.length() + 2 < 31) {,                 name = baseName + " (" + index + ")";,             } else {,                 name = baseName.substring(0, 31 - index.length() - 2) + "(" + index + ")";,             }, ,             //If the sheet name is unique, then set it otherwise move on to the next number.,             if (workbook.getSheetIndex(name) == -1) {,               return name;,             },         },     }, ,     /**,      * Create a new sheet for this Workbook and return the high level representation.,      * Use this to create new sheets.,      *,      * <p>,      *     Note that Excel allows sheet names up to 31 chars in length but other applications,      *     (such as OpenOffice) allow more. Some versions of Excel crash with names longer than 31 chars,,      *     others - truncate such names to 31 character.,      * </p>,      * <p>,      *     POI's SpreadsheetAPI silently truncates the input argument to 31 characters.,      *     Example:,      *,      *     <pre><code>,      *     Sheet sheet = workbook.createSheet("My very long sheet name which is longer than 31 chars"); // will be truncated,      *     assert 31 == sheet.getSheetName().length();,      *     assert "My very long sheet name which i" == sheet.getSheetName();,      *     </code></pre>,      * </p>,      *,      * Except the 31-character constraint, Excel applies some other rules:,      * <p>,      * Sheet name MUST be unique in the workbook and MUST NOT contain the any of the following characters:,      * <ul>,      * <li> 0x0000 </li>,      * <li> 0x0003 </li>,      * <li> colon (:) </li>,      * <li> backslash (\) </li>,      * <li> asterisk (*) </li>,      * <li> question mark (?) </li>,      * <li> forward slash (/) </li>,      * <li> opening square bracket ([) </li>,      * <li> closing square bracket (]) </li>,      * </ul>,      * The string MUST NOT begin or end with the single quote (') character.,      * </p>,      *,      * @param sheetname  sheetname to set for the sheet.,      * @return Sheet representing the new sheet.,      * @throws IllegalArgumentException if the name is null or invalid,      *  or workbook already contains a sheet with this name,      * @see org.apache.poi.ss.util.WorkbookUtil#createSafeSheetName(String nameProposal),      */,     public HSSFSheet createSheet(String sheetname),     {,         if (sheetname == null) {,             throw new IllegalArgumentException("sheetName must not be null");,         }, ,         if (workbook.doesContainsSheetName( sheetname, _sheets.size() )),             throw new IllegalArgumentException( "The workbook already contains a sheet of this name" );, ,         HSSFSheet sheet = new HSSFSheet(this);, ,         workbook.setSheetName(_sheets.size(), sheetname);,         _sheets.add(sheet);,         boolean isOnlySheet = _sheets.size() == 1;,         sheet.setSelected(isOnlySheet);,         sheet.setActive(isOnlySheet);,         return sheet;,     }, ,     /**,      * get the number of spreadsheets in the workbook (this will be three after serialization),      * @return number of sheets,      */, ,     public int getNumberOfSheets(),     {,         return _sheets.size();,     }, ,     public int getSheetIndexFromExternSheetIndex(int externSheetNumber) {,         return workbook.getSheetIndexFromExternSheetIndex(externSheetNumber);,     }, ,     private HSSFSheet[] getSheets() {,         HSSFSheet[] result = new HSSFSheet[_sheets.size()];,         _sheets.toArray(result);,         return result;,     }, ,     /**,      * Get the HSSFSheet object at the given index.,      * @param index of the sheet number (0-based physical & logical),      * @return HSSFSheet at the provided index,      */, ,     public HSSFSheet getSheetAt(int index),     {,         validateSheetIndex(index);,         return (HSSFSheet) _sheets.get(index);,     }, ,     /**,      * Get sheet with the given name (case insensitive match),      * @param name of the sheet,      * @return HSSFSheet with the name provided or <code>null</code> if it does not exist,      */, ,     public HSSFSheet getSheet(String name),     {,         HSSFSheet retval = null;, ,         for (int k = 0; k < _sheets.size(); k++),         {,             String sheetname = workbook.getSheetName(k);, ,             if (sheetname.equalsIgnoreCase(name)),             {,                 retval = (HSSFSheet) _sheets.get(k);,             },         },         return retval;,     }, ,     /**,      * Removes sheet at the given index.<p/>,      *,      * Care must be taken if the removed sheet is the currently active or only selected sheet in,      * the workbook. There are a few situations when Excel must have a selection and/or active,      * sheet. (For example when printing - see Bug 40414).<br/>,      *,      * This method makes sure that if the removed sheet was active, another sheet will become,      * active in its place.  Furthermore, if the removed sheet was the only selected sheet, another,      * sheet will become selected.  The newly active/selected sheet will have the same index, or,      * one less if the removed sheet was the last in the workbook.,      *,      * @param index of the sheet  (0-based),      */,     public void removeSheetAt(int index) {,         validateSheetIndex(index);,         boolean wasActive = getSheetAt(index).isActive();,         boolean wasSelected = getSheetAt(index).isSelected();, ,         _sheets.remove(index);,         workbook.removeSheet(index);, ,         // set the remaining active/selected sheet,         int nSheets = _sheets.size();,         if (nSheets < 1) {,             // nothing more to do if there are no sheets left,             return;,         },         // the index of the closest remaining sheet to the one just deleted,         int newSheetIndex = index;,         if (newSheetIndex >= nSheets) {,             newSheetIndex = nSheets-1;,         },         if (wasActive) {,             setActiveSheet(newSheetIndex);,         }, ,         if (wasSelected) {,             boolean someOtherSheetIsStillSelected = false;,             for (int i =0; i < nSheets; i++) {,                 if (getSheetAt(i).isSelected()) {,                     someOtherSheetIsStillSelected = true;,                     break;,                 },             },             if (!someOtherSheetIsStillSelected) {,                 setSelectedTab(newSheetIndex);,             },         },     }, ,     /**,      * determine whether the Excel GUI will backup the workbook when saving.,      *,      * @param backupValue   true to indicate a backup will be performed.,      */, ,     public void setBackupFlag(boolean backupValue),     {,         BackupRecord backupRecord = workbook.getBackupRecord();, ,         backupRecord.setBackup(backupValue ? (short) 1,                 : (short) 0);,     }, ,     /**,      * determine whether the Excel GUI will backup the workbook when saving.,      *,      * @return the current setting for backups.,      */, ,     public boolean getBackupFlag(),     {,         BackupRecord backupRecord = workbook.getBackupRecord();, ,         return (backupRecord.getBackup() == 0) ? false,                 : true;,     }, ,     /**,      * Sets the repeating rows and columns for a sheet (as found in,      * 2003:File->PageSetup->Sheet, 2007:Page Layout->Print Titles).,      *   This is function is included in the workbook,      * because it creates/modifies name records which are stored at the,      * workbook level.,      * <p>,      * To set just repeating columns:,      * <pre>,      *  workbook.setRepeatingRowsAndColumns(0,0,1,-1-1);,      * </pre>,      * To set just repeating rows:,      * <pre>,      *  workbook.setRepeatingRowsAndColumns(0,-1,-1,0,4);,      * </pre>,      * To remove all repeating rows and columns for a sheet.,      * <pre>,      *  workbook.setRepeatingRowsAndColumns(0,-1,-1,-1,-1);,      * </pre>,      *,      * @param sheetIndex    0 based index to sheet.,      * @param startColumn   0 based start of repeating columns.,      * @param endColumn     0 based end of repeating columns.,      * @param startRow      0 based start of repeating rows.,      * @param endRow        0 based end of repeating rows.,      */,     public void setRepeatingRowsAndColumns(int sheetIndex,,                                            int startColumn, int endColumn,,                                            int startRow, int endRow),     {,         // Check arguments,         if (startColumn == -1 && endColumn != -1) throw new IllegalArgumentException("Invalid column range specification");,         if (startRow == -1 && endRow != -1) throw new IllegalArgumentException("Invalid row range specification");,         if (startColumn < -1 || startColumn >= MAX_COLUMN) throw new IllegalArgumentException("Invalid column range specification");,         if (endColumn < -1 || endColumn >= MAX_COLUMN) throw new IllegalArgumentException("Invalid column range specification");,         if (startRow < -1 || startRow > MAX_ROW) throw new IllegalArgumentException("Invalid row range specification");,         if (endRow < -1 || endRow > MAX_ROW) throw new IllegalArgumentException("Invalid row range specification");,         if (startColumn > endColumn) throw new IllegalArgumentException("Invalid column range specification");,         if (startRow > endRow) throw new IllegalArgumentException("Invalid row range specification");, ,         HSSFSheet sheet = getSheetAt(sheetIndex);,         short externSheetIndex = getWorkbook().checkExternSheet(sheetIndex);, ,         boolean settingRowAndColumn =,                 startColumn != -1 && endColumn != -1 && startRow != -1 && endRow != -1;,         boolean removingRange =,                 startColumn == -1 && endColumn == -1 && startRow == -1 && endRow == -1;, ,         int rowColHeaderNameIndex = findExistingBuiltinNameRecordIdx(sheetIndex, NameRecord.BUILTIN_PRINT_TITLE);,         if (removingRange) {,             if (rowColHeaderNameIndex >= 0) {,                 workbook.removeName(rowColHeaderNameIndex);,             },             return;,         },         boolean isNewRecord;,         NameRecord nameRecord;,         if (rowColHeaderNameIndex < 0) {,             //does a lot of the house keeping for builtin records, like setting lengths to zero etc,             nameRecord = workbook.createBuiltInName(NameRecord.BUILTIN_PRINT_TITLE, sheetIndex+1);,             isNewRecord = true;,         } else {,             nameRecord = workbook.getNameRecord(rowColHeaderNameIndex);,             isNewRecord = false;,         }, ,         List temp = new ArrayList();, ,         if (settingRowAndColumn) {,             final int exprsSize = 2 * 11 + 1; // 2 * Area3DPtg.SIZE + UnionPtg.SIZE,             temp.add(new MemFuncPtg(exprsSize));,         },         if (startColumn >= 0) {,             Area3DPtg colArea = new Area3DPtg(0, MAX_ROW, startColumn, endColumn,,                     false, false, false, false, externSheetIndex);,             temp.add(colArea);,         },         if (startRow >= 0) {,             Area3DPtg rowArea = new Area3DPtg(startRow, endRow, 0, MAX_COLUMN,,                     false, false, false, false, externSheetIndex);,             temp.add(rowArea);,         },         if (settingRowAndColumn) {,             temp.add(UnionPtg.instance);,         },         Ptg[] ptgs = new Ptg[temp.size()];,         temp.toArray(ptgs);,         nameRecord.setNameDefinition(ptgs);, ,         if (isNewRecord),         {,             HSSFName newName = new HSSFName(this, nameRecord, nameRecord.isBuiltInName() ? null : workbook.getNameCommentRecord(nameRecord));,             names.add(newName);,         }, ,         HSSFPrintSetup printSetup = sheet.getPrintSetup();,         printSetup.setValidSettings(false);, ,         sheet.setActive(true);,     }, , ,     private int findExistingBuiltinNameRecordIdx(int sheetIndex, byte builtinCode) {,         for(int defNameIndex =0; defNameIndex<names.size(); defNameIndex++) {,             NameRecord r = workbook.getNameRecord(defNameIndex);,             if (r == null) {,                 throw new RuntimeException("Unable to find all defined names to iterate over");,             },             if (!r.isBuiltInName() || r.getBuiltInName() != builtinCode) {,                 continue;,             },             if (r.getSheetNumber() -1 == sheetIndex) {,                 return defNameIndex;,             },         },         return -1;,     }, ,     /**,      * create a new Font and add it to the workbook's font table,      * @return new font object,      */, ,     public HSSFFont createFont(),     {,         FontRecord font = workbook.createNewFont();,         short fontindex = (short) (getNumberOfFonts() - 1);, ,         if (fontindex > 3),         {,             fontindex++;   // THERE IS NO FOUR!!,         },         if(fontindex == Short.MAX_VALUE){,             throw new IllegalArgumentException("Maximum number of fonts was exceeded");,         }, ,         // Ask getFontAt() to build it for us,,         //  so it gets properly cached,         return getFontAt(fontindex);,     }, ,     /**,      * Finds a font that matches the one with the supplied attributes,      */,     public HSSFFont findFont(short boldWeight, short color, short fontHeight,,                              String name, boolean italic, boolean strikeout,,                              short typeOffset, byte underline),     {,         for (short i=0; i<=getNumberOfFonts(); i++) {,             // Remember - there is no 4!,             if(i == 4) continue;, ,             HSSFFont hssfFont = getFontAt(i);,             if (hssfFont.getBoldweight() == boldWeight,                     && hssfFont.getColor() == color,                     && hssfFont.getFontHeight() == fontHeight,                     && hssfFont.getFontName().equals(name),                     && hssfFont.getItalic() == italic,                     && hssfFont.getStrikeout() == strikeout,                     && hssfFont.getTypeOffset() == typeOffset,                     && hssfFont.getUnderline() == underline),             {,                 return hssfFont;,             },         }, ,         return null;,     }, ,     /**,      * get the number of fonts in the font table,      * @return number of fonts,      */, ,     public short getNumberOfFonts(),     {,         return (short) workbook.getNumberOfFontRecords();,     }, ,     /**,      * Get the font at the given index number,      * @param idx  index number,      * @return HSSFFont at the index,      */,     public HSSFFont getFontAt(short idx) {,         if(fonts == null) fonts = new Hashtable();, ,         // So we don't confuse users, give them back,         //  the same object every time, but create,         //  them lazily,         Short sIdx = Short.valueOf(idx);,         if(fonts.containsKey(sIdx)) {,             return (HSSFFont)fonts.get(sIdx);,         }, ,         FontRecord font = workbook.getFontRecordAt(idx);,         HSSFFont retval = new HSSFFont(idx, font);,         fonts.put(sIdx, retval);, ,         return retval;,     }, ,     /**,      * Reset the fonts cache, causing all new calls,      *  to getFontAt() to create new objects.,      * Should only be called after deleting fonts,,      *  and that's not something you should normally do,      */,     protected void resetFontCache() {,         fonts = new Hashtable();,     }, ,     /**,      * Create a new Cell style and add it to the workbook's style table.,      * You can define up to 4000 unique styles in a .xls workbook.,      *,      * @return the new Cell Style object,      * @throws IllegalStateException if the maximum number of cell styles exceeded the limit,      */, ,     public HSSFCellStyle createCellStyle(),     {,         if(workbook.getNumExFormats() == MAX_STYLES) {,             throw new IllegalStateException("The maximum number of cell styles was exceeded. " +,                     "You can define up to 4000 styles in a .xls workbook");,         },         ExtendedFormatRecord xfr = workbook.createCellXF();,         short index = (short) (getNumCellStyles() - 1);,         HSSFCellStyle style = new HSSFCellStyle(index, xfr, this);, ,         return style;,     }, ,     /**,      * get the number of styles the workbook contains,      * @return count of cell styles,      */, ,     public short getNumCellStyles(),     {,         return (short) workbook.getNumExFormats();,     }, ,     /**,      * get the cell style object at the given index,      * @param idx  index within the set of styles,      * @return HSSFCellStyle object at the index,      */,     public HSSFCellStyle getCellStyleAt(short idx),     {,         ExtendedFormatRecord xfr = workbook.getExFormatAt(idx);,         HSSFCellStyle style = new HSSFCellStyle(idx, xfr, this);, ,         return style;,     }, ,     /**,      * Method write - write out this workbook to an Outputstream.  Constructs,      * a new POI POIFSFileSystem, passes in the workbook binary representation  and,      * writes it out.,      *,      * @param stream - the java OutputStream you wish to write the XLS to,      *,      * @exception IOException if anything can't be written.,      * @see org.apache.poi.poifs.filesystem.POIFSFileSystem,      */, ,     public void write(OutputStream stream),             throws IOException,     {,         byte[] bytes = getBytes();,         POIFSFileSystem fs = new POIFSFileSystem();, ,         // For tracking what we've written out, used if we're,         //  going to be preserving nodes,         List<String> excepts = new ArrayList<String>(1);, ,         // Write out the Workbook stream,         fs.createDocument(new ByteArrayInputStream(bytes), "Workbook");, ,         // Write out our HPFS properties, if we have them,         writeProperties(fs, excepts);, ,         if (preserveNodes) {,             // Don't write out the old Workbook, we'll be doing our new one,             excepts.add("Workbook");,             // If the file had WORKBOOK instead of Workbook, we'll write it,             //  out correctly shortly, so don't include the old one,             excepts.add("WORKBOOK");, ,             // Copy over all the other nodes to our new poifs,             copyNodes(this.directory, fs.getRoot(), excepts);, ,             // YK: preserve StorageClsid, it is important for embedded workbooks,,             // see Bugzilla 47920,             fs.getRoot().setStorageClsid(this.directory.getStorageClsid());,         },         fs.writeFilesystem(stream);,     }, ,     /**,      * Totals the sizes of all sheet records and eventually serializes them,      */,     private static final class SheetRecordCollector implements RecordVisitor {, ,         private List _list;,         private int _totalSize;, ,         public SheetRecordCollector() {,             _totalSize = 0;,             _list = new ArrayList(128);,         },         public int getTotalSize() {,             return _totalSize;,         },         public void visitRecord(Record r) {,             _list.add(r);,             _totalSize+=r.getRecordSize();,         },         public int serialize(int offset, byte[] data) {,             int result = 0;,             int nRecs = _list.size();,             for(int i=0; i<nRecs; i++) {,                 Record rec = (Record)_list.get(i);,                 result += rec.serialize(offset + result, data);,             },             return result;,         },     }, , ,     /**,      * Method getBytes - get the bytes of just the HSSF portions of the XLS file.,      * Use this to construct a POI POIFSFileSystem yourself.,      *,      *,      * @return byte[] array containing the binary representation of this workbook and all contained,      *         sheets, rows, cells, etc.,      */,     public byte[] getBytes() {,         if (log.check( POILogger.DEBUG )) {,             log.log(DEBUG, "HSSFWorkbook.getBytes()");,         }, ,         HSSFSheet[] sheets = getSheets();,         int nSheets = sheets.length;, ,         // before getting the workbook size we must tell the sheets that,         // serialization is about to occur.,         for (int i = 0; i < nSheets; i++) {,             sheets[i].getSheet().preSerialize();,         }, ,         int totalsize = workbook.getSize();, ,         // pre-calculate all the sheet sizes and set BOF indexes,         SheetRecordCollector[] srCollectors = new SheetRecordCollector[nSheets];,         for (int k = 0; k < nSheets; k++) {,             workbook.setSheetBof(k, totalsize);,             SheetRecordCollector src = new SheetRecordCollector();,             sheets[k].getSheet().visitContainedRecords(src, totalsize);,             totalsize += src.getTotalSize();,             srCollectors[k] = src;,         }, ,         byte[] retval = new byte[totalsize];,         int pos = workbook.serialize(0, retval);, ,         for (int k = 0; k < nSheets; k++) {,             SheetRecordCollector src = srCollectors[k];,             int serializedSize = src.serialize(pos, retval);,             if (serializedSize != src.getTotalSize()) {,                 // Wrong offset values have been passed in the call to setSheetBof() above.,                 // For books with more than one sheet, this discrepancy would cause excel,                 // to report errors and loose data while reading the workbook,                 throw new IllegalStateException("Actual serialized sheet size (" + serializedSize,                         + ") differs from pre-calculated size (" + src.getTotalSize(),                         + ") for sheet (" + k + ")");,                 // TODO - add similar sanity check to ensure that Sheet.serializeIndexRecord() does not write mis-aligned offsets either,             },             pos += serializedSize;,         },         return retval;,     }, ,     /** @deprecated Do not call this method from your applications. Use the methods,      *  available in the HSSFRow to add string HSSFCells,      */,     public int addSSTString(String string),     {,         return workbook.addSSTString(new UnicodeString(string));,     }, ,     /** @deprecated Do not call this method from your applications. Use the methods,      *  available in the HSSFRow to get string HSSFCells,      */,     public String getSSTString(int index),     {,         return workbook.getSSTString(index).getString();,     }, ,     InternalWorkbook getWorkbook() {,         return workbook;,     }, ,     public int getNumberOfNames(){,         int result = names.size();,         return result;,     }, ,     public HSSFName getName(String name) {,         int nameIndex = getNameIndex(name);,         if (nameIndex < 0) {,             return null;,         },         return (HSSFName) names.get(nameIndex);,     }, ,     public HSSFName getNameAt(int nameIndex) {,         int nNames = names.size();,         if (nNames < 1) {,             throw new IllegalStateException("There are no defined names in this workbook");,         },         if (nameIndex < 0 || nameIndex > nNames) {,             throw new IllegalArgumentException("Specified name index " + nameIndex,                     + " is outside the allowable range (0.." + (nNames-1) + ").");,         },         return (HSSFName) names.get(nameIndex);,     }, ,     public NameRecord getNameRecord(int nameIndex) {,         return getWorkbook().getNameRecord(nameIndex);,     }, ,     /** gets the named range name,      * @param index the named range index (0 based),      * @return named range name,      */,     public String getNameName(int index){,         String result = getNameAt(index).getNameName();, ,         return result;,     }, ,     /**,      * Sets the printarea for the sheet provided,      * <p>,      * i.e. Reference = $A$1:$B$2,      * @param sheetIndex Zero-based sheet index (0 Represents the first sheet to keep consistent with java),      * @param reference Valid name Reference for the Print Area,      */,     public void setPrintArea(int sheetIndex, String reference),     {,         NameRecord name = workbook.getSpecificBuiltinRecord(NameRecord.BUILTIN_PRINT_AREA, sheetIndex+1);, , ,         if (name == null) {,             name = workbook.createBuiltInName(NameRecord.BUILTIN_PRINT_AREA, sheetIndex+1);,             // adding one here because 0 indicates a global named region; doesn't make sense for print areas,         },         String[] parts = COMMA_PATTERN.split(reference);,         StringBuffer sb = new StringBuffer(32);,         for (int i = 0; i < parts.length; i++) {,             if(i>0) {,                 sb.append(",");,             },             SheetNameFormatter.appendFormat(sb, getSheetName(sheetIndex));,             sb.append("!");,             sb.append(parts[i]);,         },         name.setNameDefinition(HSSFFormulaParser.parse(sb.toString(), this, FormulaType.NAMEDRANGE, sheetIndex));,     }, ,     /**,      * For the Convenience of Java Programmers maintaining pointers.,      * @see #setPrintArea(int, String),      * @param sheetIndex Zero-based sheet index (0 = First Sheet),      * @param startColumn Column to begin printarea,      * @param endColumn Column to end the printarea,      * @param startRow Row to begin the printarea,      * @param endRow Row to end the printarea,      */,     public void setPrintArea(int sheetIndex, int startColumn, int endColumn,,                               int startRow, int endRow) {, ,         //using absolute references because they don't get copied and pasted anyway,         CellReference cell = new CellReference(startRow, startColumn, true, true);,         String reference = cell.formatAsString();, ,         cell = new CellReference(endRow, endColumn, true, true);,         reference = reference+":"+cell.formatAsString();, ,         setPrintArea(sheetIndex, reference);,     }, , ,     /**,      * Retrieves the reference for the printarea of the specified sheet, the sheet name is appended to the reference even if it was not specified.,      * @param sheetIndex Zero-based sheet index (0 Represents the first sheet to keep consistent with java),      * @return String Null if no print area has been defined,      */,     public String getPrintArea(int sheetIndex) {,         NameRecord name = workbook.getSpecificBuiltinRecord(NameRecord.BUILTIN_PRINT_AREA, sheetIndex+1);,         //adding one here because 0 indicates a global named region; doesn't make sense for print areas,         if (name == null) {,             return null;,         }, ,         return HSSFFormulaParser.toFormulaString(this, name.getNameDefinition());,     }, ,     /**,      * Delete the printarea for the sheet specified,      * @param sheetIndex Zero-based sheet index (0 = First Sheet),      */,     public void removePrintArea(int sheetIndex) {,         getWorkbook().removeBuiltinRecord(NameRecord.BUILTIN_PRINT_AREA, sheetIndex+1);,     }, ,     /** creates a new named range and add it to the model,      * @return named range high level,      */,     public HSSFName createName(){,         NameRecord nameRecord = workbook.createName();, ,         HSSFName newName = new HSSFName(this, nameRecord);, ,         names.add(newName);, ,         return newName;,     }, ,     public int getNameIndex(String name) {, ,         for (int k = 0; k < names.size(); k++) {,             String nameName = getNameName(k);, ,             if (nameName.equalsIgnoreCase(name)) {,                 return k;,             },         },         return -1;,     }, , ,     public void removeName(int index){,         names.remove(index);,         workbook.removeName(index);,     }, ,     /**,      * Returns the instance of HSSFDataFormat for this workbook.,      * @return the HSSFDataFormat object,      * @see org.apache.poi.hssf.record.FormatRecord,      * @see org.apache.poi.hssf.record.Record,      */,     public HSSFDataFormat createDataFormat() {,     if (formatter == null),         formatter = new HSSFDataFormat(workbook);,     return formatter;,     }, , ,     public void removeName(String name) {,         int index = getNameIndex(name);, ,         removeName(index);,     }, ,     public HSSFPalette getCustomPalette(),     {,         return new HSSFPalette(workbook.getCustomPalette());,     }, ,     /** Test only. Do not use */,     public void insertChartRecord(),     {,         int loc = workbook.findFirstRecordLocBySid(SSTRecord.sid);,         byte[] data = {,            (byte)0x0F, (byte)0x00, (byte)0x00, (byte)0xF0, (byte)0x52,,            (byte)0x00, (byte)0x00, (byte)0x00, (byte)0x00, (byte)0x00,,            (byte)0x06, (byte)0xF0, (byte)0x18, (byte)0x00, (byte)0x00,,            (byte)0x00, (byte)0x01, (byte)0x08, (byte)0x00, (byte)0x00,,            (byte)0x02, (byte)0x00, (byte)0x00, (byte)0x00, (byte)0x02,,            (byte)0x00, (byte)0x00, (byte)0x00, (byte)0x01, (byte)0x00,,            (byte)0x00, (byte)0x00, (byte)0x01, (byte)0x00, (byte)0x00,,            (byte)0x00, (byte)0x03, (byte)0x00, (byte)0x00, (byte)0x00,,            (byte)0x33, (byte)0x00, (byte)0x0B, (byte)0xF0, (byte)0x12,,            (byte)0x00, (byte)0x00, (byte)0x00, (byte)0xBF, (byte)0x00,,            (byte)0x08, (byte)0x00, (byte)0x08, (byte)0x00, (byte)0x81,,            (byte)0x01, (byte)0x09, (byte)0x00, (byte)0x00, (byte)0x08,,            (byte)0xC0, (byte)0x01, (byte)0x40, (byte)0x00, (byte)0x00,,            (byte)0x08, (byte)0x40, (byte)0x00, (byte)0x1E, (byte)0xF1,,            (byte)0x10, (byte)0x00, (byte)0x00, (byte)0x00, (byte)0x0D,,            (byte)0x00, (byte)0x00, (byte)0x08, (byte)0x0C, (byte)0x00,,            (byte)0x00, (byte)0x08, (byte)0x17, (byte)0x00, (byte)0x00,,            (byte)0x08, (byte)0xF7, (byte)0x00, (byte)0x00, (byte)0x10,,         };,         UnknownRecord r = new UnknownRecord((short)0x00EB, data);,         workbook.getRecords().add(loc, r);,     }, ,     /**,      * Spits out a list of all the drawing records in the workbook.,      */,     public void dumpDrawingGroupRecords(boolean fat),     {,         DrawingGroupRecord r = (DrawingGroupRecord) workbook.findFirstRecordBySid( DrawingGroupRecord.sid );,         r.decode();,         List escherRecords = r.getEscherRecords();,         PrintWriter w = new PrintWriter(System.out);,         for ( Iterator iterator = escherRecords.iterator(); iterator.hasNext(); ),         {,             EscherRecord escherRecord = (EscherRecord) iterator.next();,             if (fat),                 System.out.println(escherRecord.toString());,             else,                 escherRecord.display(w, 0);,         },         w.flush();,     }, ,     void initDrawings(){,         DrawingManager2 mgr = workbook.findDrawingGroup();,         if(mgr != null) {,             for(int i=0; i < getNumberOfSheets(); i++)  {,                 getSheetAt(i).getDrawingPatriarch();,             },         } else {,             workbook.createDrawingGroup();,         },     }, ,     /**,      * Adds a picture to the workbook.,      *,      * @param pictureData       The bytes of the picture,      * @param format            The format of the picture.  One of <code>PICTURE_TYPE_*</code>,      *,      * @return the index to this picture (1 based).,      */,     public int addPicture(byte[] pictureData, int format),     {,         initDrawings();,         ,         byte[] uid = DigestUtils.md5(pictureData);,         EscherBitmapBlip blipRecord = new EscherBitmapBlip();,         blipRecord.setRecordId( (short) ( EscherBitmapBlip.RECORD_ID_START + format ) );,         switch (format),         {,             case PICTURE_TYPE_EMF:,                 blipRecord.setOptions(HSSFPictureData.MSOBI_EMF);,                 break;,             case PICTURE_TYPE_WMF:,                 blipRecord.setOptions(HSSFPictureData.MSOBI_WMF);,                 break;,             case PICTURE_TYPE_PICT:,                 blipRecord.setOptions(HSSFPictureData.MSOBI_PICT);,                 break;,             case PICTURE_TYPE_PNG:,                 blipRecord.setOptions(HSSFPictureData.MSOBI_PNG);,                 break;,             case HSSFWorkbook.PICTURE_TYPE_JPEG:,                 blipRecord.setOptions(HSSFPictureData.MSOBI_JPEG);,                 break;,             case HSSFWorkbook.PICTURE_TYPE_DIB:,                 blipRecord.setOptions(HSSFPictureData.MSOBI_DIB);,                 break;,         }, ,         blipRecord.setUID( uid );,         blipRecord.setMarker( (byte) 0xFF );,         blipRecord.setPictureData( pictureData );, ,         EscherBSERecord r = new EscherBSERecord();,         r.setRecordId( EscherBSERecord.RECORD_ID );,         r.setOptions( (short) ( 0x0002 | ( format << 4 ) ) );,         r.setBlipTypeMacOS( (byte) format );,         r.setBlipTypeWin32( (byte) format );,         r.setUid( uid );,         r.setTag( (short) 0xFF );,         r.setSize( pictureData.length + 25 );,         r.setRef( 1 );,         r.setOffset( 0 );,         r.setBlipRecord( blipRecord );, ,         return workbook.addBSERecord( r );,     }, ,     /**,      * Gets all pictures from the Workbook.,      *,      * @return the list of pictures (a list of {@link HSSFPictureData} objects.),      */,     public List<HSSFPictureData> getAllPictures(),     {,         // The drawing group record always exists at the top level, so we won't need to do this recursively.,         List<HSSFPictureData> pictures = new ArrayList<HSSFPictureData>();,         Iterator<Record> recordIter = workbook.getRecords().iterator();,         while (recordIter.hasNext()),         {,             Record r = recordIter.next();,             if (r instanceof AbstractEscherHolderRecord),             {,                 ((AbstractEscherHolderRecord) r).decode();,                 List<EscherRecord> escherRecords = ((AbstractEscherHolderRecord) r).getEscherRecords();,                 searchForPictures(escherRecords, pictures);,             },         },         return pictures;,     }, ,     /**,      * Performs a recursive search for pictures in the given list of escher records.,      *,      * @param escherRecords the escher records.,      * @param pictures the list to populate with the pictures.,      */,     private void searchForPictures(List<EscherRecord> escherRecords, List<HSSFPictureData> pictures),     {,         for(EscherRecord escherRecord : escherRecords) {, ,             if (escherRecord instanceof EscherBSERecord),             {,                 EscherBlipRecord blip = ((EscherBSERecord) escherRecord).getBlipRecord();,                 if (blip != null),                 {,                     // TODO: Some kind of structure.,                     HSSFPictureData picture = new HSSFPictureData(blip);, 					pictures.add(picture);,                 },                 ,                 ,             }, ,             // Recursive call.,             searchForPictures(escherRecord.getChildRecords(), pictures);,         },         ,     }, ,     /**,      * Is the workbook protected with a password (not encrypted)?,      */,     public boolean isWriteProtected() {,         return this.workbook.isWriteProtected();,     }, ,     /**,      * protect a workbook with a password (not encypted, just sets writeprotect,      * flags and the password.,      * @param password to set,      */,     public void writeProtectWorkbook( String password, String username ) {,        this.workbook.writeProtectWorkbook(password, username);,     }, ,     /**,      * removes the write protect flag,      */,     public void unwriteProtectWorkbook() {,        this.workbook.unwriteProtectWorkbook();,     }, ,     /**,      * Gets all embedded OLE2 objects from the Workbook.,      *,      * @return the list of embedded objects (a list of {@link HSSFObjectData} objects.),      */,     public List<HSSFObjectData> getAllEmbeddedObjects(),     {,         List<HSSFObjectData> objects = new ArrayList<HSSFObjectData>();,         for (int i = 0; i < getNumberOfSheets(); i++),         {,             getAllEmbeddedObjects(getSheetAt(i).getSheet().getRecords(), objects);,         },         return objects;,     }, ,     /**,      * Gets all embedded OLE2 objects from the Workbook.,      *,      * @param records the list of records to search.,      * @param objects the list of embedded objects to populate.,      */,     private void getAllEmbeddedObjects(List<RecordBase> records, List<HSSFObjectData> objects),     {,        for (RecordBase obj : records) {,           if (obj instanceof ObjRecord),           {,              // TODO: More convenient way of determining if there is stored binary.,              // TODO: Link to the data stored in the other stream.,              Iterator<SubRecord> subRecordIter = ((ObjRecord) obj).getSubRecords().iterator();,              while (subRecordIter.hasNext()),              {,                 SubRecord sub = subRecordIter.next();,                 if (sub instanceof EmbeddedObjectRefSubRecord),                 {,                    objects.add(new HSSFObjectData((ObjRecord) obj, directory));,                 },              },           },        },     }, ,     public HSSFCreationHelper getCreationHelper() {,         return new HSSFCreationHelper(this);,     }, ,     /**,      *,      * Returns the locator of user-defined functions.,      * The default instance extends the built-in functions with the Analysis Tool Pack,      *,      * @return the locator of user-defined functions,      */,     /*package*/ UDFFinder getUDFFinder(){,         return _udfFinder;,     }, ,     /**,      * Register a new toolpack in this workbook.,      *,      * @param toopack the toolpack to register,      */,     public void addToolPack(UDFFinder toopack){,         AggregatingUDFFinder udfs = (AggregatingUDFFinder)_udfFinder;,         udfs.add(toopack);,     }, ,     /**,      * Whether the application shall perform a full recalculation when the workbook is opened.,      * <p>,      * Typically you want to force formula recalculation when you modify cell formulas or values,      * of a workbook previously created by Excel. When set to true, this flag will tell Excel,      * that it needs to recalculate all formulas in the workbook the next time the file is opened.,      * </p>,      * <p>,      * Note, that recalculation updates cached formula results and, thus, modifies the workbook.,      * Depending on the version, Excel may prompt you with "Do you want to save the changes in <em>filename</em>?",      * on close.,      * </p>,      *,      * @param value true if the application will perform a full recalculation of,      * workbook values when the workbook is opened,      * @since 3.8,      */,     public void setForceFormulaRecalculation(boolean value){,         InternalWorkbook iwb = getWorkbook();,         RecalcIdRecord recalc = iwb.getRecalcId();,         recalc.setEngineId(0);,     }, ,     /**,      * Whether Excel will be asked to recalculate all formulas when the  workbook is opened.,      *,      * @since 3.8,      */,     public boolean getForceFormulaRecalculation(){,         InternalWorkbook iwb = getWorkbook();,         RecalcIdRecord recalc = (RecalcIdRecord)iwb.findFirstRecordBySid(RecalcIdRecord.sid);,         return recalc != null && recalc.getEngineId() != 0;],,
BAD_PRACTICE,SW_SWING_METHODS_INVOKED_IN_SWING_THREAD,org/apache/poi/hssf/view/SViewerPanel.java,main,286-286,[      frame.setVisible(true);],,
BAD_PRACTICE,RR_NOT_CHECKED,org/apache/poi/hwpf/HWPFDocFixture.java,setUp,50-50,[      filesystem.createDocumentInputStream("WordDocument").read(_mainStream);],,setUp,65-65,[      filesystem.createDocumentInputStream(name).read(_tableStream);],,
BAD_PRACTICE,DE_MIGHT_IGNORE,org/apache/poi/hwpf/HWPFDocument.java,<init>,287-287,[        catch ( Exception exc )],,
BAD_PRACTICE,RR_NOT_CHECKED,org/apache/poi/hwpf/HWPFDocument.java,<init>,243-243,[    directory.createDocumentInputStream(name).read(_tableStream);],,<init>,253-253,[      directory.createDocumentInputStream(STREAM_DATA).read(_dataStream);],,
BAD_PRACTICE,RR_NOT_CHECKED,org/apache/poi/hwpf/HWPFDocumentCore.java,<init>,153-153,[    directory.createDocumentInputStream(STREAM_WORD_DOCUMENT).read(_mainStream);],,
BAD_PRACTICE,RR_NOT_CHECKED,org/apache/poi/hwpf/HWPFDocumentCore.java,verifyAndBuildPOIFS,96-96,[	pis.read(first6);],,
BAD_PRACTICE,DE_MIGHT_IGNORE,org/apache/poi/hwpf/HWPFOldDocument.java,<init>,128-128,[        catch ( Exception exc )],,
STYLE,DMI_HARDCODED_ABSOLUTE_FILENAME,org/apache/poi/hwpf/Word2Forrest.java,main,214-214,[      OutputStream out = new FileOutputStream("c:\\test.xml");],,
I18N,DM_DEFAULT_ENCODING,org/apache/poi/hwpf/converter/AbstractWordConverter.java,processCharacters,494-494,[            if ( text.getBytes().length == 0 )],,processCharacters,522-522,[            if ( text.getBytes()[0] == FIELD_BEGIN_MARK )],,processCharacters,558-558,[            if ( text.getBytes()[0] == FIELD_SEPARATOR_MARK )],,processCharacters,563-563,[            if ( text.getBytes()[0] == FIELD_END_MARK )],,
I18N,DM_DEFAULT_ENCODING,org/apache/poi/hwpf/converter/AbstractWordConverter.java,tryDeadField_lookupFieldSeparatorEnd,1143-1143,[            if ( text.getBytes().length == 0 )],,tryDeadField_lookupFieldSeparatorEnd,1146-1146,[            final byte firstByte = text.getBytes()[0];],,tryDeadField_lookupFieldSeparatorEnd,1170-1170,[            if ( text.getBytes()[0] == FIELD_END_MARK )],,
STYLE,ICAST_IDIV_CAST_TO_DOUBLE,org/apache/poi/hwpf/converter/AbstractWordConverter.java,processImage,895-895,[            final float imageWidth = aspectRatioX > 0 ? picture.getDxaGoal()],,processImage,898-898,[            final float imageHeight = aspectRatioY > 0 ? picture.getDyaGoal()],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/poi/hwpf/converter/AbstractWordConverter.java,tryDeadField_lookupFieldSeparatorEnd,1163-1163,[                    return null;],,tryDeadField_lookupFieldSeparatorEnd,1175-1175,[                    return null;],,tryDeadField_lookupFieldSeparatorEnd,1184-1184,[            return null;],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/poi/hwpf/converter/AbstractWordConverter.java,processCharacters,334-334,[                if ( text == null || text.length() == 0],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/poi/hwpf/converter/AbstractWordConverter.java,,374-378,[                {,                     @Override,                     public String toString(),                     {,                         return "BetweenStructuresSubrange " + super.toString();],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/poi/hwpf/converter/AbstractWordConverter.java,,407-411,[                    {,                         @Override,                         public String toString(),                         {,                             return "BookmarksSubrange " + super.toString();],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/poi/hwpf/converter/AbstractWordConverter.java,,460-464,[                {,                     @Override,                     public String toString(),                     {,                         return "AfterStructureSubrange " + super.toString();],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/poi/hwpf/converter/AbstractWordConverter.java,,633-637,[            {,                 @Override,                 public String toString(),                 {,                     return "Dead field formula subrange: " + super.toString();],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/poi/hwpf/converter/AbstractWordConverter.java,,643-647,[            {,                 @Override,                 public String toString(),                 {,                     return "Dead field value subrange: " + super.toString();],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/poi/hwpf/converter/AbstractWordConverter.java,,673-677,[        {,             @Override,             public String toString(),             {,                 return "DeadFieldValueSubrange (" + super.toString() + ")";],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/poi/hwpf/converter/AbstractWordConverter.java,,855-859,[                        {,                             @Override,                             public String toString(),                             {,                                 return "Local hyperlink text";],,
BAD_PRACTICE,EQ_COMPARETO_USE_OBJECT_EQUALS,org/apache/poi/hwpf/converter/AbstractWordConverter.java,compareTo,105-105,[            return start < o.start ? -1 : start == o.start ? 0 : 1;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/poi/hwpf/converter/DefaultFontReplacer.java,update,30-30,[            if ( fontName.endsWith( " Regular" ) )],,
I18N,DM_CONVERT_CASE,org/apache/poi/hwpf/converter/NumberFormatter.java,getNumber,55-55,[            return toRoman( num ).toUpperCase();],,getNumber,59-59,[            return toLetters( num ).toUpperCase();],,
STYLE,INT_VACUOUS_COMPARISON,org/apache/poi/hwpf/converter/NumberFormatter.java,toLetters,90-90,[                if ( boundary > Integer.MAX_VALUE )],,
BAD_PRACTICE,DE_MIGHT_IGNORE,org/apache/poi/hwpf/converter/TestWordToConverterSuite.java,testFo,97-97,[        catch ( Exception exc )],,
BAD_PRACTICE,DE_MIGHT_IGNORE,org/apache/poi/hwpf/converter/TestWordToConverterSuite.java,testHtml,127-127,[        catch ( Exception exc )],,
BAD_PRACTICE,DE_MIGHT_IGNORE,org/apache/poi/hwpf/converter/TestWordToConverterSuite.java,testText,158-158,[        catch ( Exception exc )],,
STYLE,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,org/apache/poi/hwpf/converter/TestWordToConverterSuite.java,suite,53-53,[        for ( final File child : directory.listFiles( new FilenameFilter()],,
STYLE,RV_RETURN_VALUE_IGNORED_NO_SIDE_EFFECT,org/apache/poi/hwpf/converter/TestWordToConverterSuite.java,testText,179-179,[        stringWriter.toString();],,
I18N,DM_DEFAULT_ENCODING,org/apache/poi/hwpf/converter/WordToFoConverter.java,main,91-91,[            FileWriter out = new FileWriter( args[1] );],,
I18N,DM_DEFAULT_ENCODING,org/apache/poi/hwpf/converter/WordToHtmlConverter.java,main,136-136,[            FileWriter out = new FileWriter( args[1] );],,
STYLE,ICAST_IDIV_CAST_TO_DOUBLE,org/apache/poi/hwpf/converter/WordToHtmlConverter.java,processImage,339-339,[            imageWidth = picture.getDxaGoal() * aspectRatioX / 1000],,processImage,341-341,[            cropRight = picture.getDxaCropRight() * aspectRatioX / 1000],,processImage,343-343,[            cropLeft = picture.getDxaCropLeft() * aspectRatioX / 1000],,processImage,355-355,[            imageHeight = picture.getDyaGoal() * aspectRatioY / 1000],,processImage,357-357,[            cropTop = picture.getDyaCropTop() * aspectRatioY / 1000],,processImage,359-359,[            cropBottom = picture.getDyaCropBottom() * aspectRatioY / 1000],,
STYLE,UC_USELESS_OBJECT,org/apache/poi/hwpf/converter/WordToHtmlConverter.java,processImage,327-327,[        StringBuilder style = new StringBuilder();],,
I18N,DM_DEFAULT_ENCODING,org/apache/poi/hwpf/converter/WordToTextConverter.java,main,109-109,[            FileWriter out = new FileWriter( args[1] );],,
STYLE,REC_CATCH_EXCEPTION,org/apache/poi/hwpf/converter/WordToTextConverter.java,processOle2,392-392,[        catch ( Exception exc )],,
MALICIOUS_CODE,DP_DO_INSIDE_DO_PRIVILEGED,org/apache/poi/hwpf/dev/HWPFLister.java,dumpFileSystem,462-462,[        field.setAccessible( true );],,
MALICIOUS_CODE,DP_DO_INSIDE_DO_PRIVILEGED,org/apache/poi/hwpf/dev/HWPFLister.java,dumpPapx,535-535,[            fMainStream.setAccessible( true );],,dumpPapx,591-591,[        _props.setAccessible( true );],,
MALICIOUS_CODE,DP_DO_INSIDE_DO_PRIVILEGED,org/apache/poi/hwpf/dev/HWPFLister.java,dumpPapx,588-588,[        newParagraph.setAccessible( true );],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/poi/hwpf/dev/HWPFLister.java,,389-392,[                {,                     public String toString(),                     {,                         return "CHPX range (" + super.toString() + ")";],,
PERFORMANCE,DM_STRING_VOID_CTOR,org/apache/poi/hwpf/dev/RecordUtil.java,getBitFieldFunction,38-38,[        String retVal = new String();],,
STYLE,RV_RETURN_VALUE_IGNORED_NO_SIDE_EFFECT,org/apache/poi/hwpf/extractor/TestWordExtractorBugs.java,testProblemMetadata,39-39,[		extractor.getTextFromPieces();],,
CORRECTNESS,RV_RETURN_VALUE_IGNORED,org/apache/poi/hwpf/extractor/Word6Extractor.java,getParagraphText,111-111,[	            ret[i].replaceAll("\r", "\ufffe");],,getParagraphText,112-112,[                ret[i].replaceAll("\ufffe","\r\n");],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/poi/hwpf/model/CHPBinTable.java,,201-206,[        {,             public int compare( CHPX o1, CHPX o2 ),             {,                 Integer i1 = chpxToFileOrder.get( o1 );,                 Integer i2 = chpxToFileOrder.get( o2 );,                 return i1.compareTo( i2 );],,
BAD_PRACTICE,CN_IDIOM_NO_SUPER_CALL,org/apache/poi/hwpf/model/Colorref.java,clone,92-92,[        return new Colorref( this.value );],,
BAD_PRACTICE,BC_EQUALS_METHOD_SHOULD_WORK_FOR_ALL_OBJECTS,org/apache/poi/hwpf/model/Ffn.java,equals,188-188,[    if (((Ffn)o).get_cbFfnM1() == _cbFfnM1)],,
BAD_PRACTICE,HE_EQUALS_USE_HASHCODE,org/apache/poi/hwpf/model/Ffn.java,equals,186-226,[    boolean retVal = true;, ,     if (((Ffn)o).get_cbFfnM1() == _cbFfnM1),     {,       if(((Ffn)o)._info == _info),       {,       if(((Ffn)o)._wWeight == _wWeight),       {,         if(((Ffn)o)._chs == _chs),         {,         if(((Ffn)o)._ixchSzAlt == _ixchSzAlt),         {,           if(Arrays.equals(((Ffn)o)._panose,_panose)),           {,           if(Arrays.equals(((Ffn)o)._fontSig,_fontSig)),           {,                   if(!(Arrays.equals(((Ffn)o)._xszFfn,_xszFfn))),                     retVal = false;,           },           else,             retVal = false;,           },           else,           retVal = false;,         },         else,           retVal = false;,         },         else,         retVal = false;,       },       else,         retVal = false;,       },       else,       retVal = false;,     },     else,       retVal = false;, ,     return retVal;],,
BAD_PRACTICE,NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT,org/apache/poi/hwpf/model/Ffn.java,equals,186-226,[    boolean retVal = true;, ,     if (((Ffn)o).get_cbFfnM1() == _cbFfnM1),     {,       if(((Ffn)o)._info == _info),       {,       if(((Ffn)o)._wWeight == _wWeight),       {,         if(((Ffn)o)._chs == _chs),         {,         if(((Ffn)o)._ixchSzAlt == _ixchSzAlt),         {,           if(Arrays.equals(((Ffn)o)._panose,_panose)),           {,           if(Arrays.equals(((Ffn)o)._fontSig,_fontSig)),           {,                   if(!(Arrays.equals(((Ffn)o)._xszFfn,_xszFfn))),                     retVal = false;,           },           else,             retVal = false;,           },           else,           retVal = false;,         },         else,           retVal = false;,         },         else,         retVal = false;,       },       else,         retVal = false;,       },       else,       retVal = false;,     },     else,       retVal = false;, ,     return retVal;],,
BAD_PRACTICE,CN_IDIOM,org/apache/poi/hwpf/model/FileInformationBlock.java,,49-1057,[@Internal, public final class FileInformationBlock implements Cloneable, {,     public static final POILogger logger = POILogFactory,             .getLogger( FileInformationBlock.class );, ,     private FibBase _fibBase;,     private int _csw;,     private FibRgW97 _fibRgW;,     private int _cslw;,     private FibRgLw _fibRgLw;,     private int _cbRgFcLcb;,     private FIBFieldHandler _fieldHandler;,     private int _cswNew;,     private int _nFibNew;,     private byte[] _fibRgCswNew;, ,     /** Creates a new instance of FileInformationBlock */,     public FileInformationBlock( byte[] mainDocument ),     {,         int offset = 0;, ,         _fibBase = new FibBase( mainDocument, offset );,         offset = FibBase.getSize();,         assert offset == 32;, ,         if ( _fibBase.isFEncrypted() ),         {,             throw new EncryptedDocumentException(,                     "Cannot process encrypted word file" );,         }, ,         _csw = LittleEndian.getUShort( mainDocument, offset );,         offset += LittleEndian.SHORT_SIZE;,         assert offset == 34;, ,         _fibRgW = new FibRgW97( mainDocument, offset );,         offset += FibRgW97.getSize();,         assert offset == 62;, ,         _cslw = LittleEndian.getUShort( mainDocument, offset );,         offset += LittleEndian.SHORT_SIZE;,         assert offset == 64;, ,         if ( _fibBase.getNFib() < 105 ),         {,             _fibRgLw = new FibRgLw95( mainDocument, offset );,             offset += FibRgLw97.getSize();, ,             // magic number, run tests after changes,             _cbRgFcLcb = 74;, ,             // skip fibRgFcLcbBlob (read later at fillVariableFields),             offset += _cbRgFcLcb * LittleEndian.INT_SIZE * 2;, ,             _cswNew = LittleEndian.getUShort( mainDocument, offset );,             offset += LittleEndian.SHORT_SIZE;, ,             _cswNew = 0;,             _nFibNew = -1;,             _fibRgCswNew = new byte[0];, ,             return;,         }, ,         _fibRgLw = new FibRgLw97( mainDocument, offset );,         offset += FibRgLw97.getSize();,         assert offset == 152;, ,         _cbRgFcLcb = LittleEndian.getUShort( mainDocument, offset );,         offset += LittleEndian.SHORT_SIZE;,         assert offset == 154;, ,         // skip fibRgFcLcbBlob (read later at fillVariableFields),         offset += _cbRgFcLcb * LittleEndian.INT_SIZE * 2;, ,         _cswNew = LittleEndian.getUShort( mainDocument, offset );,         offset += LittleEndian.SHORT_SIZE;, ,         if ( _cswNew != 0 ),         {,             _nFibNew = LittleEndian.getUShort( mainDocument, offset );,             offset += LittleEndian.SHORT_SIZE;, ,             // first short is already read as _nFibNew,             final int fibRgCswNewLength = ( _cswNew - 1 ),                     * LittleEndian.SHORT_SIZE;,             _fibRgCswNew = new byte[fibRgCswNewLength];,             LittleEndian.getByteArray( mainDocument, offset, fibRgCswNewLength );,             offset += fibRgCswNewLength;,         },         else,         {,             _nFibNew = -1;,             _fibRgCswNew = new byte[0];,         }, ,         assertCbRgFcLcb();,         assertCswNew();,     }, ,     private void assertCbRgFcLcb(),     {,         switch ( getNFib() ),         {,         case 0x00C1:,             assertCbRgFcLcb( "0x00C1", 0x005D, "0x005D", _cbRgFcLcb );,             break;,         case 0x00D9:,             assertCbRgFcLcb( "0x00D9", 0x006C, "0x006C", _cbRgFcLcb );,             break;,         case 0x0101:,             assertCbRgFcLcb( "0x0101", 0x0088, "0x0088", _cbRgFcLcb );,             break;,         case 0x010C:,             assertCbRgFcLcb( "0x010C", 0x00A4, "0x00A4", _cbRgFcLcb );,             break;,         case 0x0112:,             assertCbRgFcLcb( "0x0112", 0x00B7, "0x00B7", _cbRgFcLcb );,             break;,         },     }, ,     private static void assertCbRgFcLcb( final String strNFib,,             final int expectedCbRgFcLcb, final String strCbRgFcLcb,,             final int cbRgFcLcb ),     {,         if ( cbRgFcLcb == expectedCbRgFcLcb ),             return;, ,         logger.log( POILogger.WARN, "Since FIB.nFib == ", strNFib,,                 " value of FIB.cbRgFcLcb MUST be ", strCbRgFcLcb + ", not 0x",,                 Integer.toHexString( cbRgFcLcb ) );,     }, ,     private void assertCswNew(),     {,         switch ( getNFib() ),         {,         case 0x00C1:,             assertCswNew( "0x00C1", 0x0000, "0x0000", _cswNew );,             break;,         case 0x00D9:,             assertCswNew( "0x00D9", 0x0002, "0x0002", _cswNew );,             break;,         case 0x0101:,             assertCswNew( "0x0101", 0x0002, "0x0002", _cswNew );,             break;,         case 0x010C:,             assertCswNew( "0x010C", 0x0002, "0x0002", _cswNew );,             break;,         case 0x0112:,             assertCswNew( "0x0112", 0x0005, "0x0005", _cswNew );,             break;,         },     }, ,     private static void assertCswNew( final String strNFib,,             final int expectedCswNew, final String strExpectedCswNew,,             final int cswNew ),     {,         if ( cswNew == expectedCswNew ),             return;, ,         logger.log( POILogger.WARN, "Since FIB.nFib == ", strNFib,,                 " value of FIB.cswNew MUST be ",,                 strExpectedCswNew + ", not 0x", Integer.toHexString( cswNew ) );,     }, ,     public void fillVariableFields( byte[] mainDocument, byte[] tableStream ),     {,         /*,          * Listed fields won't be treat as UnhandledDataStructure. For all other,          * fields FIBFieldHandler will load it content into,          * UnhandledDataStructure and save them on save.,          */,         HashSet<Integer> knownFieldSet = new HashSet<Integer>();,         knownFieldSet.add( Integer.valueOf( FIBFieldHandler.STSHF ) );,         knownFieldSet.add( Integer.valueOf( FIBFieldHandler.CLX ) );,         knownFieldSet.add( Integer.valueOf( FIBFieldHandler.DOP ) );,         knownFieldSet.add( Integer.valueOf( FIBFieldHandler.PLCFBTECHPX ) );,         knownFieldSet.add( Integer.valueOf( FIBFieldHandler.PLCFBTEPAPX ) );,         knownFieldSet.add( Integer.valueOf( FIBFieldHandler.PLCFSED ) );,         knownFieldSet.add( Integer.valueOf( FIBFieldHandler.PLCFLST ) );,         knownFieldSet.add( Integer.valueOf( FIBFieldHandler.PLFLFO ) );, ,         // field info,         for ( FieldsDocumentPart part : FieldsDocumentPart.values() ),             knownFieldSet.add( Integer.valueOf( part.getFibFieldsField() ) );, ,         // bookmarks,         knownFieldSet.add( Integer.valueOf( FIBFieldHandler.PLCFBKF ) );,         knownFieldSet.add( Integer.valueOf( FIBFieldHandler.PLCFBKL ) );,         knownFieldSet.add( Integer.valueOf( FIBFieldHandler.STTBFBKMK ) );, ,         // notes,         for ( NoteType noteType : NoteType.values() ),         {,             knownFieldSet.add( Integer.valueOf( noteType,                     .getFibDescriptorsFieldIndex() ) );,             knownFieldSet.add( Integer.valueOf( noteType,                     .getFibTextPositionsFieldIndex() ) );,         }, ,         knownFieldSet.add( Integer.valueOf( FIBFieldHandler.STTBFFFN ) );,         knownFieldSet.add( Integer.valueOf( FIBFieldHandler.STTBFRMARK ) );,         knownFieldSet.add( Integer.valueOf( FIBFieldHandler.STTBSAVEDBY ) );,         knownFieldSet.add( Integer.valueOf( FIBFieldHandler.MODIFIED ) );, ,         _fieldHandler = new FIBFieldHandler( mainDocument, 154, _cbRgFcLcb,,                 tableStream, knownFieldSet, true );,     }, ,     @Override,     public String toString(),     {,         StringBuilder stringBuilder = new StringBuilder(  );,         stringBuilder.append( _fibBase );,         stringBuilder.append( "[FIB2]\n" );,         stringBuilder.append( "\tSubdocuments info:\n" );,         for ( SubdocumentType type : SubdocumentType.values() ),         {,             stringBuilder.append( "\t\t" );,             stringBuilder.append( type );,             stringBuilder.append( " has length of " );,             stringBuilder.append( getSubdocumentTextStreamLength( type ) );,             stringBuilder.append( " char(s)\n" );,         },         stringBuilder.append( "\tFields PLCF info:\n" );,         for ( FieldsDocumentPart part : FieldsDocumentPart.values() ),         {,             stringBuilder.append( "\t\t" );,             stringBuilder.append( part );,             stringBuilder.append( ": PLCF starts at " );,             stringBuilder.append( getFieldsPlcfOffset( part ) );,             stringBuilder.append( " and have length of " );,             stringBuilder.append( getFieldsPlcfLength( part ) );,             stringBuilder.append( "\n" );,         },         stringBuilder.append( "\tNotes PLCF info:\n" );,         for ( NoteType noteType : NoteType.values() ),         {,             stringBuilder.append( "\t\t" );,             stringBuilder.append( noteType );,             stringBuilder.append( ": descriptions starts " );,             stringBuilder.append( getNotesDescriptorsOffset( noteType ) );,             stringBuilder.append( " and have length of " );,             stringBuilder.append( getNotesDescriptorsSize( noteType ) );,             stringBuilder.append( " bytes\n" );,             stringBuilder.append( "\t\t" );,             stringBuilder.append( noteType );,             stringBuilder.append( ": text positions starts " );,             stringBuilder.append( getNotesTextPositionsOffset( noteType ) );,             stringBuilder.append( " and have length of " );,             stringBuilder.append( getNotesTextPositionsSize( noteType ) );,             stringBuilder.append( " bytes\n" );,         },         stringBuilder.append( _fieldHandler );,         try,         {,             stringBuilder.append( "\tJava reflection info:\n" );,             for ( Method method : FileInformationBlock.class.getMethods() ),             {,                 if ( !method.getName().startsWith( "get" ),                         || !Modifier.isPublic( method.getModifiers() ),                         || Modifier.isStatic( method.getModifiers() ),                         || method.getParameterTypes().length > 0 ),                     continue;,                 stringBuilder.append( "\t\t" );,                 stringBuilder.append( method.getName() );,                 stringBuilder.append( " => " );,                 stringBuilder.append( method.invoke( this ) );,                 stringBuilder.append( "\n" );,             },         },         catch ( Exception exc ),         {,             stringBuilder.append( "(exc: " + exc.getMessage() + ")" );,         },         stringBuilder.append( "[/FIB2]\n" );,         return stringBuilder.toString();,     }, ,     public int getNFib(),     {,         if ( _cswNew == 0 ),             return _fibBase.getNFib();, ,         return _nFibNew;,     }, ,     public int getFcDop(),     {,       return _fieldHandler.getFieldOffset(FIBFieldHandler.DOP);,     }, ,     public void setFcDop(int fcDop),     {,       _fieldHandler.setFieldOffset(FIBFieldHandler.DOP, fcDop);,     }, ,     public int getLcbDop(),     {,       return _fieldHandler.getFieldSize(FIBFieldHandler.DOP);,     }, ,     public void setLcbDop(int lcbDop),     {,       _fieldHandler.setFieldSize(FIBFieldHandler.DOP, lcbDop);,     }, ,     public int getFcStshf(),     {,       return _fieldHandler.getFieldOffset(FIBFieldHandler.STSHF);,     }, ,     public int getLcbStshf(),     {,       return _fieldHandler.getFieldSize(FIBFieldHandler.STSHF);,     }, ,     public void setFcStshf(int fcStshf),     {,       _fieldHandler.setFieldOffset(FIBFieldHandler.STSHF, fcStshf);,     }, ,     public void setLcbStshf(int lcbStshf),     {,       _fieldHandler.setFieldSize(FIBFieldHandler.STSHF, lcbStshf);,     }, ,     public int getFcClx(),     {,       return _fieldHandler.getFieldOffset(FIBFieldHandler.CLX);,     }, ,     public int getLcbClx(),     {,       return _fieldHandler.getFieldSize(FIBFieldHandler.CLX);,     }, ,     public void setFcClx(int fcClx),     {,       _fieldHandler.setFieldOffset(FIBFieldHandler.CLX, fcClx);,     }, ,     public void setLcbClx(int lcbClx),     {,       _fieldHandler.setFieldSize(FIBFieldHandler.CLX, lcbClx);,     }, ,     public int getFcPlcfbteChpx(),     {,       return _fieldHandler.getFieldOffset(FIBFieldHandler.PLCFBTECHPX);,     }, ,     public int getLcbPlcfbteChpx(),     {,       return _fieldHandler.getFieldSize(FIBFieldHandler.PLCFBTECHPX);,     }, ,     public void setFcPlcfbteChpx(int fcPlcfBteChpx),     {,       _fieldHandler.setFieldOffset(FIBFieldHandler.PLCFBTECHPX, fcPlcfBteChpx);,     }, ,     public void setLcbPlcfbteChpx(int lcbPlcfBteChpx),     {,       _fieldHandler.setFieldSize(FIBFieldHandler.PLCFBTECHPX, lcbPlcfBteChpx);,     }, ,     public int getFcPlcfbtePapx(),     {,       return _fieldHandler.getFieldOffset(FIBFieldHandler.PLCFBTEPAPX);,     }, ,     public int getLcbPlcfbtePapx(),     {,       return _fieldHandler.getFieldSize(FIBFieldHandler.PLCFBTEPAPX);,     }, ,     public void setFcPlcfbtePapx(int fcPlcfBtePapx),     {,       _fieldHandler.setFieldOffset(FIBFieldHandler.PLCFBTEPAPX, fcPlcfBtePapx);,     }, ,     public void setLcbPlcfbtePapx(int lcbPlcfBtePapx),     {,       _fieldHandler.setFieldSize(FIBFieldHandler.PLCFBTEPAPX, lcbPlcfBtePapx);,     }, ,     public int getFcPlcfsed(),     {,       return _fieldHandler.getFieldOffset(FIBFieldHandler.PLCFSED);,     }, ,     public int getLcbPlcfsed(),     {,       return _fieldHandler.getFieldSize(FIBFieldHandler.PLCFSED);,     }, ,     public void setFcPlcfsed(int fcPlcfSed),     {,       _fieldHandler.setFieldOffset(FIBFieldHandler.PLCFSED, fcPlcfSed);,     }, ,     public void setLcbPlcfsed(int lcbPlcfSed),     {,       _fieldHandler.setFieldSize(FIBFieldHandler.PLCFSED, lcbPlcfSed);,     }, ,     public int getFcPlcfLst(),     {,       return _fieldHandler.getFieldOffset(FIBFieldHandler.PLCFLST);,     }, ,     public int getLcbPlcfLst(),     {,       return _fieldHandler.getFieldSize(FIBFieldHandler.PLCFLST);,     }, ,     public void setFcPlcfLst(int fcPlcfLst),     {,       _fieldHandler.setFieldOffset(FIBFieldHandler.PLCFLST, fcPlcfLst);,     }, ,     public void setLcbPlcfLst(int lcbPlcfLst),     {,       _fieldHandler.setFieldSize(FIBFieldHandler.PLCFLST, lcbPlcfLst);,     }, ,     public int getFcPlfLfo(),     {,       return _fieldHandler.getFieldOffset(FIBFieldHandler.PLFLFO);,     }, ,     public int getLcbPlfLfo(),     {,       return _fieldHandler.getFieldSize(FIBFieldHandler.PLFLFO);,     }, ,     /**,      * @return Offset in table stream of the STTBF that records bookmark names,      *         in the main document,      */,     public int getFcSttbfbkmk(),     {,         return _fieldHandler.getFieldOffset( FIBFieldHandler.STTBFBKMK );,     }, ,     public void setFcSttbfbkmk( int offset ),     {,         _fieldHandler.setFieldOffset( FIBFieldHandler.STTBFBKMK, offset );,     }, ,     /**,      * @return Count of bytes in Sttbfbkmk,      */,     public int getLcbSttbfbkmk(),     {,         return _fieldHandler.getFieldSize( FIBFieldHandler.STTBFBKMK );,     }, ,     public void setLcbSttbfbkmk( int length ),     {,         _fieldHandler.setFieldSize( FIBFieldHandler.STTBFBKMK, length );,     }, ,     /**,      * @return Offset in table stream of the PLCF that records the beginning CP,      *         offsets of bookmarks in the main document. See BKF structure,      *         definition.,      */,     public int getFcPlcfbkf(),     {,         return _fieldHandler.getFieldOffset( FIBFieldHandler.PLCFBKF );,     }, ,     public void setFcPlcfbkf( int offset ),     {,         _fieldHandler.setFieldOffset( FIBFieldHandler.PLCFBKF, offset );,     }, ,     /**,      * @return Count of bytes in Plcfbkf,      */,     public int getLcbPlcfbkf(),     {,         return _fieldHandler.getFieldSize( FIBFieldHandler.PLCFBKF );,     }, ,     public void setLcbPlcfbkf( int length ),     {,         _fieldHandler.setFieldSize( FIBFieldHandler.PLCFBKF, length );,     }, ,     /**,      * @return Offset in table stream of the PLCF that records the ending CP,      *         offsets of bookmarks recorded in the main document. No structure,      *         is stored in this PLCF.,      */,     public int getFcPlcfbkl(),     {,         return _fieldHandler.getFieldOffset( FIBFieldHandler.PLCFBKL );,     }, ,     public void setFcPlcfbkl( int offset ),     {,         _fieldHandler.setFieldOffset( FIBFieldHandler.PLCFBKL, offset );,     }, ,     /**,      * @return Count of bytes in Plcfbkl,      */,     public int getLcbPlcfbkl(),     {,         return _fieldHandler.getFieldSize( FIBFieldHandler.PLCFBKL );,     }, ,     public void setLcbPlcfbkl( int length ),     {,         _fieldHandler.setFieldSize( FIBFieldHandler.PLCFBKL, length );,     }, ,     public void setFcPlfLfo(int fcPlfLfo),     {,       _fieldHandler.setFieldOffset(FIBFieldHandler.PLFLFO, fcPlfLfo);,     }, ,     public void setLcbPlfLfo(int lcbPlfLfo),     {,       _fieldHandler.setFieldSize(FIBFieldHandler.PLFLFO, lcbPlfLfo);,     }, ,     public int getFcSttbfffn(),     {,       return _fieldHandler.getFieldOffset(FIBFieldHandler.STTBFFFN);,     }, ,     public int getLcbSttbfffn(),     {,       return _fieldHandler.getFieldSize(FIBFieldHandler.STTBFFFN);,     }, ,     public void setFcSttbfffn(int fcSttbFffn),     {,       _fieldHandler.setFieldOffset(FIBFieldHandler.STTBFFFN, fcSttbFffn);,     }, ,     public void setLcbSttbfffn(int lcbSttbFffn),     {,       _fieldHandler.setFieldSize(FIBFieldHandler.STTBFFFN, lcbSttbFffn);,     },     ,     public int getFcSttbfRMark(),     {,       return _fieldHandler.getFieldOffset(FIBFieldHandler.STTBFRMARK);,     }, ,     public int getLcbSttbfRMark(),     {,       return _fieldHandler.getFieldSize(FIBFieldHandler.STTBFRMARK);,     },     ,     public void setFcSttbfRMark(int fcSttbfRMark),     {,       _fieldHandler.setFieldOffset(FIBFieldHandler.STTBFRMARK, fcSttbfRMark);,     }, ,     public void setLcbSttbfRMark(int lcbSttbfRMark),     {,       _fieldHandler.setFieldSize(FIBFieldHandler.STTBFRMARK, lcbSttbfRMark);,     }, ,     /**,      * Return the offset to the PlcfHdd, in the table stream,,      * i.e. fcPlcfHdd,      */,     public int getPlcfHddOffset() {,        return _fieldHandler.getFieldOffset(FIBFieldHandler.PLCFHDD);,     },     /**,      * Return the size of the PlcfHdd, in the table stream,,      * i.e. lcbPlcfHdd,      */,     public int getPlcfHddSize() {,     	return _fieldHandler.getFieldSize(FIBFieldHandler.PLCFHDD);,     },     public void setPlcfHddOffset(int fcPlcfHdd) {,     	_fieldHandler.setFieldOffset(FIBFieldHandler.PLCFHDD, fcPlcfHdd);,     },     public void setPlcfHddSize(int lcbPlcfHdd) {,     	_fieldHandler.setFieldSize(FIBFieldHandler.PLCFHDD, lcbPlcfHdd);,     }, ,     public int getFcSttbSavedBy(),     {,         return _fieldHandler.getFieldOffset(FIBFieldHandler.STTBSAVEDBY);,     }, ,     public int getLcbSttbSavedBy(),     {,         return _fieldHandler.getFieldSize(FIBFieldHandler.STTBSAVEDBY);,     }, ,     public void setFcSttbSavedBy(int fcSttbSavedBy),     {,       _fieldHandler.setFieldOffset(FIBFieldHandler.STTBSAVEDBY, fcSttbSavedBy);,     }, ,     public void setLcbSttbSavedBy(int fcSttbSavedBy),     {,       _fieldHandler.setFieldSize(FIBFieldHandler.STTBSAVEDBY, fcSttbSavedBy);,     }, ,     public int getModifiedLow(),     {,       return _fieldHandler.getFieldOffset(FIBFieldHandler.PLFLFO);,     }, ,     public int getModifiedHigh(),     {,       return _fieldHandler.getFieldSize(FIBFieldHandler.PLFLFO);,     }, ,     public void setModifiedLow(int modifiedLow),     {,       _fieldHandler.setFieldOffset(FIBFieldHandler.PLFLFO, modifiedLow);,     }, ,     public void setModifiedHigh(int modifiedHigh),     {,       _fieldHandler.setFieldSize(FIBFieldHandler.PLFLFO, modifiedHigh);,     },     ,     /**,      * How many bytes of the main stream contain real data.,      */,     public int getCbMac(),     {,         return _fibRgLw.getCbMac();,     }, ,     /**,      * Updates the count of the number of bytes in the,      * main stream which contain real data,      */,     public void setCbMac( int cbMac ),     {,         _fibRgLw.setCbMac( cbMac );,     }, ,     /**,      * @return length of specified subdocument text stream in characters,      */,     public int getSubdocumentTextStreamLength( SubdocumentType type ),     {,         if ( type == null ),             throw new IllegalArgumentException( "argument 'type' is null" );, ,         return _fibRgLw.getSubdocumentTextStreamLength( type );,     }, ,     public void setSubdocumentTextStreamLength( SubdocumentType type, int length ),     {,         if ( type == null ),             throw new IllegalArgumentException( "argument 'type' is null" );,         if ( length < 0 ),             throw new IllegalArgumentException(,                     "Subdocument length can't be less than 0 (passed value is ",                             + length + "). " + "If there is no subdocument ",                             + "length must be set to zero." );, ,         _fibRgLw.setSubdocumentTextStreamLength( type, length );,     }, ,     public void clearOffsetsSizes(),     {,       _fieldHandler.clearFields();,     }, ,     public int getFieldsPlcfOffset( FieldsDocumentPart part ),     {,         return _fieldHandler.getFieldOffset( part.getFibFieldsField() );,     }, ,     public int getFieldsPlcfLength( FieldsDocumentPart part ),     {,         return _fieldHandler.getFieldSize( part.getFibFieldsField() );,     }, ,     public void setFieldsPlcfOffset( FieldsDocumentPart part, int offset ),     {,         _fieldHandler.setFieldOffset( part.getFibFieldsField(), offset );,     }, ,     public void setFieldsPlcfLength( FieldsDocumentPart part, int length ),     {,         _fieldHandler.setFieldSize( part.getFibFieldsField(), length );,     }, ,     @Deprecated,     public int getFcPlcffldAtn(),     {,       return _fieldHandler.getFieldOffset(FIBFieldHandler.PLCFFLDATN);,     }, ,     @Deprecated,     public int getLcbPlcffldAtn(),     {,       return _fieldHandler.getFieldSize(FIBFieldHandler.PLCFFLDATN);,     }, ,     @Deprecated,     public void setFcPlcffldAtn( int offset ),     {,         _fieldHandler.setFieldOffset( FIBFieldHandler.PLCFFLDATN, offset );,     }, ,     @Deprecated,     public void setLcbPlcffldAtn( int size ),     {,         _fieldHandler.setFieldSize( FIBFieldHandler.PLCFFLDATN, size );,     }, ,     @Deprecated,     public int getFcPlcffldEdn(),     {,       return _fieldHandler.getFieldOffset(FIBFieldHandler.PLCFFLDEDN);,     }, ,     @Deprecated,     public int getLcbPlcffldEdn(),     {,       return _fieldHandler.getFieldSize(FIBFieldHandler.PLCFFLDEDN);,     }, ,     @Deprecated,     public void setFcPlcffldEdn( int offset ),     {,         _fieldHandler.setFieldOffset( FIBFieldHandler.PLCFFLDEDN, offset );,     }, ,     @Deprecated,     public void setLcbPlcffldEdn( int size ),     {,         _fieldHandler.setFieldSize( FIBFieldHandler.PLCFFLDEDN, size );,     }, ,     @Deprecated,     public int getFcPlcffldFtn(),     {,       return _fieldHandler.getFieldOffset(FIBFieldHandler.PLCFFLDFTN);,     }, ,     @Deprecated,     public int getLcbPlcffldFtn(),     {,       return _fieldHandler.getFieldSize(FIBFieldHandler.PLCFFLDFTN);,     }, ,     @Deprecated,     public void setFcPlcffldFtn( int offset ),     {,         _fieldHandler.setFieldOffset( FIBFieldHandler.PLCFFLDFTN, offset );,     }, ,     @Deprecated,     public void setLcbPlcffldFtn( int size ),     {,         _fieldHandler.setFieldSize( FIBFieldHandler.PLCFFLDFTN, size );,     }, ,     @Deprecated,     public int getFcPlcffldHdr(),     {,       return _fieldHandler.getFieldOffset(FIBFieldHandler.PLCFFLDHDR);,     }, ,     @Deprecated,     public int getLcbPlcffldHdr(),     {,       return _fieldHandler.getFieldSize(FIBFieldHandler.PLCFFLDHDR);,     }, ,     @Deprecated,     public void setFcPlcffldHdr( int offset ),     {,         _fieldHandler.setFieldOffset( FIBFieldHandler.PLCFFLDHDR, offset );,     }, ,     @Deprecated,     public void setLcbPlcffldHdr( int size ),     {,         _fieldHandler.setFieldSize( FIBFieldHandler.PLCFFLDHDR, size );,     }, ,     @Deprecated,     public int getFcPlcffldHdrtxbx(),     {,       return _fieldHandler.getFieldOffset(FIBFieldHandler.PLCFFLDHDRTXBX);,     }, ,     @Deprecated,     public int getLcbPlcffldHdrtxbx(),     {,       return _fieldHandler.getFieldSize(FIBFieldHandler.PLCFFLDHDRTXBX);,     }, ,     @Deprecated,     public void setFcPlcffldHdrtxbx( int offset ),     {,         _fieldHandler.setFieldOffset( FIBFieldHandler.PLCFFLDHDRTXBX, offset );,     }, ,     @Deprecated,     public void setLcbPlcffldHdrtxbx( int size ),     {,         _fieldHandler.setFieldSize( FIBFieldHandler.PLCFFLDHDRTXBX, size );,     }, ,     @Deprecated,     public int getFcPlcffldMom(),     {,       return _fieldHandler.getFieldOffset(FIBFieldHandler.PLCFFLDMOM);,     }, ,     @Deprecated,     public int getLcbPlcffldMom(),     {,       return _fieldHandler.getFieldSize(FIBFieldHandler.PLCFFLDMOM);,     }, ,     @Deprecated,     public void setFcPlcffldMom( int offset ),     {,         _fieldHandler.setFieldOffset( FIBFieldHandler.PLCFFLDMOM, offset );,     }, ,     @Deprecated,     public void setLcbPlcffldMom( int size ),     {,         _fieldHandler.setFieldSize( FIBFieldHandler.PLCFFLDMOM, size );,     }, ,     @Deprecated,     public int getFcPlcffldTxbx(),     {,       return _fieldHandler.getFieldOffset(FIBFieldHandler.PLCFFLDTXBX);,     }, ,     @Deprecated,     public int getLcbPlcffldTxbx(),     {,       return _fieldHandler.getFieldSize(FIBFieldHandler.PLCFFLDTXBX);,     }, ,     @Deprecated,     public void setFcPlcffldTxbx( int offset ),     {,         _fieldHandler.setFieldOffset( FIBFieldHandler.PLCFFLDTXBX, offset );,     }, ,     @Deprecated,     public void setLcbPlcffldTxbx( int size ),     {,         _fieldHandler.setFieldSize( FIBFieldHandler.PLCFFLDTXBX, size );,     }, , ,     public int getFSPAPlcfOffset( FSPADocumentPart part ),     {,         return _fieldHandler.getFieldOffset( part.getFibFieldsField() );,     }, ,     public int getFSPAPlcfLength( FSPADocumentPart part ),     {,         return _fieldHandler.getFieldSize( part.getFibFieldsField() );,     }, ,     public void setFSPAPlcfOffset( FSPADocumentPart part, int offset ),     {,         _fieldHandler.setFieldOffset( part.getFibFieldsField(), offset );,     }, ,     public void setFSPAPlcfLength( FSPADocumentPart part, int length ),     {,         _fieldHandler.setFieldSize( part.getFibFieldsField(), length );,     }, ,     @Deprecated,     public int getFcPlcspaMom(),     {,         return _fieldHandler.getFieldOffset(FIBFieldHandler.PLCSPAMOM);,     }, ,     @Deprecated,     public int getLcbPlcspaMom(),     {,         return _fieldHandler.getFieldSize(FIBFieldHandler.PLCSPAMOM);,     }, ,     public int getFcDggInfo(),     {,         return _fieldHandler.getFieldOffset(FIBFieldHandler.DGGINFO);,     }, ,     public int getLcbDggInfo(),     {,         return _fieldHandler.getFieldSize(FIBFieldHandler.DGGINFO);,     }, ,     public int getNotesDescriptorsOffset( NoteType noteType ),     {,         return _fieldHandler.getFieldOffset( noteType,                 .getFibDescriptorsFieldIndex() );,     }, ,     public void setNotesDescriptorsOffset( NoteType noteType, int offset ),     {,         _fieldHandler.setFieldOffset( noteType.getFibDescriptorsFieldIndex(),,                 offset );,     }, ,     public int getNotesDescriptorsSize( NoteType noteType ),     {,         return _fieldHandler.getFieldSize( noteType,                 .getFibDescriptorsFieldIndex() );,     }, ,     public void setNotesDescriptorsSize( NoteType noteType, int offset ),     {,         _fieldHandler.setFieldSize( noteType.getFibDescriptorsFieldIndex(),,                 offset );,     }, ,     public int getNotesTextPositionsOffset( NoteType noteType ),     {,         return _fieldHandler.getFieldOffset( noteType,                 .getFibTextPositionsFieldIndex() );,     }, ,     public void setNotesTextPositionsOffset( NoteType noteType, int offset ),     {,         _fieldHandler.setFieldOffset( noteType.getFibTextPositionsFieldIndex(),,                 offset );,     }, ,     public int getNotesTextPositionsSize( NoteType noteType ),     {,         return _fieldHandler.getFieldSize( noteType,                 .getFibTextPositionsFieldIndex() );,     }, ,     public void setNotesTextPositionsSize( NoteType noteType, int offset ),     {,         _fieldHandler.setFieldSize( noteType.getFibTextPositionsFieldIndex(),,                 offset );,     }, ,     public void writeTo( byte[] mainStream, HWPFOutputStream tableStream ),             throws IOException,     {,         _cbRgFcLcb = _fieldHandler.getFieldsCount();, ,         _fibBase.serialize( mainStream, 0 );,         int offset = FibBase.getSize();, ,         LittleEndian.putUShort( mainStream, offset, _csw );,         offset += LittleEndian.SHORT_SIZE;, ,         _fibRgW.serialize( mainStream, offset );,         offset += FibRgW97.getSize();, ,         LittleEndian.putUShort( mainStream, offset, _cslw );,         offset += LittleEndian.SHORT_SIZE;, ,         ( (FibRgLw97) _fibRgLw ).serialize( mainStream, offset );,         offset += FibRgLw97.getSize();, ,         LittleEndian.putUShort( mainStream, offset, _cbRgFcLcb );,         offset += LittleEndian.SHORT_SIZE;, ,         _fieldHandler.writeTo( mainStream, offset, tableStream );,         offset += _cbRgFcLcb * LittleEndian.INT_SIZE * 2;, ,         LittleEndian.putUShort( mainStream, offset, _cswNew );,         offset += LittleEndian.SHORT_SIZE;,         if ( _cswNew != 0 ),         {,             LittleEndian.putUShort( mainStream, offset, _nFibNew );,             offset += LittleEndian.SHORT_SIZE;, ,             System.arraycopy( _fibRgCswNew, 0, mainStream, offset,,                     _fibRgCswNew.length );,             offset += _fibRgCswNew.length;,         },     }, ,     public int getSize(),     {,         return FibBase.getSize() + LittleEndian.SHORT_SIZE + FibRgW97.getSize(),                 + LittleEndian.SHORT_SIZE + FibRgLw97.getSize(),                 + LittleEndian.SHORT_SIZE + _fieldHandler.sizeInBytes();,     }, ,     public FibBase getFibBase(),     {,         return _fibBase;],,
STYLE,REC_CATCH_EXCEPTION,org/apache/poi/hwpf/model/FileInformationBlock.java,toString,324-324,[        catch ( Exception exc )],,
STYLE,RV_RETURN_VALUE_IGNORED_NO_SIDE_EFFECT,org/apache/poi/hwpf/model/FileInformationBlock.java,<init>,137-137,[            LittleEndian.getByteArray( mainDocument, offset, fibRgCswNewLength );],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/poi/hwpf/model/FileInformationBlock.java,assertCbRgFcLcb,152-167,[        switch ( getNFib() ),         {,         case 0x00C1:,             assertCbRgFcLcb( "0x00C1", 0x005D, "0x005D", _cbRgFcLcb );,             break;,         case 0x00D9:,             assertCbRgFcLcb( "0x00D9", 0x006C, "0x006C", _cbRgFcLcb );,             break;,         case 0x0101:,             assertCbRgFcLcb( "0x0101", 0x0088, "0x0088", _cbRgFcLcb );,             break;,         case 0x010C:,             assertCbRgFcLcb( "0x010C", 0x00A4, "0x00A4", _cbRgFcLcb );,             break;,         case 0x0112:,             assertCbRgFcLcb( "0x0112", 0x00B7, "0x00B7", _cbRgFcLcb );],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/poi/hwpf/model/FileInformationBlock.java,assertCswNew,186-201,[        switch ( getNFib() ),         {,         case 0x00C1:,             assertCswNew( "0x00C1", 0x0000, "0x0000", _cswNew );,             break;,         case 0x00D9:,             assertCswNew( "0x00D9", 0x0002, "0x0002", _cswNew );,             break;,         case 0x0101:,             assertCswNew( "0x0101", 0x0002, "0x0002", _cswNew );,             break;,         case 0x010C:,             assertCswNew( "0x010C", 0x0002, "0x0002", _cswNew );,             break;,         case 0x0112:,             assertCswNew( "0x0112", 0x0005, "0x0005", _cswNew );],,
BAD_PRACTICE,BC_EQUALS_METHOD_SHOULD_WORK_FOR_ALL_OBJECTS,org/apache/poi/hwpf/model/FontTable.java,equals,144-144,[    if(((FontTable)o).getStringCount() == _stringCount)],,
BAD_PRACTICE,HE_EQUALS_USE_HASHCODE,org/apache/poi/hwpf/model/FontTable.java,equals,142-162,[  	boolean retVal = true;, ,     if(((FontTable)o).getStringCount() == _stringCount),     {,       if(((FontTable)o).getExtraDataSz() == _extraDataSz),       {,         Ffn[] fontNamesNew = ((FontTable)o).getFontNames();,         for(int i = 0;i<_stringCount; i++),         {,           if(!(_fontNames[i].equals(fontNamesNew[i]))),             retVal = false;,         },       },       else,         retVal = false;,     },     else, 	    retVal = false;, , , 	  return retVal;],,
BAD_PRACTICE,NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT,org/apache/poi/hwpf/model/FontTable.java,equals,142-162,[  	boolean retVal = true;, ,     if(((FontTable)o).getStringCount() == _stringCount),     {,       if(((FontTable)o).getExtraDataSz() == _extraDataSz),       {,         Ffn[] fontNamesNew = ((FontTable)o).getFontNames();,         for(int i = 0;i<_stringCount; i++),         {,           if(!(_fontNames[i].equals(fontNamesNew[i]))),             retVal = false;,         },       },       else,         retVal = false;,     },     else, 	    retVal = false;, , , 	  return retVal;],,
BAD_PRACTICE,NM_CONFUSING,org/apache/poi/hwpf/model/LFOData.java,getCp,57-57,[        return _cp;],,getCP,48-48,[        return 0;],,
BAD_PRACTICE,BC_EQUALS_METHOD_SHOULD_WORK_FOR_ALL_OBJECTS,org/apache/poi/hwpf/model/ListFormatOverrideLevel.java,equals,51-51,[        ListFormatOverrideLevel lfolvl = (ListFormatOverrideLevel) obj;],,
BAD_PRACTICE,BC_EQUALS_METHOD_SHOULD_WORK_FOR_ALL_OBJECTS,org/apache/poi/hwpf/model/ListLevel.java,equals,95-95,[        ListLevel lvl = (ListLevel) obj;],,
BAD_PRACTICE,HE_EQUALS_USE_HASHCODE,org/apache/poi/hwpf/model/ListLevel.java,equals,92-99,[        if ( obj == null ),             return false;, ,         ListLevel lvl = (ListLevel) obj;,         return lvl._lvlf.equals( this._lvlf ),                 && Arrays.equals( lvl._grpprlChpx, _grpprlChpx ),                 && Arrays.equals( lvl._grpprlPapx, _grpprlPapx ),                 && Arrays.equals( lvl._xst, _xst );],,
BAD_PRACTICE,BC_EQUALS_METHOD_SHOULD_WORK_FOR_ALL_OBJECTS,org/apache/poi/hwpf/model/ListTables.java,equals,247-247,[    ListTables tables = (ListTables)obj;],,
BAD_PRACTICE,HE_EQUALS_USE_HASHCODE,org/apache/poi/hwpf/model/ListTables.java,equals,242-275,[    if (obj == null),     {,       return false;,     }, ,     ListTables tables = (ListTables)obj;, ,     if (_listMap.size() == tables._listMap.size()),     {,       Iterator<Integer> it = _listMap.keySet().iterator();,       while (it.hasNext()),       {,         Integer key = it.next();,         ListData lst1 = _listMap.get(key);,         ListData lst2 = tables._listMap.get(key);,         if (!lst1.equals(lst2)),         {,           return false;,         },       },       int size = _overrideList.size();,       if (size == tables._overrideList.size()),       {,         for (int x = 0; x < size; x++),         {,           if (!_overrideList.get(x).equals(tables._overrideList.get(x))),           {,             return false;,           },         },         return true;,       },     },     return false;],,
BAD_PRACTICE,HE_EQUALS_NO_HASHCODE,org/apache/poi/hwpf/model/PAPX.java,equals,160-164,[    if (super.equals(o)),     {,       return _phe.equals(((PAPX)o)._phe);,     },     return false;],,
BAD_PRACTICE,BC_EQUALS_METHOD_SHOULD_WORK_FOR_ALL_OBJECTS,org/apache/poi/hwpf/model/ParagraphHeight.java,equals,79-79,[    ParagraphHeight ph = (ParagraphHeight)o;],,
BAD_PRACTICE,HE_EQUALS_USE_HASHCODE,org/apache/poi/hwpf/model/ParagraphHeight.java,equals,79-81,[    ParagraphHeight ph = (ParagraphHeight)o;, ,     return infoField == ph.infoField && reserved == ph.reserved &&],,
BAD_PRACTICE,NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT,org/apache/poi/hwpf/model/ParagraphHeight.java,equals,79-81,[    ParagraphHeight ph = (ParagraphHeight)o;, ,     return infoField == ph.infoField && reserved == ph.reserved &&],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/poi/hwpf/model/ParagraphHeight.java,,35-35,[    private BitField clMac = BitFieldFactory.getInstance(0xff00);],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/poi/hwpf/model/ParagraphHeight.java,,34-34,[    private BitField fDiffLines = BitFieldFactory.getInstance(0x0004);],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/poi/hwpf/model/ParagraphHeight.java,,32-32,[    private BitField fSpare = BitFieldFactory.getInstance(0x0001);],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/poi/hwpf/model/ParagraphHeight.java,,33-33,[    private BitField fUnk = BitFieldFactory.getInstance(0x0002);],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/poi/hwpf/model/PieceDescriptor.java,,32-32,[   private static BitField fCopied = BitFieldFactory.getInstance(0x04);],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/poi/hwpf/model/PieceDescriptor.java,,30-30,[   private static BitField fNoParaLast = BitFieldFactory.getInstance(0x01);],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/poi/hwpf/model/PieceDescriptor.java,,31-31,[   private static BitField fPaphNil = BitFieldFactory.getInstance(0x02);],,
BAD_PRACTICE,BC_EQUALS_METHOD_SHOULD_WORK_FOR_ALL_OBJECTS,org/apache/poi/hwpf/model/PropertyNode.java,equals,168-168,[      Object testBuf = ((PropertyNode<?>)o)._buf;],,
BAD_PRACTICE,NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT,org/apache/poi/hwpf/model/PropertyNode.java,equals,166-175,[    if (limitsAreEqual(o)),     {,       Object testBuf = ((PropertyNode<?>)o)._buf;,       if (testBuf instanceof byte[] && _buf instanceof byte[]),       {,         return Arrays.equals((byte[])testBuf, (byte[])_buf);,       },       return _buf.equals(testBuf);,     },     return false;],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/poi/hwpf/model/PropertyNode.java,,43-43,[        public static EndComparator instance = new EndComparator();],,
BAD_PRACTICE,SE_COMPARATOR_SHOULD_BE_SERIALIZABLE,org/apache/poi/hwpf/model/PropertyNode.java,,40-49,[    public static final class EndComparator implements,             Comparator<PropertyNode<?>>,     {,         public static EndComparator instance = new EndComparator();, ,         public int compare( PropertyNode<?> o1, PropertyNode<?> o2 ),         {,             int thisVal = o1.getEnd();,             int anotherVal = o2.getEnd();,             return ( thisVal < anotherVal ? -1 : ( thisVal == anotherVal ? 0],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/poi/hwpf/model/PropertyNode.java,,57-57,[        public static StartComparator instance = new StartComparator();],,
BAD_PRACTICE,SE_COMPARATOR_SHOULD_BE_SERIALIZABLE,org/apache/poi/hwpf/model/PropertyNode.java,,54-63,[    public static final class StartComparator implements,             Comparator<PropertyNode<?>>,     {,         public static StartComparator instance = new StartComparator();, ,         public int compare( PropertyNode<?> o1, PropertyNode<?> o2 ),         {,             int thisVal = o1.getStart();,             int anotherVal = o2.getStart();,             return ( thisVal < anotherVal ? -1 : ( thisVal == anotherVal ? 0],,
BAD_PRACTICE,BC_EQUALS_METHOD_SHOULD_WORK_FOR_ALL_OBJECTS,org/apache/poi/hwpf/model/SEPX.java,equals,69-69,[        SEPX sepx = (SEPX) o;],,
BAD_PRACTICE,HE_EQUALS_NO_HASHCODE,org/apache/poi/hwpf/model/SEPX.java,equals,69-74,[        SEPX sepx = (SEPX) o;,         if ( super.equals( o ) ),         {,             return sepx._sed.equals( _sed );,         },         return false;],,
BAD_PRACTICE,BC_EQUALS_METHOD_SHOULD_WORK_FOR_ALL_OBJECTS,org/apache/poi/hwpf/model/SectionDescriptor.java,equals,82-82,[    SectionDescriptor sed = (SectionDescriptor)o;],,
BAD_PRACTICE,HE_EQUALS_USE_HASHCODE,org/apache/poi/hwpf/model/SectionDescriptor.java,equals,82-83,[    SectionDescriptor sed = (SectionDescriptor)o;,     return sed.fn == fn && sed.fnMpr == fnMpr;],,
BAD_PRACTICE,NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT,org/apache/poi/hwpf/model/SectionDescriptor.java,equals,82-83,[    SectionDescriptor sed = (SectionDescriptor)o;,     return sed.fn == fn && sed.fnMpr == fnMpr;],,
STYLE,IM_BAD_CHECK_FOR_ODD,org/apache/poi/hwpf/model/StyleDescription.java,<init>,136-136,[          if(upxSize % 2 == 1)],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/poi/hwpf/model/StyleDescription.java,getCHPX,158-158,[        return null;],,getCHPX,162-162,[        return null;],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/poi/hwpf/model/StyleDescription.java,getPAPX,173-173,[        return null;],,
BAD_PRACTICE,BC_EQUALS_METHOD_SHOULD_WORK_FOR_ALL_OBJECTS,org/apache/poi/hwpf/model/StyleSheet.java,equals,179-179,[    StyleSheet ss = (StyleSheet)o;],,
BAD_PRACTICE,HE_EQUALS_USE_HASHCODE,org/apache/poi/hwpf/model/StyleSheet.java,equals,179-200,[    StyleSheet ss = (StyleSheet)o;, ,     if (ss._stshif.equals( this._stshif ) && ss._cbStshi == _cbStshi),     {,       if (ss._styleDescriptions.length == _styleDescriptions.length),       {,         for (int x = 0; x < _styleDescriptions.length; x++),         {,           // check for null,           if (ss._styleDescriptions[x] != _styleDescriptions[x]),           {,             // check for equality,             if (!ss._styleDescriptions[x].equals(_styleDescriptions[x])),             {,               return false;,             },           },         },         return true;,       },     },     return false;],,
BAD_PRACTICE,NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT,org/apache/poi/hwpf/model/StyleSheet.java,equals,179-200,[    StyleSheet ss = (StyleSheet)o;, ,     if (ss._stshif.equals( this._stshif ) && ss._cbStshi == _cbStshi),     {,       if (ss._styleDescriptions.length == _styleDescriptions.length),       {,         for (int x = 0; x < _styleDescriptions.length; x++),         {,           // check for null,           if (ss._styleDescriptions[x] != _styleDescriptions[x]),           {,             // check for equality,             if (!ss._styleDescriptions[x].equals(_styleDescriptions[x])),             {,               return false;,             },           },         },         return true;,       },     },     return false;],,
MALICIOUS_CODE,MS_MUTABLE_ARRAY,org/apache/poi/hwpf/model/SubdocumentType.java,,49-49,[    public static final SubdocumentType[] ORDERED = new SubdocumentType[] {],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/poi/hwpf/model/TestCHPBinTable.java,,34-37,[  private TextPieceTable fakeTPT = new TextPieceTable() {,       @Override,       public boolean isIndexInTable(int bytePos) {,           return true;],,
PERFORMANCE,DM_NEXTINT_VIA_NEXTDOUBLE,org/apache/poi/hwpf/model/TestPlexOfCps.java,testWriteRead,38-38,[      int span = (int)(110.0f * Math.random());],,
BAD_PRACTICE,BC_EQUALS_METHOD_SHOULD_WORK_FOR_ALL_OBJECTS,org/apache/poi/hwpf/model/TextPiece.java,equals,208-208,[       TextPiece tp = (TextPiece)o;],,
BAD_PRACTICE,HE_EQUALS_NO_HASHCODE,org/apache/poi/hwpf/model/TextPiece.java,equals,206-212,[     if (limitsAreEqual(o)),      {,        TextPiece tp = (TextPiece)o;,        return getStringBuilder().toString().equals(tp.getStringBuilder().toString()) &&,               tp._usesUnicode == _usesUnicode && _pd.equals(tp._pd);,      },      return false;],,
BAD_PRACTICE,NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT,org/apache/poi/hwpf/model/TextPiece.java,equals,206-212,[     if (limitsAreEqual(o)),      {,        TextPiece tp = (TextPiece)o;,        return getStringBuilder().toString().equals(tp.getStringBuilder().toString()) &&,               tp._usesUnicode == _usesUnicode && _pd.equals(tp._pd);,      },      return false;],,
BAD_PRACTICE,BC_EQUALS_METHOD_SHOULD_WORK_FOR_ALL_OBJECTS,org/apache/poi/hwpf/model/TextPieceTable.java,equals,163-163,[        TextPieceTable tpt = (TextPieceTable) o;],,
BAD_PRACTICE,NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT,org/apache/poi/hwpf/model/TextPieceTable.java,equals,163-177,[        TextPieceTable tpt = (TextPieceTable) o;, ,         int size = tpt._textPieces.size();,         if ( size == _textPieces.size() ),         {,             for ( int x = 0; x < size; x++ ),             {,                 if ( !tpt._textPieces.get( x ).equals( _textPieces.get( x ) ) ),                 {,                     return false;,                 },             },             return true;,         },         return false;],,
BAD_PRACTICE,SE_COMPARATOR_SHOULD_BE_SERIALIZABLE,org/apache/poi/hwpf/model/TextPieceTable.java,,498-514,[    private static class FCComparator implements Comparator<TextPiece>,     {,         public int compare( TextPiece textPiece, TextPiece textPiece1 ),         {,             if ( textPiece.getPieceDescriptor().fc > textPiece1,                     .getPieceDescriptor().fc ),             {,                 return 1;,             },             else if ( textPiece.getPieceDescriptor().fc < textPiece1,                     .getPieceDescriptor().fc ),             {,                 return -1;,             },             else,             {,                 return 0;],,
BAD_PRACTICE,BC_EQUALS_METHOD_SHOULD_WORK_FOR_ALL_OBJECTS,org/apache/poi/hwpf/model/UPX.java,equals,45-45,[    UPX upx = (UPX)o;],,
BAD_PRACTICE,HE_EQUALS_USE_HASHCODE,org/apache/poi/hwpf/model/UPX.java,equals,45-46,[    UPX upx = (UPX)o;,     return Arrays.equals(_upx, upx._upx);],,
BAD_PRACTICE,NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT,org/apache/poi/hwpf/model/UPX.java,equals,45-46,[    UPX upx = (UPX)o;,     return Arrays.equals(_upx, upx._upx);],,
MT_CORRECTNESS,IS2_INCONSISTENT_SYNC,org/apache/poi/hwpf/model/io/HWPFOutputStream.java,,37-37,[    return _offset;],,,55-55,[    _offset++;],,,49-49,[    _offset += len;],,,43-43,[    _offset = 0;],,
CORRECTNESS,DMI_INVOKING_TOSTRING_ON_ARRAY,org/apache/poi/hwpf/model/types/CHPAbstractType.java,getXstDispFldRMark,378-378,[        builder.append(" (").append(getXstDispFldRMark()).append(" )\n");],,
CORRECTNESS,DMI_INVOKING_TOSTRING_ON_ARRAY,org/apache/poi/hwpf/model/types/DOPAbstractType.java,getAsumyi,483-483,[        builder.append(" (").append(getAsumyi()).append(" )\n");],,
CORRECTNESS,DMI_INVOKING_TOSTRING_ON_ARRAY,org/apache/poi/hwpf/model/types/DOPAbstractType.java,getDogrid,464-464,[        builder.append(" (").append(getDogrid()).append(" )\n");],,
CORRECTNESS,DMI_INVOKING_TOSTRING_ON_ARRAY,org/apache/poi/hwpf/model/types/DOPAbstractType.java,getDoptypography,462-462,[        builder.append(" (").append(getDoptypography()).append(" )\n");],,
CORRECTNESS,DMI_INVOKING_TOSTRING_ON_ARRAY,org/apache/poi/hwpf/model/types/DOPAbstractType.java,getSpare,496-496,[        builder.append(" (").append(getSpare()).append(" )\n");],,
CORRECTNESS,DMI_INVOKING_TOSTRING_ON_ARRAY,org/apache/poi/hwpf/model/types/LSTFAbstractType.java,getRgistdPara,147-147,[        builder.append(" (").append(getRgistdPara()).append(" )\n");],,
CORRECTNESS,DMI_INVOKING_TOSTRING_ON_ARRAY,org/apache/poi/hwpf/model/types/LVLFAbstractType.java,getRgbxchNums,194-194,[        builder.append(" (").append(getRgbxchNums()).append(" )\n");],,
CORRECTNESS,DMI_INVOKING_TOSTRING_ON_ARRAY,org/apache/poi/hwpf/model/types/PAPAbstractType.java,getAnld,308-308,[        builder.append(" (").append(getAnld()).append(" )\n");],,
CORRECTNESS,DMI_INVOKING_TOSTRING_ON_ARRAY,org/apache/poi/hwpf/model/types/PAPAbstractType.java,getNumrm,324-324,[        builder.append(" (").append(getNumrm()).append(" )\n");],,
CORRECTNESS,DMI_INVOKING_TOSTRING_ON_ARRAY,org/apache/poi/hwpf/model/types/PAPAbstractType.java,getPhe,310-310,[        builder.append(" (").append(getPhe()).append(" )\n");],,
CORRECTNESS,DMI_INVOKING_TOSTRING_ON_ARRAY,org/apache/poi/hwpf/model/types/PAPAbstractType.java,getPtap,326-326,[        builder.append(" (").append(getPtap()).append(" )\n");],,
CORRECTNESS,DMI_INVOKING_TOSTRING_ON_ARRAY,org/apache/poi/hwpf/model/types/PAPAbstractType.java,getRgdxaTab,320-320,[        builder.append(" (").append(getRgdxaTab()).append(" )\n");],,
CORRECTNESS,DMI_INVOKING_TOSTRING_ON_ARRAY,org/apache/poi/hwpf/model/types/PAPAbstractType.java,getRgtbd,322-322,[        builder.append(" (").append(getRgtbd()).append(" )\n");],,
CORRECTNESS,DMI_INVOKING_TOSTRING_ON_ARRAY,org/apache/poi/hwpf/model/types/PICFAbstractType.java,getBrcBottom80,209-209,[        builder.append(" (").append(getBrcBottom80()).append(" )\n");],,
CORRECTNESS,DMI_INVOKING_TOSTRING_ON_ARRAY,org/apache/poi/hwpf/model/types/PICFAbstractType.java,getBrcLeft80,207-207,[        builder.append(" (").append(getBrcLeft80()).append(" )\n");],,
CORRECTNESS,DMI_INVOKING_TOSTRING_ON_ARRAY,org/apache/poi/hwpf/model/types/PICFAbstractType.java,getBrcRight80,211-211,[        builder.append(" (").append(getBrcRight80()).append(" )\n");],,
CORRECTNESS,DMI_INVOKING_TOSTRING_ON_ARRAY,org/apache/poi/hwpf/model/types/PICFAbstractType.java,getBrcTop80,205-205,[        builder.append(" (").append(getBrcTop80()).append(" )\n");],,
CORRECTNESS,DMI_INVOKING_TOSTRING_ON_ARRAY,org/apache/poi/hwpf/model/types/SEPAbstractType.java,getOlstAnm,262-262,[        builder.append(" (").append(getOlstAnm()).append(" )\n");],,
CORRECTNESS,DMI_INVOKING_TOSTRING_ON_ARRAY,org/apache/poi/hwpf/model/types/SEPAbstractType.java,getRgdxaColumn,252-252,[        builder.append(" (").append(getRgdxaColumn()).append(" )\n");],,
CORRECTNESS,DMI_INVOKING_TOSTRING_ON_ARRAY,org/apache/poi/hwpf/model/types/TAPAbstractType.java,getRgdxaCenter,261-261,[        builder.append(" (").append(getRgdxaCenter()).append(" )\n");],,
CORRECTNESS,DMI_INVOKING_TOSTRING_ON_ARRAY,org/apache/poi/hwpf/model/types/TAPAbstractType.java,getRgdxaCenterPrint,263-263,[        builder.append(" (").append(getRgdxaCenterPrint()).append(" )\n");],,
CORRECTNESS,DMI_INVOKING_TOSTRING_ON_ARRAY,org/apache/poi/hwpf/model/types/TAPAbstractType.java,getRgshd,345-345,[        builder.append(" (").append(getRgshd()).append(" )\n");],,
CORRECTNESS,DMI_INVOKING_TOSTRING_ON_ARRAY,org/apache/poi/hwpf/model/types/TAPAbstractType.java,getRgtc,343-343,[        builder.append(" (").append(getRgtc()).append(" )\n");],,
BAD_PRACTICE,BIT_SIGNED_CHECK,org/apache/poi/hwpf/sprm/CharacterSprmUncompressor.java,unCompressCHPOperation,327-327,[        boolean fAdjust = (operand & 0x0100) > 0;],,
STYLE,DB_DUPLICATE_SWITCH_CLAUSES,org/apache/poi/hwpf/sprm/CharacterSprmUncompressor.java,unCompressCHPOperation,300-301,[        newCHP.setFtcAscii ((short) sprm.getOperand());,         break;],,unCompressCHPOperation,477-478,[        newCHP.setFtcAscii ((short) sprm.getOperand());,         break;],,
STYLE,DB_DUPLICATE_SWITCH_CLAUSES,org/apache/poi/hwpf/sprm/CharacterSprmUncompressor.java,unCompressCHPOperation,341-342,[        newCHP.setLidDefault ((short) sprm.getOperand());,         break;],,unCompressCHPOperation,599-600,[        newCHP.setLidDefault ((short) sprm.getOperand());,         break;],,
STYLE,ICAST_QUESTIONABLE_UNSIGNED_RIGHT_SHIFT,org/apache/poi/hwpf/sprm/CharacterSprmUncompressor.java,unCompressCHPOperation,315-315,[        cInc = (byte) (cInc >>> 1);],,
CORRECTNESS,INT_BAD_COMPARISON_WITH_SIGNED_BYTE,org/apache/poi/hwpf/sprm/CharacterSprmUncompressor.java,unCompressCHPOperation,323-323,[        if (hpsPos != 0x80)],,unCompressCHPOperation,328-328,[        if (fAdjust && hpsPos != 128 && hpsPos != 0 && oldCHP.getHpsPos () == 0)],,
STYLE,UCF_USELESS_CONTROL_FLOW,org/apache/poi/hwpf/sprm/ParagraphSprmCompressor.java,compressParagraphProperty,93-93,[            !Arrays.equals(newPAP.getRgtbd(), oldPAP.getRgtbd()))],,
BAD_PRACTICE,BC_EQUALS_METHOD_SHOULD_WORK_FOR_ALL_OBJECTS,org/apache/poi/hwpf/sprm/SprmBuffer.java,equals,155-155,[    SprmBuffer sprmBuf = (SprmBuffer)obj;],,
BAD_PRACTICE,HE_EQUALS_USE_HASHCODE,org/apache/poi/hwpf/sprm/SprmBuffer.java,equals,155-156,[    SprmBuffer sprmBuf = (SprmBuffer)obj;,     return (Arrays.equals(_buf, sprmBuf._buf));],,
BAD_PRACTICE,NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT,org/apache/poi/hwpf/sprm/SprmBuffer.java,equals,155-156,[    SprmBuffer sprmBuf = (SprmBuffer)obj;,     return (Arrays.equals(_buf, sprmBuf._buf));],,
STYLE,DB_DUPLICATE_SWITCH_CLAUSES,org/apache/poi/hwpf/sprm/SprmUtils.java,addSprm,74-76,[        sprm = new byte[4];,         LittleEndian.putShort(sprm, 2, (short)param);,         break;],,addSprm,83-85,[        sprm = new byte[4];,         LittleEndian.putShort(sprm, 2, (short)param);,         break;],,
CORRECTNESS,NP_NULL_PARAM_DEREF,org/apache/poi/hwpf/sprm/SprmUtils.java,addSprm,102-102,[    LittleEndian.putShort(sprm, 0, instruction);],,addSprm,65-65,[    byte[] sprm = null;],,addSprm,66-66,[    switch(type)],,
I18N,DM_CONVERT_CASE,org/apache/poi/hwpf/sprm/TestSprms.java,testInnerTable,65-65,[            char first = paragraph.text().toLowerCase().charAt( 0 );],,
BAD_PRACTICE,BC_EQUALS_METHOD_SHOULD_WORK_FOR_ALL_OBJECTS,org/apache/poi/hwpf/usermodel/BorderCode.java,equals,73-73,[    BorderCode brc = (BorderCode)o;],,
BAD_PRACTICE,HE_EQUALS_USE_HASHCODE,org/apache/poi/hwpf/usermodel/BorderCode.java,equals,73-74,[    BorderCode brc = (BorderCode)o;,     return _info == brc._info && _info2 == brc._info2;],,
BAD_PRACTICE,NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT,org/apache/poi/hwpf/usermodel/BorderCode.java,equals,73-74,[    BorderCode brc = (BorderCode)o;,     return _info == brc._info && _info2 == brc._info2;],,
STYLE,RV_RETURN_VALUE_IGNORED_NO_SIDE_EFFECT,org/apache/poi/hwpf/usermodel/BorderCode.java,setBorderType,128-128,[    _brcType.setValue(_info, borderType);],,
STYLE,RV_RETURN_VALUE_IGNORED_NO_SIDE_EFFECT,org/apache/poi/hwpf/usermodel/BorderCode.java,setColor,156-156,[    _ico.setValue(_info2, color);],,
STYLE,RV_RETURN_VALUE_IGNORED_NO_SIDE_EFFECT,org/apache/poi/hwpf/usermodel/BorderCode.java,setFrame,194-194,[    _fFrame.setValue(_info2, frame ? 1 : 0);],,
STYLE,RV_RETURN_VALUE_IGNORED_NO_SIDE_EFFECT,org/apache/poi/hwpf/usermodel/BorderCode.java,setLineWidth,91-91,[    _dptLineWidth.setValue(_info, lineWidth);],,
STYLE,RV_RETURN_VALUE_IGNORED_NO_SIDE_EFFECT,org/apache/poi/hwpf/usermodel/BorderCode.java,setShadow,183-183,[    _fShadow.setValue(_info2, shadow ? 1 : 0);],,
STYLE,RV_RETURN_VALUE_IGNORED_NO_SIDE_EFFECT,org/apache/poi/hwpf/usermodel/BorderCode.java,setSpace,171-171,[    _dptSpace.setValue(_info2, space);],,
BAD_PRACTICE,NM_CONFUSING,org/apache/poi/hwpf/usermodel/CharacterProperties.java,setDoubleStrikeThrough,232-233,[    super.setFDStrike(dstrike);,   }],,setDoubleStrikethrough,301-306,[    _props.setFDStrike(dstrike);, ,     byte newVal = (byte)(dstrike ? 1 : 0);,     _chpx.updateSprm(SPRM_FDSTRIKE, newVal);, ,   }],,
BAD_PRACTICE,BC_EQUALS_METHOD_SHOULD_WORK_FOR_ALL_OBJECTS,org/apache/poi/hwpf/usermodel/DateAndTime.java,equals,77-77,[    DateAndTime dttm = (DateAndTime)o;],,
BAD_PRACTICE,HE_EQUALS_USE_HASHCODE,org/apache/poi/hwpf/usermodel/DateAndTime.java,equals,77-78,[    DateAndTime dttm = (DateAndTime)o;,     return _info == dttm._info && _info2 == dttm._info2;],,
BAD_PRACTICE,NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT,org/apache/poi/hwpf/usermodel/DateAndTime.java,equals,77-78,[    DateAndTime dttm = (DateAndTime)o;,     return _info == dttm._info && _info2 == dttm._info2;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/poi/hwpf/usermodel/FieldImpl.java,,70-74,[            {,                 @Override,                 public String toString(),                 {,                     return "FieldSubrange1 (" + super.toString() + ")";],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/poi/hwpf/usermodel/FieldImpl.java,,83-87,[        {,             @Override,             public String toString(),             {,                 return "FieldSubrange1 (" + super.toString() + ")";],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/poi/hwpf/usermodel/FieldImpl.java,,214-218,[        {,             @Override,             public String toString(),             {,                 return "FieldSubrange2 (" + super.toString() + ")";],,
BAD_PRACTICE,SE_COMPARATOR_SHOULD_BE_SERIALIZABLE,org/apache/poi/hwpf/usermodel/FieldsImpl.java,,265-272,[    private static final class PlexOfFieldComparator implements,             Comparator<PlexOfField>,     {,         public int compare( PlexOfField o1, PlexOfField o2 ),         {,             int thisVal = o1.getFcStart();,             int anotherVal = o2.getFcStart();,             return thisVal < anotherVal ? -1 : thisVal == anotherVal ? 0 : 1;],,
BAD_PRACTICE,BC_EQUALS_METHOD_SHOULD_WORK_FOR_ALL_OBJECTS,org/apache/poi/hwpf/usermodel/LineSpacingDescriptor.java,equals,76-76,[    LineSpacingDescriptor lspd = (LineSpacingDescriptor)o;],,
BAD_PRACTICE,HE_EQUALS_USE_HASHCODE,org/apache/poi/hwpf/usermodel/LineSpacingDescriptor.java,equals,76-78,[    LineSpacingDescriptor lspd = (LineSpacingDescriptor)o;, ,     return _dyaLine == lspd._dyaLine && _fMultiLinespace == lspd._fMultiLinespace;],,
BAD_PRACTICE,NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT,org/apache/poi/hwpf/usermodel/LineSpacingDescriptor.java,equals,76-78,[    LineSpacingDescriptor lspd = (LineSpacingDescriptor)o;, ,     return _dyaLine == lspd._dyaLine && _fMultiLinespace == lspd._fMultiLinespace;],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/poi/hwpf/usermodel/OfficeDrawingsImpl.java,getBitmapRecord,58-58,[        if ( bContainers == null || bContainers.size() != 1 )],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/poi/hwpf/usermodel/OfficeDrawingsImpl.java,getPictureData,179-179,[                    return null;],,getPictureData,184-184,[                    return null;],,getPictureData,189-189,[                    return null;],,getPictureData,194-194,[                    return null;],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/poi/hwpf/usermodel/Picture.java,,44-44,[    public static final byte[] COMPRESSED1 = { (byte) 0xFE, 0x78, (byte) 0xDA };],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/poi/hwpf/usermodel/Picture.java,,46-46,[    public static final byte[] COMPRESSED2 = { (byte) 0xFE, 0x78, (byte) 0x9C };],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/poi/hwpf/usermodel/Picture.java,,53-53,[    public static final byte[] IHDR = new byte[] { 'I', 'H', 'D', 'R' };],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/poi/hwpf/usermodel/Picture.java,,59-59,[    public static final byte[] PNG = new byte[] { (byte) 0x89, 0x50, 0x4E,],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/poi/hwpf/usermodel/Picture.java,,42-42,[    public static final byte[] BMP = new byte[] { 'B', 'M' };],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/poi/hwpf/usermodel/Picture.java,,49-49,[    public static final byte[] EMF = { 0x01, 0x00, 0x00, 0x00 };],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/poi/hwpf/usermodel/Picture.java,,52-52,[    public static final byte[] GIF = new byte[] { 'G', 'I', 'F' };],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/poi/hwpf/usermodel/Picture.java,,55-55,[    public static final byte[] JPG = new byte[] { (byte) 0xFF, (byte) 0xD8 };],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/poi/hwpf/usermodel/Picture.java,,62-62,[    public static final byte[] TIFF = new byte[] { 0x49, 0x49, 0x2A, 0x00 };],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/poi/hwpf/usermodel/Picture.java,,65-65,[    public static final byte[] TIFF1 = new byte[] { 0x4D, 0x4D, 0x00, 0x2A };],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/poi/hwpf/usermodel/Picture.java,,67-67,[    public static final byte[] WMF1 = { (byte) 0xD7, (byte) 0xCD, (byte) 0xC6,],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/poi/hwpf/usermodel/Picture.java,,71-71,[    public static final byte[] WMF2 = { 0x01, 0x00, 0x09, 0x00, 0x00, 0x03 }; // Windows],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/poi/hwpf/usermodel/Picture.java,<init>,135-135,[        if ( _picfAndOfficeArtData != null && _picfAndOfficeArtData.getBlipRecords() != null) {],,
BAD_PRACTICE,HE_EQUALS_USE_HASHCODE,org/apache/poi/hwpf/usermodel/SectionProperties.java,equals,51-73,[        Field[] fields = SectionProperties.class.getSuperclass(),                 .getDeclaredFields();,         AccessibleObject.setAccessible( fields, true );,         try,         {,             for ( int x = 0; x < fields.length; x++ ),             {,                 Object obj1 = fields[x].get( this );,                 Object obj2 = fields[x].get( obj );,                 if ( obj1 == null && obj2 == null ),                 {,                     continue;,                 },                 if ( !obj1.equals( obj2 ) ),                 {,                     return false;,                 },             },             return true;,         },         catch ( Exception e ),         {,             return false;],,
CORRECTNESS,NP_NULL_ON_SOME_PATH,org/apache/poi/hwpf/usermodel/SectionProperties.java,equals,64-64,[                if ( !obj1.equals( obj2 ) )],,equals,60-60,[                if ( obj1 == null && obj2 == null )],,
STYLE,REC_CATCH_EXCEPTION,org/apache/poi/hwpf/usermodel/SectionProperties.java,equals,71-71,[        catch ( Exception e )],,
CORRECTNESS,NP_ALWAYS_NULL,org/apache/poi/hwpf/usermodel/TestBorderCode.java,findParagraph,110-110,[        throw null;],,
STYLE,RV_RETURN_VALUE_IGNORED_NO_SIDE_EFFECT,org/apache/poi/hwpf/usermodel/TestBug50075.java,test,38-38,[    level.getNumberText();],,
BAD_PRACTICE,DE_MIGHT_IGNORE,org/apache/poi/hwpf/usermodel/TestBugs.java,test50955,550-550,[        catch ( Exception e )],,
I18N,DM_CONVERT_CASE,org/apache/poi/openxml4j/opc/ContentTypes.java,getContentTypeFromFileExtension,113-113,[				.toLowerCase();],,
CORRECTNESS,GC_UNRELATED_TYPES,org/apache/poi/openxml4j/opc/OPCPackage.java,removeMarshaller,1282-1282,[		partMarshallers.remove(contentType);],,
CORRECTNESS,GC_UNRELATED_TYPES,org/apache/poi/openxml4j/opc/OPCPackage.java,removeUnmarshaller,1292-1292,[		partUnmarshallers.remove(contentType);],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/poi/openxml4j/opc/OPCPackage.java,save,1342-1342,[			fos = new FileOutputStream(targetFile);],,save,1345-1345,[		}],,save,1346-1346,[		this.save(fos);],,
CORRECTNESS,RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE,org/apache/poi/openxml4j/opc/PackagePart.java,getOutputStream,525-525,[			part._relationships = this._relationships;],,getOutputStream,526-526,[			if (part == null) {],,
I18N,DM_CONVERT_CASE,org/apache/poi/openxml4j/opc/PackagePartName.java,compareTo,441-441,[		return this.partNameURI.toASCIIString().toLowerCase().compareTo(],,compareTo,442-442,[				otherPartName.partNameURI.toASCIIString().toLowerCase());],,
I18N,DM_CONVERT_CASE,org/apache/poi/openxml4j/opc/PackagePartName.java,equals,481-481,[		return this.partNameURI.toASCIIString().toLowerCase().equals(],,equals,483-483,[						.toLowerCase());],,
I18N,DM_CONVERT_CASE,org/apache/poi/openxml4j/opc/PackagePartName.java,hashCode,488-488,[		return this.partNameURI.toASCIIString().toLowerCase().hashCode();],,
BAD_PRACTICE,NM_CONFUSING,org/apache/poi/openxml4j/opc/PackageRelationship.java,getId,156-156,[		return id;],,
I18N,DM_CONVERT_CASE,org/apache/poi/openxml4j/opc/PackageRelationshipCollection.java,parseRelationshipsPart,341-341,[					targetMode = targetModeAttr.getValue().toLowerCase()],,
STYLE,REC_CATCH_EXCEPTION,org/apache/poi/openxml4j/opc/PackageRelationshipCollection.java,parseRelationshipsPart,363-363,[		} catch (Exception e) {],,
PERFORMANCE,WMI_WRONG_MAP_ITERATOR,org/apache/poi/openxml4j/opc/TestFileHelper.java,testGetDirectory,45-45,[			File f1 = new File(expectedValue.get(filename));],,
PERFORMANCE,WMI_WRONG_MAP_ITERATOR,org/apache/poi/openxml4j/opc/TestListParts.java,testListParts,101-101,[			assertEquals(expectedValues.get(partName), values.get(partName));],,
I18N,DM_DEFAULT_ENCODING,org/apache/poi/openxml4j/opc/TestPackage.java,testCreatePackageWithCoreDocument,162-162,[        coreOut.write("<dummy-xml />".getBytes());],,testCreatePackageWithCoreDocument,172-172,[        coreOut.write("<dummy-xml2 />".getBytes());],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/poi/openxml4j/opc/TestPackage.java,testCreatePackageWithCoreDocument,191-191,[            FileOutputStream fout = new FileOutputStream(tmp);],,testCreatePackageWithCoreDocument,192-192,[        fout.write(baos.toByteArray());],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/poi/openxml4j/opc/TestPackage.java,testSaveToOutputStream,303-303,[		FileOutputStream fout = new FileOutputStream(targetFile);],,testSaveToOutputStream,304-304,[		p.save(fout);],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/poi/openxml4j/opc/TestPackage.java,testCreateGetsContentTypes,75-75,[		if(targetFile.exists()) targetFile.delete();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/poi/openxml4j/opc/TestPackage.java,testCreatePackageAddPart,109-109,[        if(targetFile.exists()) targetFile.delete();],,
PERFORMANCE,WMI_WRONG_MAP_ITERATOR,org/apache/poi/openxml4j/opc/TestPackage.java,testDeletePart,404-404,[			assertEquals(expectedValues.get(partName), values.get(partName));],,
PERFORMANCE,WMI_WRONG_MAP_ITERATOR,org/apache/poi/openxml4j/opc/TestPackage.java,testDeletePartRecursive,442-442,[			assertEquals(expectedValues.get(partName), values.get(partName));],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/poi/openxml4j/opc/TestPackageCoreProperties.java,testSetProperties,99-99,[		outputFile.delete();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/poi/openxml4j/opc/TestPackageThumbnail.java,testSetProperties,55-55,[		outputFile.delete();],,
STYLE,REC_CATCH_EXCEPTION,org/apache/poi/openxml4j/opc/ZipPackage.java,saveImpl,448-448,[		} catch (Exception e) {],,
I18N,DM_DEFAULT_ENCODING,org/apache/poi/openxml4j/opc/internal/ContentType.java,<init>,140-140,[			contentTypeASCII = new String(contentType.getBytes(), "US-ASCII");],,
I18N,DM_CONVERT_CASE,org/apache/poi/openxml4j/opc/internal/ContentTypeManager.java,addContentType,152-152,[		String extension = partName.getExtension().toLowerCase();],,
I18N,DM_CONVERT_CASE,org/apache/poi/openxml4j/opc/internal/ContentTypeManager.java,addDefaultContentType,187-187,[		defaultContentType.put(extension.toLowerCase(), contentType);],,
I18N,DM_CONVERT_CASE,org/apache/poi/openxml4j/opc/internal/ContentTypeManager.java,getContentType,330-330,[		String extension = partName.getExtension().toLowerCase();],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/poi/openxml4j/opc/internal/MemoryPackagePart.java,,107-107,[		length = 0;],,
CORRECTNESS,RV_EXCEPTION_NOT_THROWN,org/apache/poi/openxml4j/opc/internal/PackagePropertiesPart.java,setCreatedProperty,392-392,[					+ e.getLocalizedMessage());],,
CORRECTNESS,RV_EXCEPTION_NOT_THROWN,org/apache/poi/openxml4j/opc/internal/PackagePropertiesPart.java,setLastPrintedProperty,470-470,[					+ e.getLocalizedMessage());],,
CORRECTNESS,RV_EXCEPTION_NOT_THROWN,org/apache/poi/openxml4j/opc/internal/PackagePropertiesPart.java,setModifiedProperty,494-494,[					+ e.getLocalizedMessage());],,
BAD_PRACTICE,OS_OPEN_STREAM,org/apache/poi/openxml4j/opc/internal/ZipContentTypeManager.java,saveImpl,65-65,[			zos = new ZipOutputStream(out);],,
CORRECTNESS,NP_NULL_PARAM_DEREF_NONVIRTUAL,org/apache/poi/openxml4j/opc/internal/signature/DigitalCertificatePart.java,<init>,38-38,[		super(null, null, new ContentType(""));],,
CORRECTNESS,NP_NULL_PARAM_DEREF_NONVIRTUAL,org/apache/poi/openxml4j/opc/signature/PackageDigitalSignature.java,<init>,32-32,[		super(null, null, new ContentType(""));],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_NEEDS_THIS,org/apache/poi/openxml4j/util/ZipInputStreamZipEntrySource.java,,82-94,[	private class EntryEnumerator implements Enumeration<ZipEntry> {, 		private Iterator<? extends ZipEntry> iterator;, 		, 		private EntryEnumerator() {, 			iterator = zipEntries.iterator();, 		}, 		, 		public boolean hasMoreElements() {, 			return iterator.hasNext();, 		}, , 		public ZipEntry nextElement() {, 			return iterator.next();],,
MALICIOUS_CODE,MS_MUTABLE_ARRAY,org/apache/poi/poifs/common/POIFSConstants.java,,62-62,[    public static final byte[] OOXML_FILE_HEADER = ],,
BAD_PRACTICE,SR_NOT_CHECKED,org/apache/poi/poifs/crypt/AgileDecryptor.java,nextChunk,190-190,[                _stream.skip((index - _lastIndex) << 12);],,
I18N,DM_DEFAULT_ENCODING,org/apache/poi/poifs/crypt/EncryptionHeader.java,<init>,88-88,[            is = new ByteArrayInputStream(descriptor.getBytes());],,<init>,141-141,[        keySalt = Base64.decodeBase64(salt.getBytes());],,
STYLE,REC_CATCH_EXCEPTION,org/apache/poi/poifs/crypt/EncryptionHeader.java,<init>,92-92,[        } catch (Exception e) {],,
BAD_PRACTICE,RR_NOT_CHECKED,org/apache/poi/poifs/crypt/EncryptionInfo.java,<init>,54-54,[            dis.read(xmlDescriptor);],,
I18N,DM_DEFAULT_ENCODING,org/apache/poi/poifs/crypt/EncryptionVerifier.java,<init>,49-49,[            is = new ByteArrayInputStream(descriptor.getBytes());],,<init>,70-70,[                                       .getNodeValue().getBytes());],,<init>,72-72,[                                   .getNodeValue().getBytes());],,<init>,76-76,[                                           .getNodeValue().getBytes());],,<init>,85-85,[                                           .getNodeValue().getBytes());],,
STYLE,REC_CATCH_EXCEPTION,org/apache/poi/poifs/crypt/EncryptionVerifier.java,<init>,62-62,[        } catch (Exception e) {],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/poi/poifs/crypt/EncryptionVerifier.java,,113-113,[        verifierHashSize = Integer.parseInt(keyData.getNamedItem("hashSize")],,
BAD_PRACTICE,OS_OPEN_STREAM,org/apache/poi/poifs/crypt/TestDecryptor.java,zipOk,70-70,[        ZipInputStream zin = new ZipInputStream(d.getDataStream(fs));],,
BAD_PRACTICE,SR_NOT_CHECKED,org/apache/poi/poifs/crypt/TestDecryptor.java,zipOk,79-79,[                zin.skip(zin.available());],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/poi/poifs/dev/POIFSDump.java,dump,61-61,[                FileOutputStream out = new FileOutputStream(new File(parent, node.getName().trim()));],,dump,62-62,[                out.write(bytes);],,
BAD_PRACTICE,RR_NOT_CHECKED,org/apache/poi/poifs/dev/POIFSDump.java,dump,58-58,[                is.read(bytes);],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/poi/poifs/dev/POIFSDump.java,dump,67-67,[                file.mkdir();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/poi/poifs/dev/POIFSDump.java,main,44-44,[            file.mkdir();],,
MALICIOUS_CODE,DP_DO_INSIDE_DO_PRIVILEGED,org/apache/poi/poifs/dev/POIFSHeaderDumper.java,displayBATReader,131-131,[      entriesF.setAccessible(true);],,
MALICIOUS_CODE,DP_DO_INSIDE_DO_PRIVILEGED,org/apache/poi/poifs/dev/POIFSHeaderDumper.java,displayRawBlocksSummary,114-114,[      gbm.setAccessible(true);],,
CORRECTNESS,INT_BAD_COMPARISON_WITH_NONNEGATIVE_VALUE,org/apache/poi/poifs/dev/POIFSViewer.java,main,45-45,[        if (args.length < 0)],,
BAD_PRACTICE,RR_NOT_CHECKED,org/apache/poi/poifs/eventfilesystem/POIFSReader.java,processPOIFSReaderEvent,314-314,[                istream.read(data);],,
CORRECTNESS,ICAST_INT_CAST_TO_DOUBLE_PASSED_TO_CEIL,org/apache/poi/poifs/filesystem/BlockStore.java,<init>,83-83,[          int numBlocks = (int)Math.ceil( rawSize / getBlockStoreBlockSize() );],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_NEEDS_THIS,org/apache/poi/poifs/filesystem/BlockStore.java,,82-102,[       protected ChainLoopDetector(long rawSize) {,           int numBlocks = (int)Math.ceil( rawSize / getBlockStoreBlockSize() );,           used_blocks = new boolean[numBlocks];,        },        protected void claim(int offset) {,           if(offset >= used_blocks.length) {,              // They're writing, and have had new blocks requested,              //  for the write to proceed. That means they're into,              //  blocks we've allocated for them, so are safe,              return;,           },           ,           // Claiming an existing block, ensure there's no loop,           if(used_blocks[offset]) {,              throw new IllegalStateException(,                    "Potential loop detected - Block " + offset + ,                    " was already claimed but was just requested again",              );,           },           used_blocks[offset] = true;,        }],,
I18N,DM_DEFAULT_ENCODING,org/apache/poi/poifs/filesystem/NPOIFSDocument.java,getViewableArray,154-154,[            result = output.toString();],,
BAD_PRACTICE,RR_NOT_CHECKED,org/apache/poi/poifs/filesystem/Ole10Native.java,createFromEmbeddedOleObject,87-87,[     directory.createDocumentInputStream(nativeEntry).read(data);],,
STYLE,DLS_DEAD_LOCAL_STORE_OF_NULL,org/apache/poi/poifs/filesystem/POIFSDocument.java,read,262-262,[					currentBlock = null;],,
I18N,DM_DEFAULT_ENCODING,org/apache/poi/poifs/filesystem/POIFSDocument.java,getViewableArray,362-362,[				result = output.toString();],,
BAD_PRACTICE,DM_EXIT,org/apache/poi/poifs/filesystem/ReaderWriter.java,processPOIFSReaderEvent,145-145,[                        System.exit(1);],,
BAD_PRACTICE,DM_EXIT,org/apache/poi/poifs/filesystem/ReaderWriter.java,processPOIFSWriterEvent,182-182,[            System.exit(1);],,
BAD_PRACTICE,RR_NOT_CHECKED,org/apache/poi/poifs/filesystem/ReaderWriter.java,processPOIFSReaderEvent,116-116,[            istream.read(data);],,
BAD_PRACTICE,OS_OPEN_STREAM,org/apache/poi/poifs/filesystem/TestDocumentInputStream.java,testConstructor,98-98,[        DocumentInputStream ostream = new DocumentInputStream(_workbook_o);],,testConstructor,99-99,[        DocumentInputStream nstream = new NDocumentInputStream(_workbook_n);],,
BAD_PRACTICE,RR_NOT_CHECKED,org/apache/poi/poifs/filesystem/TestDocumentInputStream.java,testBufferRead,327-327,[             stream.read(null);],,
BAD_PRACTICE,RR_NOT_CHECKED,org/apache/poi/poifs/filesystem/TestDocumentInputStream.java,testComplexBufferRead,388-388,[             stream.read(null, 0, 1);],,testComplexBufferRead,396-396,[             stream.read(new byte[ 5 ], -4, 0);],,testComplexBufferRead,402-402,[             stream.read(new byte[ 5 ], 0, -4);],,testComplexBufferRead,408-408,[             stream.read(new byte[ 5 ], 0, 6);],,testComplexBufferRead,466-466,[             stream.read(buffer, 0, 1);],,
BAD_PRACTICE,RR_NOT_CHECKED,org/apache/poi/poifs/filesystem/TestDocumentInputStream.java,testMarkFunctions,147-147,[           stream.read(buffer);],,testMarkFunctions,231-231,[           stream.read(buffer);],,
BAD_PRACTICE,RR_NOT_CHECKED,org/apache/poi/poifs/filesystem/TestDocumentInputStream.java,testBufferRead,320-376,[       DocumentInputStream[] streams = new DocumentInputStream[] {,              new DocumentInputStream(_workbook_o),,              new NDocumentInputStream(_workbook_n),        };,        for(DocumentInputStream stream : streams) {,           // Need to give a byte array to read,           try {,              stream.read(null);,              fail("Should have caught NullPointerException");,           } catch (NullPointerException ignored) {,              // as expected,           }, ,           // test reading zero length buffer,           assertEquals(0, stream.read(new byte[ 0 ]));,           assertEquals(_workbook_size, stream.available());,           byte[] buffer = new byte[ _buffer_size ];,           int    offset = 0;, ,           while (stream.available() >= buffer.length),           {,              assertEquals(_buffer_size, stream.read(buffer));,              for (int j = 0; j < buffer.length; j++),              {,                 assertEquals("in main loop, byte " + offset,,                       _workbook_data[ offset ], buffer[ j ]);,                 offset++;,              },              assertEquals("offset " + offset, _workbook_size - offset,,                    stream.available());,           },           assertEquals(_workbook_size % _buffer_size, stream.available());,           Arrays.fill(buffer, ( byte ) 0);,           int count = stream.read(buffer);, ,           assertEquals(_workbook_size % _buffer_size, count);,           for (int j = 0; j < count; j++),           {,              assertEquals("past main loop, byte " + offset,,                    _workbook_data[ offset ], buffer[ j ]);,              offset++;,           },           assertEquals(_workbook_size, offset);,           for (int j = count; j < buffer.length; j++),           {,              assertEquals("checking remainder, byte " + j, 0, buffer[ j ]);,           },           assertEquals(-1, stream.read(buffer));,           stream.close();,           try {,              stream.read(buffer);,              fail("Should have caught IOException");,           } catch (IOException ignored) {,              // as expected,           },        },     }],,read,114-114,[		return read(b, 0, b.length);],,
BAD_PRACTICE,RR_NOT_CHECKED,org/apache/poi/poifs/filesystem/TestDocumentInputStream.java,testMarkFunctions,138-278,[        byte[] buffer = new byte[ _workbook_size / 5 ];,         byte[] small_buffer = new byte[212];,        ,         DocumentInputStream[] streams = new DocumentInputStream[] {,               new DocumentInputStream(_workbook_o),,               new NDocumentInputStream(_workbook_n),         };,         for(DocumentInputStream stream : streams) {,            // Read a fifth of it, and check all's correct,            stream.read(buffer);,            for (int j = 0; j < buffer.length; j++) {,               assertEquals(,                     "checking byte " + j, ,                     _workbook_data[ j ], buffer[ j ],               );,            },            assertEquals(_workbook_size - buffer.length, stream.available());,            ,            // Reset, and check the available goes back to being the,            //  whole of the stream,            stream.reset();,            assertEquals(_workbook_size, stream.available());,            ,            ,            // Read part of a block,            stream.read(small_buffer);,            for (int j = 0; j < small_buffer.length; j++) {,               assertEquals(,                     "checking byte " + j, ,                     _workbook_data[ j ], small_buffer[ j ],               );,            },            assertEquals(_workbook_size - small_buffer.length, stream.available());,            stream.mark(0);,            ,            // Read the next part,            stream.read(small_buffer);,            for (int j = 0; j < small_buffer.length; j++) {,               assertEquals(,                     "checking byte " + j, ,                     _workbook_data[ j+small_buffer.length ], small_buffer[ j ],               );,            },            assertEquals(_workbook_size - 2*small_buffer.length, stream.available());,            ,            // Reset, check it goes back to where it was,            stream.reset();,            assertEquals(_workbook_size - small_buffer.length, stream.available());,            ,            // Read ,            stream.read(small_buffer);,            for (int j = 0; j < small_buffer.length; j++) {,               assertEquals(,                     "checking byte " + j, ,                     _workbook_data[ j+small_buffer.length ], small_buffer[ j ],               );,            },            assertEquals(_workbook_size - 2*small_buffer.length, stream.available());,            ,            ,            // Now read at various points,            Arrays.fill(small_buffer, ( byte ) 0);,            stream.read(small_buffer, 6, 8);,            stream.read(small_buffer, 100, 10);,            stream.read(small_buffer, 150, 12);,            int pos = small_buffer.length * 2;,            for (int j = 0; j < small_buffer.length; j++) {,               byte exp = 0;,               if(j>= 6 && j<6+8) {,                  exp = _workbook_data[pos];,                  pos++;,               },               if(j>= 100 && j<100+10) {,                  exp = _workbook_data[pos];,                  pos++;,               },               if(j>= 150 && j<150+12) {,                  exp = _workbook_data[pos];,                  pos++;,               },               ,               assertEquals("checking byte " + j, exp, small_buffer[j]);,            },         },            ,         // Now repeat it with spanning multiple blocks,         streams = new DocumentInputStream[] {,               new DocumentInputStream(_workbook_o),,               new NDocumentInputStream(_workbook_n),         };,         for(DocumentInputStream stream : streams) {,            // Read several blocks work,            buffer = new byte[ _workbook_size / 5 ];,            stream.read(buffer);,            for (int j = 0; j < buffer.length; j++) {,               assertEquals(,                     "checking byte " + j, ,                     _workbook_data[ j ], buffer[ j ],               );,            },            assertEquals(_workbook_size - buffer.length, stream.available());,            ,            // Read all of it again, check it began at the start again,            stream.reset();,            assertEquals(_workbook_size, stream.available());,            ,            stream.read(buffer);,            for (int j = 0; j < buffer.length; j++) {,               assertEquals(,                     "checking byte " + j, ,                     _workbook_data[ j ], buffer[ j ],               );,            },            ,            // Mark our position, and read another whole buffer,            stream.mark(12);,            stream.read(buffer);,            assertEquals(_workbook_size - (2 * buffer.length),,                  stream.available());,            for (int j = buffer.length; j < (2 * buffer.length); j++),            {,               assertEquals("checking byte " + j, _workbook_data[ j ],,                     buffer[ j - buffer.length ]);,            },            ,            // Reset, should go back to only one buffer full read,            stream.reset();,            assertEquals(_workbook_size - buffer.length, stream.available());,            ,            // Read the buffer again,            stream.read(buffer);,            assertEquals(_workbook_size - (2 * buffer.length),,                  stream.available());,            for (int j = buffer.length; j < (2 * buffer.length); j++),            {,               assertEquals("checking byte " + j, _workbook_data[ j ],,                     buffer[ j - buffer.length ]);,            },            assertTrue(stream.markSupported());,         },     }],,read,114-114,[		return read(b, 0, b.length);],,
BAD_PRACTICE,RR_NOT_CHECKED,org/apache/poi/poifs/filesystem/TestDocumentInputStream.java,testMarkFunctions,200-200,[           stream.read(small_buffer, 6, 8);],,testMarkFunctions,201-201,[           stream.read(small_buffer, 100, 10);],,testMarkFunctions,202-202,[           stream.read(small_buffer, 150, 12);],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/poi/poifs/filesystem/TestEmptyDocument.java,,51-54,[		dir.createDocument("Foo", 0, new POIFSWriterListener() {, 			public void processPOIFSWriterEvent(POIFSWriterEvent event) {, 				_logger.log(POILogger.WARN, "written");, 			}],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/poi/poifs/filesystem/TestEmptyDocument.java,,76-83,[		dir.createDocument("Bar", 1, new POIFSWriterListener() {, 			public void processPOIFSWriterEvent(POIFSWriterEvent event) {, 				try {, 					event.getStream().write(0);, 				} catch (IOException exception) {, 					throw new RuntimeException("exception on write: " + exception);, 				}, 			}],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/poi/poifs/filesystem/TestEmptyDocument.java,,85-87,[		dir.createDocument("Foo", 0, new POIFSWriterListener() {, 			public void processPOIFSWriterEvent(POIFSWriterEvent event) {, 			}],,
BAD_PRACTICE,OS_OPEN_STREAM,org/apache/poi/poifs/filesystem/TestNPOIFSFileSystem.java,testGetDocumentEntry,535-535,[         NDocumentInputStream inp = new NDocumentInputStream(doc);],,
STYLE,RV_RETURN_VALUE_IGNORED_NO_SIDE_EFFECT,org/apache/poi/poifs/filesystem/TestNPOIFSFileSystem.java,testPropertiesAndFatOnRead,70-70,[         fs.getBATBlockAndIndex(0);],,testPropertiesAndFatOnRead,71-71,[         fs.getBATBlockAndIndex(1);],,testPropertiesAndFatOnRead,73-73,[            fs.getBATBlockAndIndex(140);],,testPropertiesAndFatOnRead,134-134,[         fs.getBATBlockAndIndex(0);],,testPropertiesAndFatOnRead,135-135,[         fs.getBATBlockAndIndex(1);],,testPropertiesAndFatOnRead,137-137,[            fs.getBATBlockAndIndex(1040);],,
STYLE,RV_RETURN_VALUE_IGNORED_NO_SIDE_EFFECT,org/apache/poi/poifs/filesystem/TestNPOIFSFileSystem.java,testPropertiesAndFatOnRead,114-114,[         ministore.getBATBlockAndIndex(0);],,testPropertiesAndFatOnRead,115-115,[         ministore.getBATBlockAndIndex(128);],,testPropertiesAndFatOnRead,117-117,[            ministore.getBATBlockAndIndex(256);],,testPropertiesAndFatOnRead,179-179,[         ministore.getBATBlockAndIndex(0);],,testPropertiesAndFatOnRead,180-180,[         ministore.getBATBlockAndIndex(128);],,testPropertiesAndFatOnRead,181-181,[         ministore.getBATBlockAndIndex(1023);],,testPropertiesAndFatOnRead,183-183,[            ministore.getBATBlockAndIndex(1024);],,
BAD_PRACTICE,OS_OPEN_STREAM,org/apache/poi/poifs/filesystem/TestPOIFSFileSystem.java,checkAllDirectoryContents,285-285,[	         DocumentInputStream dis = new DocumentInputStream(doc);],,
BAD_PRACTICE,RR_NOT_CHECKED,org/apache/poi/poifs/filesystem/TestPOIFSFileSystem.java,checkAllDirectoryContents,288-288,[            dis.read(data);],,
I18N,DM_CONVERT_CASE,org/apache/poi/poifs/poibrowser/Codec.java,hexDecode,184-184,[        s.toUpperCase().getChars(0, length, c, 0);],,
I18N,DM_DEFAULT_ENCODING,org/apache/poi/poifs/poibrowser/Codec.java,hexEncode,53-53,[        return hexEncode(s.getBytes());],,
I18N,DM_DEFAULT_ENCODING,org/apache/poi/poifs/poibrowser/Codec.java,main,221-221,[        final BufferedReader in =],,
I18N,DM_DEFAULT_ENCODING,org/apache/poi/poifs/poibrowser/Codec.java,main,235-235,[                System.out.println(new String(hexDecode(bytes)));],,
I18N,DM_DEFAULT_ENCODING,org/apache/poi/poifs/poibrowser/Codec.java,main,233-233,[                System.out.println(hexEncode(s.getBytes()));],,
CORRECTNESS,ICAST_BAD_SHIFT_AMOUNT,org/apache/poi/poifs/poibrowser/Codec.java,hexEncode,143-143,[        sb.append(hexEncode((int) (l & 0xFFFFFFFF00000000L) >> 32));],,
STYLE,IM_BAD_CHECK_FOR_ODD,org/apache/poi/poifs/poibrowser/Codec.java,hexDecode,179-179,[        if (length % 2 == 1)],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/poi/poifs/poibrowser/Codec.java,,40-40,[    protected static final byte hexval[] =],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/poi/poifs/poibrowser/ExtendableTreeCellRenderer.java,,54-66,[            {,                 public Component getTreeCellRendererComponent,                     (JTree tree, Object value, boolean selected,,                      boolean expanded, boolean leaf, int row, boolean hasFocus),                 {,                     final String s = value.toString();,                     final JLabel l = new JLabel(s + "  ");,                     if (selected),                     {,                         Util.invert(l);,                         l.setOpaque(true);,                     },                     return l;],,
BAD_PRACTICE,DM_EXIT,org/apache/poi/poifs/poibrowser/POIBrowser.java,run,115-115,[            System.exit(0);],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/poi/poifs/poibrowser/POIBrowser.java,,69-73,[            {,                 public void windowClosing(WindowEvent e),                 {,                         System.exit(0);,                 }],,
BAD_PRACTICE,HE_EQUALS_USE_HASHCODE,org/apache/poi/poifs/property/DirectoryProperty.java,equals,129-129,[            return this == o;],,
BAD_PRACTICE,SE_COMPARATOR_SHOULD_BE_SERIALIZABLE,org/apache/poi/poifs/property/DirectoryProperty.java,,118-184,[    public static class PropertyComparator implements Comparator<Property> {, ,         /**,          * Object equality, implemented as object identity,          *,          * @param o Object we're being compared to,          *,          * @return true if identical, else false,          */,         public boolean equals(Object o),         {,             return this == o;,         }, ,         /**,          * compare method. Assumes both parameters are non-null,          * instances of Property. One property is less than another if,          * its name is shorter than the other property's name. If the,          * names are the same length, the property whose name comes,          * before the other property's name, alphabetically, is less,          * than the other property.,          *,          * @param o1 first object to compare, better be a Property,          * @param o2 second object to compare, better be a Property,          *,          * @return negative value if o1 <  o2,,          *         zero           if o1 == o2,,          *         positive value if o1 >  o2.,          */,         public int compare(Property o1, Property o2),         {,             String VBA_PROJECT = "_VBA_PROJECT";,             String name1  = o1.getName();,             String name2  = o2.getName();,             int  result = name1.length() - name2.length();, ,             if (result == 0),             {,               // _VBA_PROJECT, it seems, will always come last,               if (name1.compareTo(VBA_PROJECT) == 0),                 result = 1;,               else if (name2.compareTo(VBA_PROJECT) == 0),                 result = -1;,               else,               {,                 if (name1.startsWith("__") && name2.startsWith("__")),                 {,                   // Betweeen __SRP_0 and __SRP_1 just sort as normal,                   result = name1.compareToIgnoreCase(name2);,                 },                 else if (name1.startsWith("__")),                 {,                   // If only name1 is __XXX then this will be placed after name2,                   result = 1;,                 },                 else if (name2.startsWith("__")),                 {,                   // If only name2 is __XXX then this will be placed after name1,                   result = -1;,                 },                 else,                   // result = name1.compareTo(name2);,                   // The default case is to sort names ignoring case,                   result = name1.compareToIgnoreCase(name2);,               },             },             return result;],,
CORRECTNESS,ICAST_INT_CAST_TO_DOUBLE_PASSED_TO_CEIL,org/apache/poi/poifs/property/NPropertyTable.java,countBlocks,109-109,[       return (int)Math.ceil(size / _bigBigBlockSize.getBigBlockSize());],,
I18N,DM_DEFAULT_ENCODING,org/apache/poi/poifs/property/TestDirectoryProperty.java,createBasicDirectoryProperty,178-178,[        byte[] name_bytes = name.getBytes();],,
I18N,DM_DEFAULT_ENCODING,org/apache/poi/poifs/property/TestDocumentProperty.java,verifyProperty,140-140,[        byte[] name_bytes = name.getBytes();],,
I18N,DM_DEFAULT_ENCODING,org/apache/poi/poifs/property/TestRootProperty.java,createBasicRootProperty,70-70,[		byte[] name_bytes = name.getBytes();],,
STYLE,ICAST_IDIV_CAST_TO_DOUBLE,org/apache/poi/poifs/storage/BATBlock.java,getBATBlockAndIndex,271-271,[       int whichBAT = (int)Math.floor(offset / bigBlockSize.getBATEntriesPerBlock());],,
STYLE,ICAST_IDIV_CAST_TO_DOUBLE,org/apache/poi/poifs/storage/BATBlock.java,getSBATBlockAndIndex,286-286,[       int whichSBAT = (int)Math.floor(offset / bigBlockSize.getBATEntriesPerBlock());],,
CORRECTNESS,BIT_AND,org/apache/poi/poifs/storage/HeaderBlock.java,<init>,133-133,[			if ((signature & 0xFF8FFFFFFFFFFFFFL) == 0x0010000200040009L) {],,
I18N,DM_CONVERT_CASE,org/apache/poi/ss/examples/AddDimensionedImage.java,addImageToSheet,358-358,[        String sURL = imageFile.toString().toLowerCase();],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/poi/ss/examples/AddDimensionedImage.java,,816-871,[        public int fromIndex = 0;,         public int toIndex = 0;,         public int inset = 0;, ,         /**,          * Create a new instance of the ClientAnchorDetail class using the,          * following parameters.,          *,          * @param fromIndex A primitive int that contains one of the,          *                  co-ordinates (row or column index) for the top left,          *                  hand corner of the image.,          * @param toIndex A primitive int that contains one of the,          *                co-ordinates (row or column index) for the bottom,          *                right hand corner of the image.,          * @param inset A primitive int that contains a value which indicates,          *              how far the image should be inset from the top or the,          *              left hand edge of a cell.,          */,         public ClientAnchorDetail(int fromIndex, int toIndex, int inset) {,             this.fromIndex = fromIndex;,             this.toIndex = toIndex;,             this.inset = inset;,         }, ,         /**,          * Get one of the number of the column or row that contains the cell,          * whose top left hand corner will be aligned with the top left hand,          * corner of the image.,          *,          * @return The value - row or column index - for one of the co-ordinates,          *         of the top left hand corner of the image.,          */,         public int getFromIndex() {,             return(this.fromIndex);,         }, ,         /**,          * Get one of the number of the column or row that contains the cell,          * whose top left hand corner will be aligned with the bottom righ hand,          * corner of the image.,          *,          * @return The value - row or column index - for one of the co-ordinates,          *         of the bottom right hand corner of the image.,          */,         public int getToIndex() {,             return(this.toIndex);,         }, ,         /**,          * Get the image's offset from the edge of a cell.,          *,          * @return How far either the right hand or bottom edge of the image is,          *         inset from the left hand or top edge of a cell.,          */,         public int getInset() {,             return(this.inset);],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/poi/ss/examples/AddDimensionedImage.java,,909-909,[        public static final int[] UNIT_OFFSET_MAP = new int[]],,
MT_CORRECTNESS,STCAL_INVOKE_ON_STATIC_DATE_FORMAT_INSTANCE,org/apache/poi/ss/examples/BusinessPlan.java,main,116-116,[        calendar.setTime(fmt.parse("9-Jul"));],,main,165-165,[                        calendar.setTime(fmt.parse(data[i][j]));],,
STYLE,DB_DUPLICATE_SWITCH_CLAUSES,org/apache/poi/ss/examples/SSPerformanceTest.java,main,76-77,[                        cell.setCellValue(value++);,                         break;],,main,110-110,[                        cell.setCellValue(value++);],,
BAD_PRACTICE,DM_EXIT,org/apache/poi/ss/examples/SSPerformanceTest.java,usage,171-171,[        System.exit(1);],,
I18N,DM_DEFAULT_ENCODING,org/apache/poi/ss/examples/ToCSV.java,saveCSVFile,461-461,[            fw = new FileWriter(file);],,
STYLE,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,org/apache/poi/ss/examples/ToCSV.java,convertExcelToCSV,346-346,[        for(File excelFile : filesList) {],,convertExcelToCSV,326-326,[            filesList = source.listFiles(new ExcelFilenameFilter());],,
STYLE,REC_CATCH_EXCEPTION,org/apache/poi/ss/examples/ToCSV.java,main,721-721,[        catch(Exception ex) {],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/poi/ss/examples/ToCSV.java,,734-758,[    class ExcelFilenameFilter implements FilenameFilter {, ,         /**,          * Determine those files that will be returned by a call to the,          * listFiles() method. In this case, the name of the file must end with,          * either of the following two extension; '.xls' or '.xlsx'. For the,          * future, it is very possible to parameterise this and allow the,          * containing class to pass, for example, an array of Strings to this,          * class on instantiation. Each element in that array could encapsulate,          * a valid file extension - '.xls', '.xlsx', '.xlt', '.xlst', etc. These,          * could then be used to control which files were returned by the call,          * to the listFiles() method.,          *,          * @param file An instance of the File class that encapsulates a handle,          *             referring to the folder/directory that contains the file.,          * @param name An instance of the String class that encapsulates the,          *             name of the file.,          * @return A boolean value that indicates whether the file should be,          *         included in the array retirned by the call to the listFiles(),          *         method. In this case true will be returned if the name of the,          *         file ends with either '.xls' or '.xlsx' and false will be,          *         returned in all other instances.,          */,         public boolean accept(File file, String name) {,             return(name.endsWith(".xls") || name.endsWith(".xlsx"));],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/poi/ss/examples/formula/TestExcelAntUserDefinedFunction.java,testSetClassName,33-33,[		fixture.setClassName( className ) ;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/poi/ss/examples/formula/TestExcelAntUserDefinedFunction.java,testSetFunction,43-43,[		fixture.setFunctionAlias( functionAlias ) ;],,
I18N,DM_DEFAULT_ENCODING,org/apache/poi/ss/examples/html/ToHtml.java,main,171-171,[        ToHtml toHtml = create(args[0], new PrintWriter(new FileWriter(args[1])));],,
I18N,DM_DEFAULT_ENCODING,org/apache/poi/ss/examples/html/ToHtml.java,printStyles,232-232,[                    getClass().getResourceAsStream("excelStyle.css")));],,
BAD_PRACTICE,UI_INHERITANCE_UNSAFE_GETRESOURCE,org/apache/poi/ss/examples/html/ToHtml.java,printStyles,232-232,[                    getClass().getResourceAsStream("excelStyle.css")));],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/poi/ss/examples/html/XSSFHtmlHelper.java,,39-39,[        this.wb = wb;],,
I18N,DM_DEFAULT_ENCODING,org/apache/poi/ss/excelant/BuildFileTest.java,executeTarget,322-322,[            PrintStream out = new PrintStream(new AntOutputStream(outBuffer));],,executeTarget,325-325,[            PrintStream err = new PrintStream(new AntOutputStream(errBuffer));],,
BAD_PRACTICE,UI_INHERITANCE_UNSAFE_GETRESOURCE,org/apache/poi/ss/excelant/BuildFileTest.java,getResource,475-475,[        URL url = getClass().getResource(resource);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/poi/ss/excelant/BuildFileTest.java,getFullLog,229-229,[        return fullLogBuffer.toString();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/poi/ss/excelant/BuildFileTest.java,getLog,196-196,[        return logBuffer.toString();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/poi/ss/excelant/ExcelAntEvaluateCell.java,execute,126-126,[		result = wbUtil.evaluateCell(cell, expectedValue, precisionToUse ) ;],,
STYLE,REC_CATCH_EXCEPTION,org/apache/poi/ss/excelant/ExcelAntHandlerTask.java,execute,71-71,[        } catch( Exception e ) {],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/poi/ss/excelant/ExcelAntHandlerTask.java,execute,68-68,[                iHandler.setWorkbook( wbUtil.getWorkbook() ) ;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/poi/ss/excelant/ExcelAntSetDoubleCell.java,execute,56-56,[		wbUtil.setDoubleValue(cellStr, cellValue ) ;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/poi/ss/excelant/ExcelAntSetFormulaCell.java,execute,48-48,[		wbUtil.setFormulaValue( cellStr, cellValue ) ;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/poi/ss/excelant/ExcelAntSetStringCell.java,execute,58-58,[		wbUtil.setStringValue(cellStr, stringValue ) ;],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/poi/ss/excelant/ExcelAntTask.java,loadWorkbook,104-104,[		if( targetWorkbook == null ) {],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/poi/ss/excelant/ExcelAntTest.java,,61-61,[		setters = new LinkedList<ExcelAntSet>() ;],,
PERFORMANCE,SS_SHOULD_BE_STATIC,org/apache/poi/ss/excelant/TestExcelAntSet.java,,31-31,[	private final String mortgageCalculatorFileName =],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/poi/ss/excelant/TestExcelAntSet.java,testSetWorkbookUtil,62-62,[		fixture.setWorkbookUtil( util ) ;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/poi/ss/excelant/TestExcelAntSet.java,testSetter,48-48,[		fixture.setCell( cell ) ;],,
PERFORMANCE,SS_SHOULD_BE_STATIC,org/apache/poi/ss/excelant/TestExcelAntSetDoubleCell.java,,28-28,[	private final String mortgageCalculatorFileName =],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/poi/ss/excelant/TestExcelAntSetDoubleCell.java,testSetDouble,50-50,[		fixture.setCell( cellId ) ;],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/poi/ss/excelant/TestExcelAntSetDoubleCell.java,testSetDouble,60-60,[		double setValue = util.getCellAsDouble( cellId ) ;],,
PERFORMANCE,WMI_WRONG_MAP_ITERATOR,org/apache/poi/ss/excelant/util/ExcelAntWorkbookUtil.java,getFunctions,141-141,[            FreeRefFunction function = xlsMacroList.get(name);],,
BAD_PRACTICE,ISC_INSTANTIATE_STATIC_CLASS,org/apache/poi/ss/excelant/util/ExcelAntWorkbookUtilFactory.java,getInstance,51-51,[            factory = new ExcelAntWorkbookUtilFactory() ;],,
MT_CORRECTNESS,LI_LAZY_INIT_STATIC,org/apache/poi/ss/excelant/util/ExcelAntWorkbookUtilFactory.java,getInstance,50-51,[        if( factory == null ) {,             factory = new ExcelAntWorkbookUtilFactory() ;],,
CORRECTNESS,NP_NULL_ON_SOME_PATH,org/apache/poi/ss/excelant/util/ExcelAntWorkbookUtilFactory.java,getInstance,58-58,[            workbookUtilMap.put( fileName, wbu ) ;],,getInstance,53-53,[        if( workbookUtilMap != null && ],,
STYLE,ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD,org/apache/poi/ss/excelant/util/ExcelAntWorkbookUtilFactory.java,<init>,38-38,[        workbookUtilMap = new HashMap<String, ExcelAntWorkbookUtil>() ; ],,
PERFORMANCE,SS_SHOULD_BE_STATIC,org/apache/poi/ss/excelant/util/TestExcelAntWorkbookUtil.java,,30-30,[	private final String mortgageCalculatorFileName =],,
PERFORMANCE,SS_SHOULD_BE_STATIC,org/apache/poi/ss/excelant/util/TestExcelAntWorkbookUtilFactory.java,,31-31,[	private final String mortgageCalculatorWorkbookFile = ],,
I18N,DM_CONVERT_CASE,org/apache/poi/ss/format/CellDateFormatter.java,handlePart,72-72,[                return part.toLowerCase();],,handlePart,79-79,[                return part.toLowerCase();],,handlePart,85-85,[                    return part.toLowerCase();],,handlePart,87-87,[                    return part.toLowerCase().replace('d', 'E');],,handlePart,95-95,[                    return part.toLowerCase();],,handlePart,97-97,[                    return part.toUpperCase();],,handlePart,104-104,[                return part.toLowerCase();],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/poi/ss/format/CellElapsedFormatter.java,<init>,143-143,[            if (spec.type != topmost.type) {],,
I18N,DM_CONVERT_CASE,org/apache/poi/ss/format/CellElapsedFormatter.java,handlePart,88-88,[                part = part.toLowerCase();],,handlePart,97-97,[                part = part.toLowerCase();],,
I18N,DM_CONVERT_CASE,org/apache/poi/ss/format/CellFormatPart.java,<clinit>,62-62,[            if (name.equals(name.toUpperCase())) {],,
STYLE,RV_CHECK_FOR_POSITIVE_INDEXOF,org/apache/poi/ss/format/CellFormatPart.java,<clinit>,68-68,[                if (name.indexOf("_PERCENT") > 0)],,
CORRECTNESS,IJU_NO_TESTS,org/apache/poi/ss/format/CellFormatTestBase.java,,63-311,[    private static final POILogger logger = POILogFactory.getLogger(CellFormatTestBase.class);, ,     private final ITestDataProvider _testDataProvider;, ,     protected Workbook workbook;, ,     private String testFile;,     private Map<String, String> testFlags;,     private boolean tryAllColors;,     private JLabel label;, ,     private static final String[] COLOR_NAMES =,             {"Black", "Red", "Green", "Blue", "Yellow", "Cyan", "Magenta",,                     "White"};,     private static final Color[] COLORS =,             {BLACK, RED, GREEN, BLUE, YELLOW, CYAN, MAGENTA, WHITE};, ,     public static final Color TEST_COLOR = ORANGE.darker();, ,     protected CellFormatTestBase(ITestDataProvider testDataProvider) {,         _testDataProvider = testDataProvider;,     }, ,     abstract static class CellValue {,         abstract Object getValue(Cell cell);, ,         @SuppressWarnings({"UnusedDeclaration"}),         Color getColor(Cell cell) {,             return TEST_COLOR;,         }, ,         void equivalent(String expected, String actual, CellFormatPart format) {,             assertEquals("format \"" + format + "\"", '"' + expected + '"',,                     '"' + actual + '"');,         },     }, ,     protected void runFormatTests(String workbookName, CellValue valueGetter),             throws IOException {, ,         openWorkbook(workbookName);, ,         readFlags(workbook);, ,         Set<String> runCategories = new TreeSet<String>(,                 String.CASE_INSENSITIVE_ORDER);,         String runCategoryList = flagString("Categories", "");,         if (runCategoryList != null) {,             runCategories.addAll(Arrays.asList(runCategoryList.split(,                     "\\s*,\\s*")));,             runCategories.remove(""); // this can be found and means nothing,         }, ,         Sheet sheet = workbook.getSheet("Tests");,         int end = sheet.getLastRowNum();,         // Skip the header row, therefore "+ 1",         for (int r = sheet.getFirstRowNum() + 1; r <= end; r++) {,             Row row = sheet.getRow(r);,             if (row == null),                 continue;,             int cellnum = 0;,             String expectedText = row.getCell(cellnum).getStringCellValue();,             String format = row.getCell(1).getStringCellValue();,             String testCategoryList = row.getCell(3).getStringCellValue();,             boolean byCategory = runByCategory(runCategories, testCategoryList);,             if ((expectedText.length() > 0 || format.length() > 0) && byCategory) {,                 Cell cell = row.getCell(2);,                 tryFormat(r, expectedText, format, valueGetter, cell);,             },         },     }, ,     /**,      * Open a given workbook.,      *,      * @param workbookName The workbook name.  This is presumed to live in the,      *                     "spreadsheets" directory under the directory named in,      *                     the Java property "POI.testdata.path".,      *,      * @throws IOException,      */,     protected void openWorkbook(String workbookName),             throws IOException {,         workbook = _testDataProvider.openSampleWorkbook(workbookName);,         workbook.setMissingCellPolicy(Row.CREATE_NULL_AS_BLANK);,         testFile = workbookName;,     }, ,     /**,      * Read the flags from the workbook.  Flags are on the sheet named "Flags",,      * and consist of names in column A and values in column B.  These are put,      * into a map that can be queried later.,      *,      * @param wb The workbook to look in.,      */,     private void readFlags(Workbook wb) {,         Sheet flagSheet = wb.getSheet("Flags");,         testFlags = new TreeMap<String, String>(String.CASE_INSENSITIVE_ORDER);,         if (flagSheet != null) {,             int end = flagSheet.getLastRowNum();,             // Skip the header row, therefore "+ 1",             for (int r = flagSheet.getFirstRowNum() + 1; r <= end; r++) {,                 Row row = flagSheet.getRow(r);,                 if (row == null),                     continue;,                 String flagName = row.getCell(0).getStringCellValue();,                 String flagValue = row.getCell(1).getStringCellValue();,                 if (flagName.length() > 0) {,                     testFlags.put(flagName, flagValue);,                 },             },         }, ,         tryAllColors = flagBoolean("AllColors", true);,     }, ,     /**,      * Returns <tt>true</tt> if any of the categories for this run are contained,      * in the test's listed categories.,      *,      * @param categories     The categories of tests to be run.  If this is,      *                       empty, then all tests will be run.,      * @param testCategories The categories that this test is in.  This is a,      *                       comma-separated list.  If <em>any</em> tests in,      *                       this list are in <tt>categories</tt>, the test will,      *                       be run.,      *,      * @return <tt>true</tt> if the test should be run.,      */,     private boolean runByCategory(Set<String> categories,,             String testCategories) {, ,         if (categories.isEmpty()),             return true;,         // If there are specified categories, find out if this has one of them,         for (String category : testCategories.split("\\s*,\\s*")) {,             if (categories.contains(category)) {,                 return true;,             },         },         return false;,     }, ,     private void tryFormat(int row, String expectedText, String desc,,             CellValue getter, Cell cell) {, ,         Object value = getter.getValue(cell);,         Color testColor = getter.getColor(cell);,         if (testColor == null),             testColor = TEST_COLOR;, ,         if (label == null),             label = new JLabel();,         label.setForeground(testColor);,         label.setText("xyzzy");, ,         logger.log(POILogger.INFO, String.format("Row %d: \"%s\" -> \"%s\": expected \"%s\"", row + 1,,                 String.valueOf(value), desc, expectedText));,         String actualText = tryColor(desc, null, getter, value, expectedText,,                 testColor);,         logger.log(POILogger.INFO, String.format(", actual \"%s\")%n", actualText));, ,         if (tryAllColors && testColor != TEST_COLOR) {,             for (int i = 0; i < COLOR_NAMES.length; i++) {,                 String cname = COLOR_NAMES[i];,                 tryColor(desc, cname, getter, value, expectedText, COLORS[i]);,             },         },     }, ,     private String tryColor(String desc, String cname, CellValue getter,,             Object value, String expectedText, Color expectedColor) {, ,         if (cname != null),             desc = "[" + cname + "]" + desc;,         Color origColor = label.getForeground();,         CellFormatPart format = new CellFormatPart(desc);,         if (!format.apply(label, value).applies) {,             // If this doesn't apply, no color change is expected,             expectedColor = origColor;,         }, ,         String actualText = label.getText();,         Color actualColor = label.getForeground();,         getter.equivalent(expectedText, actualText, format);,         assertEquals(cname == null ? "no color" : "color " + cname,,                 expectedColor, actualColor);,         return actualText;,     }, ,     /**,      * Returns the value for the given flag.  The flag has the value of,      * <tt>true</tt> if the text value is <tt>"true"</tt>, <tt>"yes"</tt>, or,      * <tt>"on"</tt> (ignoring case).,      *,      * @param flagName The name of the flag to fetch.,      * @param expected The value for the flag that is expected when the tests,      *                 are run for a full test.  If the current value is not the,      *                 expected one, you will get a warning in the test output.,      *                 This is so that you do not accidentally leave a flag set,      *                 to a value that prevents running some tests, thereby,      *                 letting you accidentally release code that is not fully,      *                 tested.,      *,      * @return The value for the flag.,      */,     protected boolean flagBoolean(String flagName, boolean expected) {,         String value = testFlags.get(flagName);,         boolean isSet;,         if (value == null),             isSet = false;,         else {,             isSet = value.equalsIgnoreCase("true") || value.equalsIgnoreCase(,                     "yes") || value.equalsIgnoreCase("on");,         },         warnIfUnexpected(flagName, expected, isSet);,         return isSet;,     }, ,     /**,      * Returns the value for the given flag.,      *,      * @param flagName The name of the flag to fetch.,      * @param expected The value for the flag that is expected when the tests,      *                 are run for a full test.  If the current value is not the,      *                 expected one, you will get a warning in the test output.,      *                 This is so that you do not accidentally leave a flag set,      *                 to a value that prevents running some tests, thereby,      *                 letting you accidentally release code that is not fully,      *                 tested.,      *,      * @return The value for the flag.,      */,     protected String flagString(String flagName, String expected) {,         String value = testFlags.get(flagName);,         if (value == null),             value = "";,         warnIfUnexpected(flagName, expected, value);,         return value;,     }, ,     private void warnIfUnexpected(String flagName, Object expected,,             Object actual) {,         if (!actual.equals(expected)) {,             System.err.println(,                     "WARNING: " + testFile + ": " + "Flag " + flagName +,                             " = \"" + actual + "\" [not \"" + expected + "\"]");,         },     }],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/poi/ss/format/CellFormatTestBase.java,flagString,110-110,[        if (runCategoryList != null) {],,
STYLE,FE_FLOATING_POINT_EQUALITY,org/apache/poi/ss/format/CellGeneralFormatter.java,formatValue,52-52,[            else if ((long) val != val)],,
BAD_PRACTICE,ES_COMPARING_STRINGS_WITH_EQ,org/apache/poi/ss/format/CellNumberFormatter.java,formatValue,648-648,[                        if (nextChange.toAdd == "")],,
STYLE,SF_SWITCH_FALLTHROUGH,org/apache/poi/ss/format/CellNumberFormatter.java,formatValue,619-622,[                    posTweak = 1;,                     //noinspection fallthrough,                 case StringMod.BEFORE:,                     output.insert(modPos + posTweak, nextChange.toAdd);],,
CORRECTNESS,UR_UNINIT_READ,org/apache/poi/ss/format/CellNumberFormatter.java,<init>,255-255,[        if ((decimalPoint != null || exponent != null) && slash != null) {],,
CORRECTNESS,UR_UNINIT_READ,org/apache/poi/ss/format/CellNumberFormatter.java,<init>,255-255,[        if ((decimalPoint != null || exponent != null) && slash != null) {],,
CORRECTNESS,UR_UNINIT_READ,org/apache/poi/ss/format/CellNumberFormatter.java,<init>,255-255,[        if ((decimalPoint != null || exponent != null) && slash != null) {],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/poi/ss/format/CellTextFormatter.java,,40-47,[                new PartHandler() {,                     public String handlePart(Matcher m, String part,,                             CellFormatType type, StringBuffer desc) {,                         if (part.equals("@")) {,                             numPlaces[0]++;,                             return "\u0000";,                         },                         return null;],,
STYLE,FE_FLOATING_POINT_EQUALITY,org/apache/poi/ss/formula/CellCacheEntry.java,areValuesEqual,70-70,[			return ((NumberEval)a).getNumberValue() == ((NumberEval)b).getNumberValue();],,
STYLE,FE_FLOATING_POINT_EQUALITY,org/apache/poi/ss/formula/EvaluationCache.java,areValuesEqual,164-164,[			return ((NumberEval)a).getNumberValue() == ((NumberEval)b).getNumberValue();],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/poi/ss/formula/Formula.java,getTokens,154-154,[			return null;],,
I18N,DM_CONVERT_CASE,org/apache/poi/ss/formula/FormulaParser.java,getFunction,951-951,[		FunctionMetadata fm = FunctionMetadataRegistry.getFunctionByName(name.toUpperCase());],,
I18N,DM_CONVERT_CASE,org/apache/poi/ss/formula/FormulaParser.java,isValidCellReference,883-883,[			boolean isFunc = FunctionMetadataRegistry.getFunctionByName(str.toUpperCase()) != null;],,
I18N,DM_CONVERT_CASE,org/apache/poi/ss/formula/FormulaParser.java,parseErrorLiteral,1293-1293,[		String part1 = parseUnquotedIdentifier().toUpperCase();],,
PERFORMANCE,DM_FP_NUMBER_CTOR,org/apache/poi/ss/formula/FormulaParser.java,convertArrayNumber,1252-1252,[		return new Double(value);],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/poi/ss/formula/FormulaParser.java,Arguments,1029-1061,[		List<ParseNode> temp = new ArrayList<ParseNode>(2);, 		SkipWhite();, 		if(look == ')') {, 			return ParseNode.EMPTY_ARRAY;, 		}, , 		boolean missedPrevArg = true;, 		int numArgs = 0;, 		while (true) {, 			SkipWhite();, 			if (isArgumentDelimiter(look)) {, 				if (missedPrevArg) {, 					temp.add(new ParseNode(MissingArgPtg.instance));, 					numArgs++;, 				}, 				if (look == ')') {, 					break;, 				}, 				Match(',');, 				missedPrevArg = true;, 				continue;, 			}, 			temp.add(comparisonExpression());, 			numArgs++;, 			missedPrevArg = false;, 			SkipWhite();, 			if (!isArgumentDelimiter(look)) {, 				throw expected("',' or ')'");, 			}, 		}, 		ParseNode[] result = new ParseNode[temp.size()];, 		temp.toArray(result);, 		return result;],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/poi/ss/formula/FormulaParser.java,GetChar,183-195,[		if (_pointer > _formulaLength) {, 			throw new RuntimeException("too far");, 		}, 		if (_pointer < _formulaLength) {, 			look=_formulaString.charAt(_pointer);, 		} else {, 			// Just return if so and reset 'look' to something to keep, 			// SkipWhitespace from spinning, 			look = (char)0;, 		}, 		_pointer++;, 		//System.out.println("Got char: "+ look);, 	}],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/poi/ss/formula/FormulaParser.java,GetNum,258-264,[		StringBuffer value = new StringBuffer();, , 		while (IsDigit(this.look)){, 			value.append(this.look);, 			GetChar();, 		}, 		return value.length() == 0 ? null : value.toString();],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/poi/ss/formula/FormulaParser.java,IsAlpha,224-224,[		return Character.isLetter(c) || c == '$' || c=='_';],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/poi/ss/formula/FormulaParser.java,IsDigit,229-229,[		return Character.isDigit(c);],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/poi/ss/formula/FormulaParser.java,IsWhite,234-234,[		return  c ==' ' || c== TAB || c == CR || c == LF;],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/poi/ss/formula/FormulaParser.java,Match,250-254,[		if (look != x) {, 			throw expected("'" + x + "'");, 		}, 		GetChar();, 	}],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/poi/ss/formula/FormulaParser.java,SkipWhite,239-242,[		while (IsWhite(look)) {, 			GetChar();, 		}, 	}],,
BAD_PRACTICE,NM_METHOD_NAMING_CONVENTION,org/apache/poi/ss/formula/FormulaParser.java,Term,1426-1444,[		ParseNode result = powerFactor();, 		while(true) {, 			SkipWhite();, 			Ptg operator;, 			switch(look) {, 				case '*':, 					Match('*');, 					operator = MultiplyPtg.instance;, 					break;, 				case '/':, 					Match('/');, 					operator = DividePtg.instance;, 					break;, 				default:, 					return result; // finished with Term, 			}, 			ParseNode other = powerFactor();, 			result = new ParseNode(operator, result, other);, 		}],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/poi/ss/formula/FormulaParser.java,parseRangeable,460-460,[				return createAreaRefParseNode(sheetIden, part1, part2);],,
STYLE,FE_FLOATING_POINT_EQUALITY,org/apache/poi/ss/formula/TestEvaluationCache.java,testBlankCellChangedToValueCell_bug46053,609-609,[		if (cv.getNumberValue() == 2.2) {],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/poi/ss/formula/TestEvaluationCache.java,testPlainValueCache,706-734,[        Sheet summary = wb.createSheet("summary");,         wb.setActiveSheet(wb.getSheetIndex(summary));, ,         //formula referring all sheets created below,         row = summary.createRow(0);,         Cell summaryCell = row.createCell(0);,         summaryCell.setCellFormula("SUM(A2:A" + (numberOfSheets + 2) + ")");, , ,         //create sheets with cells having (different) numbers,         // and add a row to summary,         for (int i = 1; i < numberOfSheets; i++) {,             Sheet sheet = wb.createSheet("new" + i);, ,             row = sheet.createRow(0);,             cell = row.createCell(0);,             cell.setCellValue(i);, ,             row = summary.createRow(i);,             cell = row.createCell(0);,             cell.setCellFormula("new" + i + "!A1");, ,         }, , ,         //calculate,         FormulaEvaluator evaluator = wb.getCreationHelper().createFormulaEvaluator();,         evaluator.evaluateFormulaCell(summaryCell);,     }],,
BAD_PRACTICE,SE_COMPARATOR_SHOULD_BE_SERIALIZABLE,org/apache/poi/ss/formula/TestEvaluationCache.java,,60-85,[	private static final class FormulaCellCacheEntryComparer implements Comparator<ICacheEntry> {, , 		private final Map<ICacheEntry,EvaluationCell> _formulaCellsByCacheEntry;, , 		public FormulaCellCacheEntryComparer(Map<ICacheEntry,EvaluationCell> formulaCellsByCacheEntry) {, 			_formulaCellsByCacheEntry = formulaCellsByCacheEntry;, 		}, 		private EvaluationCell getCell(ICacheEntry a) {, 			return _formulaCellsByCacheEntry.get(a);, 		}, 		public int compare(ICacheEntry oa, ICacheEntry ob) {, 			EvaluationCell a = getCell(oa);, 			EvaluationCell b = getCell(ob);, 			int cmp;, 			cmp = a.getRowIndex() - b.getRowIndex();, 			if (cmp != 0) {, 				return cmp;, 			}, 			cmp = a.getColumnIndex() - b.getColumnIndex();, 			if (cmp != 0) {, 				return cmp;, 			}, 			if (a.getSheet() == b.getSheet()) {, 				return 0;, 			}, 			throw new RuntimeException("Incomplete code - don't know how to order sheets");],,
I18N,DM_CONVERT_CASE,org/apache/poi/ss/formula/atp/AnalysisToolPak.java,findFunction,51-51,[        return _functionsByName.get(name.toUpperCase());],,
CORRECTNESS,IL_INFINITE_RECURSIVE_LOOP,org/apache/poi/ss/formula/atp/DateParser.java,<init>,34-34,[    public DateParser instance = new DateParser();],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/poi/ss/formula/atp/DateParser.java,,34-34,[    public DateParser instance = new DateParser();],,
PERFORMANCE,DM_STRING_TOSTRING,org/apache/poi/ss/formula/atp/TestNetworkdaysFunction.java,testFailWhenStartDateAfterEndDate,80-80,[        assertEquals(NAME_INVALID, NetworkdaysFunction.instance.evaluate(new ValueEval[]{ new StringEval(END_DATE.toString()),],,testFailWhenStartDateAfterEndDate,81-81,[                new StringEval(STARTING_DATE.toString()) }, EC));],,
PERFORMANCE,DM_STRING_TOSTRING,org/apache/poi/ss/formula/atp/TestNetworkdaysFunction.java,testReturnNetworkdays,86-86,[                new StringEval(STARTING_DATE.toString()), new StringEval(END_DATE.toString()) }, EC)).getNumberValue());],,
PERFORMANCE,DM_STRING_TOSTRING,org/apache/poi/ss/formula/atp/TestNetworkdaysFunction.java,testReturnNetworkdaysWithAHoliday,91-91,[                new StringEval(STARTING_DATE.toString()), new StringEval(END_DATE.toString()), new StringEval(FIRST_HOLIDAY.toString()) },],,
PERFORMANCE,DM_STRING_TOSTRING,org/apache/poi/ss/formula/atp/TestNetworkdaysFunction.java,testReturnNetworkdaysWithManyHolidays,97-97,[                new StringEval(STARTING_DATE.toString()), new StringEval(END_DATE.toString()),],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/poi/ss/formula/atp/TestNetworkdaysFunction.java,,106-131,[            this(0, 0, 0, holidays.length - 1);,             this.holidays = new ArrayList<ValueEval>();,             for (String holiday : holidays) {,                 this.holidays.add(new StringEval(holiday));,             },         }, ,         protected MockAreaEval(int firstRow, int firstColumn, int lastRow, int lastColumn) {,             super(firstRow, firstColumn, lastRow, lastColumn);,         }, ,         @Override,         public ValueEval getRelativeValue(int relativeRowIndex, int relativeColumnIndex) {,             return this.holidays.get(relativeColumnIndex);,         }, ,         public AreaEval offset(int relFirstRowIx, int relLastRowIx, int relFirstColIx, int relLastColIx) {,             return null;,         }, ,         public TwoDEval getColumn(int columnIndex) {,             return null;,         }, ,         public TwoDEval getRow(int rowIndex) {,             return null;],,
PERFORMANCE,DM_STRING_TOSTRING,org/apache/poi/ss/formula/atp/TestWorkdayFunction.java,testReturnNetworkdaysWithManyHolidays,102-102,[                new StringEval(STARTING_DATE.toString()), new NumberEval(151),],,
PERFORMANCE,DM_STRING_TOSTRING,org/apache/poi/ss/formula/atp/TestWorkdayFunction.java,testReturnRetroativeWorkday,96-96,[                new StringEval(STARTING_DATE.toString()), new NumberEval(-5), new StringEval(RETROATIVE_HOLIDAY.toString()) }, EC))],,
PERFORMANCE,DM_STRING_TOSTRING,org/apache/poi/ss/formula/atp/TestWorkdayFunction.java,testReturnWorkdays,86-86,[                new StringEval(STARTING_DATE.toString()), new NumberEval(151) }, EC)).getNumberValue()));],,
PERFORMANCE,DM_STRING_TOSTRING,org/apache/poi/ss/formula/atp/TestWorkdayFunction.java,testReturnWorkdaysWithDaysTruncated,91-91,[                new StringEval(STARTING_DATE.toString()), new NumberEval(151.99999) }, EC)).getNumberValue()));],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/poi/ss/formula/atp/TestWorkdayFunction.java,,111-136,[            this(0, 0, 0, holidays.length - 1);,             this.holidays = new ArrayList<ValueEval>();,             for (String holiday : holidays) {,                 this.holidays.add(new StringEval(holiday));,             },         }, ,         protected MockAreaEval(int firstRow, int firstColumn, int lastRow, int lastColumn) {,             super(firstRow, firstColumn, lastRow, lastColumn);,         }, ,         @Override,         public ValueEval getRelativeValue(int relativeRowIndex, int relativeColumnIndex) {,             return this.holidays.get(relativeColumnIndex);,         }, ,         public AreaEval offset(int relFirstRowIx, int relLastRowIx, int relFirstColIx, int relLastColIx) {,             return null;,         }, ,         public TwoDEval getColumn(int columnIndex) {,             return null;,         }, ,         public TwoDEval getRow(int rowIndex) {,             return null;],,
STYLE,FE_FLOATING_POINT_EQUALITY,org/apache/poi/ss/formula/atp/TestYearFracCalculatorFromSpreadsheet.java,getIntCell,129-129,[		if (Math.floor(dVal) != dVal) {],,
STYLE,FE_FLOATING_POINT_EQUALITY,org/apache/poi/ss/formula/atp/TestYearFracCalculatorFromSpreadsheet.java,processRow,107-107,[		if (expectedValue != actualValue) {],,processRow,112-112,[		if (expectedValue != actualValue) {],,
STYLE,SF_SWITCH_FALLTHROUGH,org/apache/poi/ss/formula/atp/YearFrac.java,evaluate,69-71,[					basis = evaluateIntArg(args[2], srcCellRow, srcCellCol);, 				case 2:, 					break;],,
PERFORMANCE,DM_FP_NUMBER_CTOR,org/apache/poi/ss/formula/constant/ConstantValueParser.java,readAConstantValue,64-64,[				return new Double(in.readDouble());],,
PERFORMANCE,DM_FP_NUMBER_CTOR,org/apache/poi/ss/formula/constant/TestConstantValueParser.java,<clinit>,34-34,[	private static final Object[] SAMPLE_VALUES = {],,
BAD_PRACTICE,SE_BAD_FIELD,org/apache/poi/ss/formula/eval/ErrorEval.java,,29-109,[    private static final ErrorConstants EC = null;, ,     /** <b>#NULL!</b>  - Intersection of two cell ranges is empty */,     public static final ErrorEval NULL_INTERSECTION = new ErrorEval(EC.ERROR_NULL);,     /** <b>#DIV/0!</b> - Division by zero */,     public static final ErrorEval DIV_ZERO = new ErrorEval(EC.ERROR_DIV_0);,     /** <b>#VALUE!</b> - Wrong type of operand */,     public static final ErrorEval VALUE_INVALID = new ErrorEval(EC.ERROR_VALUE);,     /** <b>#REF!</b> - Illegal or deleted cell reference */,     public static final ErrorEval REF_INVALID = new ErrorEval(EC.ERROR_REF);,     /** <b>#NAME?</b> - Wrong function or range name */,     public static final ErrorEval NAME_INVALID = new ErrorEval(EC.ERROR_NAME);,     /** <b>#NUM!</b> - Value range overflow */,     public static final ErrorEval NUM_ERROR = new ErrorEval(EC.ERROR_NUM);,     /** <b>#N/A</b> - Argument or function not available */,     public static final ErrorEval NA = new ErrorEval(EC.ERROR_NA);, , ,     // POI internal error codes,     private static final int CIRCULAR_REF_ERROR_CODE = 0xFFFFFFC4;,     private static final int FUNCTION_NOT_IMPLEMENTED_CODE = 0xFFFFFFE2;, ,     // Note - Excel does not seem to represent this condition with an error code,     public static final ErrorEval CIRCULAR_REF_ERROR = new ErrorEval(CIRCULAR_REF_ERROR_CODE);, , ,     /**,      * Translates an Excel internal error code into the corresponding POI ErrorEval instance,      * @param errorCode,      */,     public static ErrorEval valueOf(int errorCode) {,         switch(errorCode) {,             case ErrorConstants.ERROR_NULL:  return NULL_INTERSECTION;,             case ErrorConstants.ERROR_DIV_0: return DIV_ZERO;,             case ErrorConstants.ERROR_VALUE: return VALUE_INVALID;,             case ErrorConstants.ERROR_REF:   return REF_INVALID;,             case ErrorConstants.ERROR_NAME:  return NAME_INVALID;,             case ErrorConstants.ERROR_NUM:   return NUM_ERROR;,             case ErrorConstants.ERROR_NA:    return NA;,             // non-std errors (conditions modeled as errors by POI),             case CIRCULAR_REF_ERROR_CODE:        return CIRCULAR_REF_ERROR;,         },         throw new RuntimeException("Unexpected error code (" + errorCode + ")");,     }, ,     /**,      * Converts error codes to text.  Handles non-standard error codes OK.  ,      * For debug/test purposes (and for formatting error messages).,      * @return the String representation of the specified Excel error code.,      */,     public static String getText(int errorCode) {,         if(ErrorConstants.isValidCode(errorCode)) {,             return ErrorConstants.getText(errorCode);,         },         // It is desirable to make these (arbitrary) strings look clearly different from any other,         // value expression that might appear in a formula.  In addition these error strings should,         // look unlike the standard Excel errors.  Hence tilde ('~') was used.,         switch(errorCode) {,             case CIRCULAR_REF_ERROR_CODE: return "~CIRCULAR~REF~";,             case FUNCTION_NOT_IMPLEMENTED_CODE: return "~FUNCTION~NOT~IMPLEMENTED~";,         },         return "~non~std~err(" + errorCode + ")~";,     }, ,     private int _errorCode;,     /**,      * @param errorCode an 8-bit value,      */,     private ErrorEval(int errorCode) {,         _errorCode = errorCode;,     }, ,     public int getErrorCode() {,         return _errorCode;,     },     public String toString() {,         StringBuffer sb = new StringBuffer(64);,         sb.append(getClass().getName()).append(" [");,         sb.append(getText(_errorCode));,         sb.append("]");,         return sb.toString();],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/poi/ss/formula/eval/FunctionEval.java,,51-51,[	protected static final Function[] functions = produceFunctions();],,
BAD_PRACTICE,NP_BOOLEAN_RETURN_NULL,org/apache/poi/ss/formula/eval/OperandResolver.java,coerceValueToBoolean,286-286,[			return null;],,coerceValueToBoolean,293-293,[			return null;],,coerceValueToBoolean,298-298,[				return null;],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/poi/ss/formula/eval/TestFormulasFromSpreadsheet.java,confirmExpectedResult,116-136,[		switch (expected.getCellType()) {, 			case Cell.CELL_TYPE_BLANK:, 				assertEquals(msg, Cell.CELL_TYPE_BLANK, actual.getCellType());, 				break;, 			case Cell.CELL_TYPE_BOOLEAN:, 				assertEquals(msg, Cell.CELL_TYPE_BOOLEAN, actual.getCellType());, 				assertEquals(msg, expected.getBooleanCellValue(), actual.getBooleanValue());, 				break;, 			case Cell.CELL_TYPE_ERROR:, 				assertEquals(msg, Cell.CELL_TYPE_ERROR, actual.getCellType());, 				assertEquals(msg, ErrorEval.getText(expected.getErrorCellValue()), ErrorEval.getText(actual.getErrorValue()));, 				break;, 			case Cell.CELL_TYPE_FORMULA: // will never be used, since we will call method after formula evaluation, 				throw new AssertionFailedError("Cannot expect formula as result of formula evaluation: " + msg);, 			case Cell.CELL_TYPE_NUMERIC:, 				assertEquals(msg, Cell.CELL_TYPE_NUMERIC, actual.getCellType());, 				TestMathX.assertEquals(msg, expected.getNumericCellValue(), actual.getNumberValue(), TestMathX.POS_ZERO, TestMathX.DIFF_TOLERANCE_FACTOR);, 				break;, 			case Cell.CELL_TYPE_STRING:, 				assertEquals(msg, Cell.CELL_TYPE_STRING, actual.getCellType());, 				assertEquals(msg, expected.getRichStringCellValue().getString(), actual.getStringValue());],,
BAD_PRACTICE,EQ_COMPARETO_USE_OBJECT_EQUALS,org/apache/poi/ss/formula/eval/forked/ForkedEvaluationWorkbook.java,compareTo,154-154,[			return _index - o._index;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/poi/ss/formula/eval/forked/TestForkedEvaluator.java,,60-62,[		IStabilityClassifier stabilityClassifier = new IStabilityClassifier() {, 			public boolean isCellFinal(int sheetIndex, int rowIndex, int columnIndex) {, 				return sheetIndex == 1;],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/poi/ss/formula/function/ExcelFileFormatDocFunctionExtractor.java,main,615-615,[		tempEFFDocFile.delete();],,
BAD_PRACTICE,ES_COMPARING_PARAMETER_STRING_WITH_EQ,org/apache/poi/ss/formula/function/ExcelFileFormatDocFunctionExtractor.java,endElement,301-301,[			if(expectedName != name) {],,
STYLE,RV_CHECK_FOR_POSITIVE_INDEXOF,org/apache/poi/ss/formula/function/TestReadMissingBuiltInFuncs.java,testDatedif,58-58,[				if(e.getMessage().indexOf("AttrPtg") > 0) {],,
BAD_PRACTICE,NP_BOOLEAN_RETURN_NULL,org/apache/poi/ss/formula/functions/Countif.java,parseBoolean,510-510,[			return null;],,parseBoolean,526-526,[		return null;],,
STYLE,FE_FLOATING_POINT_EQUALITY,org/apache/poi/ss/formula/functions/Countif.java,matches,216-216,[				return _value == val.doubleValue();],,
STYLE,FE_FLOATING_POINT_EQUALITY,org/apache/poi/ss/formula/functions/Even.java,calcEven,44-44,[		if (x == d) {],,
STYLE,SF_SWITCH_FALLTHROUGH,org/apache/poi/ss/formula/functions/FinanceFunction.java,evaluate,84-86,[				arg4 = ds[4];, 			case 4:, 				arg3 = ds[3];],,evaluate,86-88,[				arg3 = ds[3];, 			case 3:, 				break;],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/poi/ss/formula/functions/Indirect.java,parseWorkbookAndSheetName,135-135,[			return null;],,parseWorkbookAndSheetName,138-138,[			return null;],,parseWorkbookAndSheetName,142-142,[			return null;],,parseWorkbookAndSheetName,148-148,[				return null;],,parseWorkbookAndSheetName,152-152,[				return null;],,parseWorkbookAndSheetName,159-159,[					return null;],,parseWorkbookAndSheetName,163-163,[					return null;],,parseWorkbookAndSheetName,175-175,[				return null;],,parseWorkbookAndSheetName,183-183,[				return null;],,parseWorkbookAndSheetName,187-187,[				return null;],,parseWorkbookAndSheetName,191-191,[				return null;],,
PERFORMANCE,DM_FP_NUMBER_CTOR,org/apache/poi/ss/formula/functions/Mode.java,collectValue,128-128,[			temp.add(new Double(((NumberEval) arg).getNumberValue()));],,
STYLE,FE_FLOATING_POINT_EQUALITY,org/apache/poi/ss/formula/functions/Mode.java,evaluate,57-57,[				if (v[i] == v[j])],,
STYLE,FE_FLOATING_POINT_EQUALITY,org/apache/poi/ss/formula/functions/NumericFunction.java,evaluate,368-368,[				if (base == Math.E) {],,
STYLE,FE_FLOATING_POINT_EQUALITY,org/apache/poi/ss/formula/functions/Odd.java,calcOdd,40-40,[		if (x == dpm1) {],,
STYLE,SF_SWITCH_FALLTHROUGH,org/apache/poi/ss/formula/functions/Offset.java,evaluate,176-178,[					width = evaluateIntArg(args[4], srcCellRow, srcCellCol);, 				case 4:, 					height = evaluateIntArg(args[3], srcCellRow, srcCellCol);],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/poi/ss/formula/functions/Offset.java,evaluate,174-178,[			switch(args.length) {, 				case 5:, 					width = evaluateIntArg(args[4], srcCellRow, srcCellCol);, 				case 4:, 					height = evaluateIntArg(args[3], srcCellRow, srcCellCol);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/poi/ss/formula/functions/TestCalendarFieldFunction.java,confirm,76-76,[        cell11.setCellFormula(formulaText);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/poi/ss/formula/functions/TestCalendarFieldFunction.java,confirm,77-77,[        evaluator.clearAllCachedResultValues();],,
STYLE,FE_FLOATING_POINT_EQUALITY,org/apache/poi/ss/formula/functions/TestCountFuncs.java,testCountFunctionFromSpreadsheet,448-448,[			if (actualValue != expectedValue) {],,
BAD_PRACTICE,NM_CONFUSING,org/apache/poi/ss/formula/functions/TestCountFuncs.java,testCountA,81-105,[		args = new ValueEval[] {, 			new NumberEval(0),, 		};, 		confirmCountA(1, args);, , 		args = new ValueEval[] {, 			new NumberEval(0),, 			new NumberEval(0),, 			new StringEval(""),, 		};, 		confirmCountA(3, args);, , 		args = new ValueEval[] {, 			EvalFactory.createAreaEval("D2:F5", new ValueEval[12]),, 		};, 		confirmCountA(12, args);, , 		args = new ValueEval[] {, 			EvalFactory.createAreaEval("D1:F5", new ValueEval[15]),, 			EvalFactory.createRefEval("A1"),, 			EvalFactory.createAreaEval("A1:G6", new ValueEval[42]),, 			new NumberEval(0),, 		};, 		confirmCountA(59, args);, 	}],,testCounta,172-197,[        Workbook wb = new HSSFWorkbook();, ,         FormulaEvaluator fe = wb.getCreationHelper().createFormulaEvaluator();, ,         Sheet sh = wb.createSheet();,         Cell a1 = sh.createRow(0).createCell(0);,         a1.setCellValue(1);,         Cell a2 = sh.createRow(1).createCell(0);,         a2.setCellValue(3);,         Cell a3 = sh.createRow(2).createCell(0);,         a3.setCellFormula("SUBTOTAL(3,A1:A2)");,         Cell a4 = sh.createRow(3).createCell(0);,         a4.setCellValue("POI");                  // A4 is string and not counted,         Cell a5 = sh.createRow(4).createCell(0); // A5 is blank and not counted, ,         Cell a6 = sh.createRow(5).createCell(0);,         a6.setCellFormula("SUBTOTAL(3,A1:A5)*2 + 2");,         Cell a7 = sh.createRow(6).createCell(0);,         a7.setCellFormula("SUBTOTAL(3,A1:A6)");, ,         fe.evaluateAll();, ,         assertEquals(2.0, a3.getNumericCellValue());,         assertEquals(8.0, a6.getNumericCellValue());,         assertEquals(3.0, a7.getNumericCellValue());,     }],,
STYLE,FE_FLOATING_POINT_EQUALITY,org/apache/poi/ss/formula/functions/TestDays360.java,confirm,138-138,[			if (numberEval.getNumberValue() != expResult) {],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/poi/ss/formula/functions/TestIndexFunctionFromSpreadsheet.java,confirmExpectedResult,88-98,[		switch (expected.getCellType()) {, 			case HSSFCell.CELL_TYPE_BOOLEAN:, 				assertEquals(msg, expected.getBooleanCellValue(), actual.getBooleanValue());, 				break;, 			case HSSFCell.CELL_TYPE_FORMULA: // will never be used, since we will call method after formula evaluation, 				throw new AssertionFailedError("Cannot expect formula as result of formula evaluation: " + msg);, 			case HSSFCell.CELL_TYPE_NUMERIC:, 				assertEquals(msg, expected.getNumericCellValue(), actual.getNumberValue(), 0.0);, 				break;, 			case HSSFCell.CELL_TYPE_STRING:, 				assertEquals(msg, expected.getRichStringCellValue().getString(), actual.getStringValue());],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/poi/ss/formula/functions/TestLookupFunctionsFromSpreadsheet.java,confirmExpectedResult,110-120,[		switch (expected.getCellType()) {, 			case HSSFCell.CELL_TYPE_BOOLEAN:, 				assertEquals(msg, expected.getBooleanCellValue(), actual.getBooleanValue());, 				break;, 			case HSSFCell.CELL_TYPE_FORMULA: // will never be used, since we will call method after formula evaluation, 				throw new IllegalStateException("Cannot expect formula as result of formula evaluation: " + msg);, 			case HSSFCell.CELL_TYPE_NUMERIC:, 				assertEquals(expected.getNumericCellValue(), actual.getNumberValue(), 0.0);, 				break;, 			case HSSFCell.CELL_TYPE_STRING:, 				assertEquals(msg, expected.getRichStringCellValue().getString(), actual.getStringValue());],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/poi/ss/formula/functions/TestLookupFunctionsFromSpreadsheet.java,testFunctionsFromTestSpreadsheet,183-185,[			switch(sheetResult) {, 				case Result.ALL_EVALUATIONS_SUCCEEDED: _sheetSuccessCount ++; break;, 				case Result.SOME_EVALUATIONS_FAILED: _sheetFailureCount ++; break;],,
PERFORMANCE,DM_FP_NUMBER_CTOR,org/apache/poi/ss/formula/functions/TestStatsLib.java,confirmMode,217-217,[    	confirmMode(v, new Double(expectedResult));],,
I18N,DM_CONVERT_CASE,org/apache/poi/ss/formula/functions/TextFunction.java,evaluate,107-107,[			return new StringEval(arg.toLowerCase());],,
I18N,DM_CONVERT_CASE,org/apache/poi/ss/formula/functions/TextFunction.java,evaluate,112-112,[			return new StringEval(arg.toUpperCase());],,
STYLE,UC_USELESS_CONDITION,org/apache/poi/ss/formula/functions/TextFunction.java,evaluate,197-197,[			if (numChars < 0 || startIx > len) {],,
I18N,DM_CONVERT_CASE,org/apache/poi/ss/formula/functions/TextFunction.java,eval,342-342,[				result = haystack.toUpperCase().indexOf(needle.toUpperCase(), startIndex);],,
PERFORMANCE,DM_FP_NUMBER_CTOR,org/apache/poi/ss/formula/functions/Value.java,<clinit>,42-42,[	private static final Double ZERO = new Double(0.0);],,
PERFORMANCE,DM_FP_NUMBER_CTOR,org/apache/poi/ss/formula/functions/Value.java,convertTextToNumber,182-182,[		return new Double(foundUnaryMinus ? -d : d);],,
I18N,DM_CONVERT_CASE,org/apache/poi/ss/formula/ptg/AbstractFunctionPtg.java,isBuiltInFunctionName,122-122,[        short ix = FunctionMetadataRegistry.lookupIndexByName(name.toUpperCase());],,
I18N,DM_CONVERT_CASE,org/apache/poi/ss/formula/ptg/AbstractFunctionPtg.java,lookupIndex,144-144,[        short ix = FunctionMetadataRegistry.lookupIndexByName(name.toUpperCase());],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/poi/ss/formula/ptg/TestAreaPtg.java,shiftAllColumnsBy1,90-90,[		Ptg[] ptgs = HSSFFormulaParser.parse(formula, wb);],,shiftAllColumnsBy1,101-101,[		String newFormula = HSSFFormulaParser.toFormulaString(wb, ptgs);],,
PERFORMANCE,DM_FP_NUMBER_CTOR,org/apache/poi/ss/formula/ptg/TestArrayPtg.java,testReadWriteTokenValueBytes,70-70,[		assertEquals(new Double(0), values[1][0]);],,
STYLE,REC_CATCH_EXCEPTION,org/apache/poi/ss/formula/ptg/TestExternalNameReference.java,testReadCalcSheet,62-62,[	    }catch(Exception e){],,
STYLE,REC_CATCH_EXCEPTION,org/apache/poi/ss/formula/ptg/TestExternalNameReference.java,testReadReferencedSheet,75-75,[	    }catch(Exception e){],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/poi/ss/formula/ptg/TestExternalNameReference.java,,35-35,[	double MARKUP_COST = 1.9d;],,
I18N,DM_CONVERT_CASE,org/apache/poi/ss/formula/udf/DefaultUDFFinder.java,<init>,41-41,[			m.put(functionNames[i].toUpperCase(), functionImpls[i]);],,
I18N,DM_CONVERT_CASE,org/apache/poi/ss/formula/udf/DefaultUDFFinder.java,findFunction,47-47,[		return _functionsByName.get(name.toUpperCase());],,
BAD_PRACTICE,IC_SUPERCLASS_USES_SUBCLASS_DURING_INITIALIZATION,org/apache/poi/ss/formula/udf/UDFFinder.java,<clinit>,29-29,[	public static final UDFFinder DEFAULT = new AggregatingUDFFinder(AnalysisToolPak.instance);],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/poi/ss/usermodel/BaseTestCell.java,assertProhibitedValueAccess,102-116,[				switch (type) {, 					case Cell.CELL_TYPE_NUMERIC:, 						cell.getNumericCellValue();, 						break;, 					case Cell.CELL_TYPE_STRING:, 						cell.getStringCellValue();, 						break;, 					case Cell.CELL_TYPE_BOOLEAN:, 						cell.getBooleanCellValue();, 						break;, 					case Cell.CELL_TYPE_FORMULA:, 						cell.getCellFormula();, 						break;, 					case Cell.CELL_TYPE_ERROR:, 						cell.getErrorCellValue();],,
STYLE,RV_CHECK_FOR_POSITIVE_INDEXOF,org/apache/poi/ss/usermodel/BaseTestConditionalFormatting.java,testClone,385-385,[            if (e.getMessage().indexOf("needs to define a clone method") > 0) {],,
PERFORMANCE,SS_SHOULD_BE_STATIC,org/apache/poi/ss/usermodel/BaseTestDataFormat.java,,68-68,[    protected final String poundFmt = "\"\u00a3\"#,##0;[Red]\\-\"\u00a3\"#,##0";],,
STYLE,NP_LOAD_OF_KNOWN_NULL_VALUE,org/apache/poi/ss/usermodel/BaseTestDataValidation.java,addValidation,72-72,[			addValidationInternal(operatorType, firstFormula, secondFormula, errorStyle, ruleDescr,],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/poi/ss/usermodel/BaseTestSheetHiding.java,testHideUnHideFlags,117-117,[        assertTrue(wbH.isSheetHidden(0));],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/poi/ss/usermodel/BaseTestSheetHiding.java,testTextSheets,90-90,[        assertEquals(2, wbH.getNumberOfSheets());],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/poi/ss/usermodel/BaseTestSheetHiding.java,testUnHide,141-141,[        wbH.setSheetHidden(0, false);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/poi/ss/usermodel/BaseTestSheetHiding.java,testHide,128-128,[        wbU.setSheetHidden(0, true);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/poi/ss/usermodel/BaseTestSheetHiding.java,testHideUnHideFlags,119-119,[        assertFalse(wbU.isSheetHidden(0));],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/poi/ss/usermodel/BaseTestSheetHiding.java,testTextSheets,91-91,[        assertEquals(2, wbU.getNumberOfSheets());],,
I18N,DM_CONVERT_CASE,org/apache/poi/ss/usermodel/DataFormatter.java,createDateFormat,392-392,[            formatStr = dateMatcher.replaceAll(match.toUpperCase().replaceAll("D", "E"));],,
PERFORMANCE,DM_FP_NUMBER_CTOR,org/apache/poi/ss/usermodel/DataFormatter.java,formatRawCellContents,699-699,[            String result = numberFormat.format(new Double(value));],,
PERFORMANCE,DM_FP_NUMBER_CTOR,org/apache/poi/ss/usermodel/DataFormatter.java,getFormattedNumberString,660-660,[        return numberFormat.format(new Double(d));],,
STYLE,FE_FLOATING_POINT_EQUALITY,org/apache/poi/ss/usermodel/DataFormatter.java,isWholeNumber,589-589,[        return d == Math.floor(d);],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/poi/ss/usermodel/DataFormatter.java,,1051-1064,[        private static final DecimalFormat df = createIntegerOnlyFormat("##########");,         private final String str;,         public ConstantStringFormat(String s) {,             str = s;,         }, ,         @Override,         public StringBuffer format(Object obj, StringBuffer toAppendTo, FieldPosition pos) {,             return toAppendTo.append(str);,         }, ,         @Override,         public Object parseObject(String source, ParsePosition pos) {,             return df.parseObject(source, pos);],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/poi/ss/usermodel/DataFormatter.java,,979-1037,[       public FractionFormat(String s) {,           str = s;,        },        ,        public String format(Number num) {,           double wholePart = Math.floor(num.doubleValue());,           double decPart = num.doubleValue() - wholePart;,           if (wholePart * decPart == 0) {,              return "0";,           },           ,           // Split the format string into decimal and fraction parts,           String[] parts = str.split(" ");,           String[] fractParts;,           if (parts.length == 2) {,              fractParts = parts[1].split("/");,           } else {,              fractParts = str.split("/");,           },           ,           // Excel supports both #/# and ?/?, but Java only the former,           for (int i=0; i<fractParts.length; i++) {,              fractParts[i] = fractParts[i].replace('?', '#');,           }, ,           if (fractParts.length == 2) {,              double minVal = 1.0;,              double currDenom = Math.pow(10 ,  fractParts[1].length()) - 1d;,              double currNeum = 0;,              for (int i = (int)(Math.pow(10,  fractParts[1].length())- 1d); i > 0; i--) {,                 for(int i2 = (int)(Math.pow(10,  fractParts[1].length())- 1d); i2 > 0; i2--){,                    if (minVal >=  Math.abs((double)i2/(double)i - decPart)) {,                       currDenom = i;,                       currNeum = i2;,                       minVal = Math.abs((double)i2/(double)i  - decPart);,                    },                 },              },              NumberFormat neumFormatter = new DecimalFormat(fractParts[0]);,              NumberFormat denomFormatter = new DecimalFormat(fractParts[1]);,              if (parts.length == 2) {,                 NumberFormat wholeFormatter = new DecimalFormat(parts[0]);,                 String result = wholeFormatter.format(wholePart) + " " + neumFormatter.format(currNeum) + "/" + denomFormatter.format(currDenom);,                 return result;,              } else {,                 String result = neumFormatter.format(currNeum + (currDenom * wholePart)) + "/" + denomFormatter.format(currDenom);,                 return result;,              },           } else {,              throw new IllegalArgumentException("Fraction must have 2 parts, found " + fractParts.length + " for fraction format " + str);,           },        }, ,        public StringBuffer format(Object obj, StringBuffer toAppendTo, FieldPosition pos) {,           return toAppendTo.append(format((Number)obj));,        }, ,        public Object parseObject(String source, ParsePosition pos) {,           throw new NotImplementedException("Reverse parsing not supported");],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/poi/ss/usermodel/DataFormatter.java,format,954-954,[            if(seg1 != null && seg1.trim().length() > 0) {],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/poi/ss/usermodel/DataFormatter.java,format,957-957,[            if(seg2 != null && seg2.trim().length() > 0) {],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/poi/ss/usermodel/DataFormatter.java,,934-969,[        public static final Format instance = new PhoneFormat();,         private static final DecimalFormat df = createIntegerOnlyFormat("##########");,         private PhoneFormat() {,             // enforce singleton,         }, ,         /** Format a number as a phone number */,         public static String format(Number num) {,             String result = df.format(num);,             StringBuffer sb = new StringBuffer();,             String seg1, seg2, seg3;,             int len = result.length();,             if (len <= 4) {,                 return result;,             }, ,             seg3 = result.substring(len - 4, len);,             seg2 = result.substring(Math.max(0, len - 7), len - 4);,             seg1 = result.substring(Math.max(0, len - 10), Math.max(0, len - 7));, ,             if(seg1 != null && seg1.trim().length() > 0) {,                 sb.append('(').append(seg1).append(") ");,             },             if(seg2 != null && seg2.trim().length() > 0) {,                 sb.append(seg2).append('-');,             },             sb.append(seg3);,             return sb.toString();,         }, ,         public StringBuffer format(Object obj, StringBuffer toAppendTo, FieldPosition pos) {,             return toAppendTo.append(format((Number)obj));,         }, ,         public Object parseObject(String source, ParsePosition pos) {,             return df.parseObject(source, pos);],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/poi/ss/usermodel/DataFormatter.java,,871-892,[        public static final Format instance = new SSNFormat();,         private static final DecimalFormat df = createIntegerOnlyFormat("000000000");,         private SSNFormat() {,             // enforce singleton,         }, ,         /** Format a number as an SSN */,         public static String format(Number num) {,             String result = df.format(num);,             StringBuffer sb = new StringBuffer();,             sb.append(result.substring(0, 3)).append('-');,             sb.append(result.substring(3, 5)).append('-');,             sb.append(result.substring(5, 9));,             return sb.toString();,         }, ,         public StringBuffer format(Object obj, StringBuffer toAppendTo, FieldPosition pos) {,             return toAppendTo.append(format((Number)obj));,         }, ,         public Object parseObject(String source, ParsePosition pos) {,             return df.parseObject(source, pos);],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/poi/ss/usermodel/DataFormatter.java,,903-923,[        public static final Format instance = new ZipPlusFourFormat();,         private static final DecimalFormat df = createIntegerOnlyFormat("000000000");,         private ZipPlusFourFormat() {,             // enforce singleton,         }, ,         /** Format a number as Zip + 4 */,         public static String format(Number num) {,             String result = df.format(num);,             StringBuffer sb = new StringBuffer();,             sb.append(result.substring(0, 5)).append('-');,             sb.append(result.substring(5, 9));,             return sb.toString();,         }, ,         public StringBuffer format(Object obj, StringBuffer toAppendTo, FieldPosition pos) {,             return toAppendTo.append(format((Number)obj));,         }, ,         public Object parseObject(String source, ParsePosition pos) {,             return df.parseObject(source, pos);],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/poi/ss/usermodel/ExcelStyleDateFormatter.java,,43-170,[    private DecimalFormat format1digit = new DecimalFormat("0");,     private DecimalFormat format2digits = new DecimalFormat("00");, ,     private DecimalFormat format3digit = new DecimalFormat("0");,     private DecimalFormat format4digits = new DecimalFormat("00");, ,     {,         DataFormatter.setExcelStyleRoundingMode(format1digit, RoundingMode.DOWN);,         DataFormatter.setExcelStyleRoundingMode(format2digits, RoundingMode.DOWN);,         DataFormatter.setExcelStyleRoundingMode(format3digit);,         DataFormatter.setExcelStyleRoundingMode(format4digits);,     }, ,     private double dateToBeFormatted = 0.0;, ,     public ExcelStyleDateFormatter() {,         super();,     }, ,     public ExcelStyleDateFormatter(String pattern) {,         super(processFormatPattern(pattern));,     }, ,     public ExcelStyleDateFormatter(String pattern,,                                    DateFormatSymbols formatSymbols) {,         super(processFormatPattern(pattern), formatSymbols);,     }, ,     public ExcelStyleDateFormatter(String pattern, Locale locale) {,         super(processFormatPattern(pattern), locale);,     }, ,     /**,      * Takes a format String, and replaces Excel specific bits,      * with our detection sequences,      */,     private static String processFormatPattern(String f) {,         String t = f.replaceAll("MMMMM", MMMMM_START_SYMBOL + "MMM" + MMMMM_TRUNCATE_SYMBOL);,         t = t.replaceAll("\\[H\\]", String.valueOf(H_BRACKET_SYMBOL));,         t = t.replaceAll("\\[HH\\]", String.valueOf(HH_BRACKET_SYMBOL));,         t = t.replaceAll("\\[m\\]", String.valueOf(M_BRACKET_SYMBOL));,         t = t.replaceAll("\\[mm\\]", String.valueOf(MM_BRACKET_SYMBOL));,         t = t.replaceAll("\\[s\\]", String.valueOf(S_BRACKET_SYMBOL));,         t = t.replaceAll("\\[ss\\]", String.valueOf(SS_BRACKET_SYMBOL));,         t = t.replaceAll("s.000", "s.S");,         t = t.replaceAll("s.00", "s." + LL_BRACKET_SYMBOL);,         t = t.replaceAll("s.0", "s." + L_BRACKET_SYMBOL);,         return t;,     }, ,     /**,      * Used to let us know what the date being,      * formatted is, in Excel terms, which we,      * may wish to use when handling elapsed,      * times.,      */,     public void setDateToBeFormatted(double date) {,         this.dateToBeFormatted = date;,     }, ,     @Override,     public StringBuffer format(Date date, StringBuffer paramStringBuffer,,                                FieldPosition paramFieldPosition) {,         // Do the normal format,         String s = super.format(date, paramStringBuffer, paramFieldPosition).toString();, ,         // Now handle our special cases,         if (s.indexOf(MMMMM_START_SYMBOL) != -1) {,             s = s.replaceAll(,                     MMMMM_START_SYMBOL + "(\\w)\\w+" + MMMMM_TRUNCATE_SYMBOL,,                     "$1",             );,         }, ,         if (s.indexOf(H_BRACKET_SYMBOL) != -1 ||,                 s.indexOf(HH_BRACKET_SYMBOL) != -1) {,             float hours = (float) dateToBeFormatted * 24;, ,             s = s.replaceAll(,                     String.valueOf(H_BRACKET_SYMBOL),,                     format1digit.format(hours),             );,             s = s.replaceAll(,                     String.valueOf(HH_BRACKET_SYMBOL),,                     format2digits.format(hours),             );,         }, ,         if (s.indexOf(M_BRACKET_SYMBOL) != -1 ||,                 s.indexOf(MM_BRACKET_SYMBOL) != -1) {,             float minutes = (float) dateToBeFormatted * 24 * 60;,             s = s.replaceAll(,                     String.valueOf(M_BRACKET_SYMBOL),,                     format1digit.format(minutes),             );,             s = s.replaceAll(,                     String.valueOf(MM_BRACKET_SYMBOL),,                     format2digits.format(minutes),             );,         },         if (s.indexOf(S_BRACKET_SYMBOL) != -1 ||,                 s.indexOf(SS_BRACKET_SYMBOL) != -1) {,             float seconds = (float) (dateToBeFormatted * 24.0 * 60.0 * 60.0);,             s = s.replaceAll(,                     String.valueOf(S_BRACKET_SYMBOL),,                     format1digit.format(seconds),             );,             s = s.replaceAll(,                     String.valueOf(SS_BRACKET_SYMBOL),,                     format2digits.format(seconds),             );,         }, ,         if (s.indexOf(L_BRACKET_SYMBOL) != -1 ||,                 s.indexOf(LL_BRACKET_SYMBOL) != -1) {,             float millisTemp = (float) ((dateToBeFormatted - Math.floor(dateToBeFormatted)) * 24.0 * 60.0 * 60.0);,             float millis = (millisTemp - (int) millisTemp);,             s = s.replaceAll(,                     String.valueOf(L_BRACKET_SYMBOL),,                     format3digit.format(millis * 10),             );,             s = s.replaceAll(,                     String.valueOf(LL_BRACKET_SYMBOL),,                     format4digits.format(millis * 100),             );,         }, ,         return new StringBuffer(s);],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/poi/ss/util/AreaReference.java,separateAreaRefs,324-334,[            switch(reference.charAt(i)) {,                 case CELL_DELIMITER:,                     if(!insideDelimitedName) {,                         if(delimiterPos >=0) {,                             throw new IllegalArgumentException("More than one cell delimiter '" ,                                     + CELL_DELIMITER + "' appears in area reference '" + reference + "'");,                         },                         delimiterPos = i;,                     },                 default:,                     continue;],,
I18N,DM_CONVERT_CASE,org/apache/poi/ss/util/CellReference.java,isColumnWithnRange,312-312,[			if(colStr.toUpperCase().compareTo(lastCol) > 0) {],,
BAD_PRACTICE,HE_EQUALS_USE_HASHCODE,org/apache/poi/ss/util/CellReference.java,equals,504-508,[		if(!(o instanceof CellReference)) {, 			return false;, 		}, 		CellReference cr = (CellReference) o;, 		return _rowIndex == cr._rowIndex],,
I18N,DM_CONVERT_CASE,org/apache/poi/ss/util/CellUtil.java,translateUnicodeValues,339-339,[		String lowerCaseStr = s.toLowerCase();],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/poi/ss/util/ImageUtils.java,getResolution,108-108,[        if(lst != null && lst.getLength() == 1) hdpi = (int)(mm2inch/Float.parseFloat(((Element)lst.item(0)).getAttribute("value")));],,getResolution,111-111,[        if(lst != null && lst.getLength() == 1) vdpi = (int)(mm2inch/Float.parseFloat(((Element)lst.item(0)).getAttribute("value")));],,
I18N,DM_CONVERT_CASE,org/apache/poi/ss/util/NumberComparer.java,toHex,171-171,[		return "0x" + Long.toHexString(Double.doubleToLongBits(a)).toUpperCase();],,
I18N,DM_CONVERT_CASE,org/apache/poi/ss/util/NumberRenderingSpreadsheetGenerator.java,interpretLong,232-232,[		return "0x" + Long.toHexString(l).toUpperCase();],,
I18N,DM_CONVERT_CASE,org/apache/poi/ss/util/NumberToTextConversionExamples.java,doubleToHexString,65-65,[			return "0x" + Long.toHexString(Double.doubleToLongBits(d)).toUpperCase() + "L";],,
STYLE,FE_FLOATING_POINT_EQUALITY,org/apache/poi/ss/util/NumberToTextConversionExamples.java,<init>,48-48,[				boolean javaParseOk = Double.parseDouble(javaRendering) == d;],,
BAD_PRACTICE,EQ_COMPARETO_USE_OBJECT_EQUALS,org/apache/poi/ss/util/Region.java,compareTo,178-192,[		if ((this.getRowFrom() == r.getRowFrom()), 				&& (this.getColumnFrom() == r.getColumnFrom()), 				&& (this.getRowTo() == r.getRowTo()), 				&& (this.getColumnTo() == r.getColumnTo())), 		{, 			return 0;, 		}, 		if ((this.getRowFrom() < r.getRowFrom()), 				|| (this.getColumnFrom() < r.getColumnFrom()), 				|| (this.getRowTo() < r.getRowTo()), 				|| (this.getColumnTo() < r.getColumnTo())), 		{, 			return 1;, 		}, 		return -1;],,
CORRECTNESS,EQ_SELF_USE_OBJECT,org/apache/poi/ss/util/Region.java,equals,164-164,[		return (compareTo(r) == 0);],,
BAD_PRACTICE,HE_EQUALS_USE_HASHCODE,org/apache/poi/ss/util/Region.java,equals,164-164,[		return (compareTo(r) == 0);],,
I18N,DM_CONVERT_CASE,org/apache/poi/ss/util/SheetUtil.java,getCellWidth,159-159,[                sval = String.valueOf(cell.getBooleanCellValue()).toUpperCase();],,
STYLE,UCF_USELESS_CONTROL_FLOW,org/apache/poi/ss/util/SheetUtil.java,getCellWidth,127-127,[                if (rt.numFormattingRuns() > 0) {],,
I18N,DM_CONVERT_CASE,org/apache/poi/ss/util/TestNumberToTextConverter.java,formatExample,77-77,[		String hexLong = Long.toHexString(example.getRawDoubleBits()).toUpperCase();],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/poi/ss/util/cellwalk/CellWalk.java,,111-125,[    private class SimpleCellWalkContext implements CellWalkContext {,         public long ordinalNumber = 0;,         public int rowNumber = 0;,         public int colNumber = 0;, ,         public long getOrdinalNumber() {,             return ordinalNumber;,         }, ,         public int getRowNumber() {,             return rowNumber;,         }, ,         public int getColumnNumber() {,             return colNumber;],,
I18N,DM_DEFAULT_ENCODING,org/apache/poi/util/HexDump.java,dump,73-73,[            stream.write( ("No Data" + System.getProperty( "line.separator")).getBytes() );],,dump,128-128,[            stream.write(buffer.toString().getBytes());],,
CORRECTNESS,INT_BAD_COMPARISON_WITH_SIGNED_BYTE,org/apache/poi/util/HexDump.java,dump,208-208,[                if ((data[ k + j ] >= ' ') && (data[ k + j ] < 127))],,
CORRECTNESS,INT_BAD_COMPARISON_WITH_SIGNED_BYTE,org/apache/poi/util/HexDump.java,dump,118-118,[                if ((data[ k + j ] >= ' ') && (data[ k + j ] < 127))],,
BAD_PRACTICE,RR_NOT_CHECKED,org/apache/poi/util/HexDump.java,main,461-461,[        in.read(b);],,
I18N,DM_DEFAULT_ENCODING,org/apache/poi/util/HexRead.java,readFromString,177-177,[            return readData(new ByteArrayInputStream( data.getBytes() ), -1);],,
STYLE,SF_SWITCH_FALLTHROUGH,org/apache/poi/util/HexRead.java,readData,142-149,[                    baseChar = 'A';,                 case 'a':,                 case 'b':,                 case 'c':,                 case 'd':,                 case 'e':,                 case 'f':,                     b <<= 4;],,
MALICIOUS_CODE,DP_DO_INSIDE_DO_PRIVILEGED,org/apache/poi/util/OOXMLLite.java,<clinit>,40-40,[            _classes.setAccessible(true);],,
STYLE,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,org/apache/poi/util/OOXMLLite.java,collectTests,149-149,[            for (File f : arg.listFiles()) {],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/poi/util/OOXMLLite.java,copyFile,183-183,[        destDirectory.mkdirs();],,
BAD_PRACTICE,DE_MIGHT_IGNORE,org/apache/poi/util/POILogFactory.java,getLogger,92-92,[        	} catch(Exception e) {}],,
STYLE,REC_CATCH_EXCEPTION,org/apache/poi/util/POILogFactory.java,getLogger,118-118,[            } catch(Exception e) {],,
PERFORMANCE,DM_FP_NUMBER_CTOR,org/apache/poi/util/POILogger.java,objectToObjectArray,658-658,[                results.add(new Double(array[ j ]));],,
PERFORMANCE,DM_FP_NUMBER_CTOR,org/apache/poi/util/POILogger.java,objectToObjectArray,649-649,[                results.add(new Float(array[ j ]));],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/poi/util/POILogger.java,,34-34,[    public static int DEBUG = 1;],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/poi/util/POILogger.java,,37-37,[    public static int ERROR = 7;],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/poi/util/POILogger.java,,38-38,[    public static int FATAL = 9;],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/poi/util/POILogger.java,,35-35,[    public static int INFO  = 3;],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/poi/util/POILogger.java,,36-36,[    public static int WARN  = 5;],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/poi/util/PackageHelper.java,copy,100-100,[        if(rels != null) for (PackageRelationship rel : rels) {],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/poi/util/PackageHelper.java,createTempFile,90-90,[        file.delete();],,
BAD_PRACTICE,IT_NO_SUCH_ELEMENT,org/apache/poi/util/StringUtil.java,next,415-418,[         int ourPos = position++;,          if(ourPos >= strings.length),             throw new ArrayIndexOutOfBoundsException(ourPos);,          return strings[ourPos];],,
MT_CORRECTNESS,LI_LAZY_INIT_UPDATE_STATIC,org/apache/poi/util/TempFile.java,createTempFile,40-42,[        if (dir == null),         {,             dir = new File(System.getProperty("java.io.tmpdir"), "poifiles");],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/poi/util/TempFile.java,createTempFile,43-43,[            dir.mkdir();],,
BAD_PRACTICE,DMI_ENTRY_SETS_MAY_REUSE_ENTRY_OBJECTS,org/apache/poi/util/TestBinaryTree.java,testEntrySet,2415-2415,[        Set hs = new HashSet(s);],,
STYLE,IM_BAD_CHECK_FOR_ODD,org/apache/poi/util/TestBinaryTree.java,testKeySet,485-485,[            if (k % 2 == 1)],,
STYLE,IM_BAD_CHECK_FOR_ODD,org/apache/poi/util/TestBinaryTree.java,testKeySetByValue,1170-1170,[            if (k % 2 == 1)],,
STYLE,IM_BAD_CHECK_FOR_ODD,org/apache/poi/util/TestBinaryTree.java,testValues,621-621,[            if (k % 2 == 1)],,
STYLE,IM_BAD_CHECK_FOR_ODD,org/apache/poi/util/TestBinaryTree.java,testValuesByValue,1306-1306,[            if (k % 2 == 1)],,
STYLE,RV_RETURN_VALUE_IGNORED_NO_SIDE_EFFECT,org/apache/poi/util/TestBinaryTree.java,testContainsKey,101-101,[            m.containsKey(new Object());],,testContainsKey,109-109,[            m.containsKey(null);],,testContainsKey,126-126,[            m.containsKey("foo");],,
STYLE,RV_RETURN_VALUE_IGNORED_NO_SIDE_EFFECT,org/apache/poi/util/TestBinaryTree.java,testGet,160-160,[            m.get(new Object());],,testGet,168-168,[            m.get(null);],,testGet,185-185,[            m.get("foo");],,
STYLE,RV_RETURN_VALUE_IGNORED_NO_SIDE_EFFECT,org/apache/poi/util/TestBinaryTree.java,testKeySet,1377-1377,[            s.contains(null);],,testKeySet,1385-1385,[            s.contains(new Object());],,
STYLE,RV_RETURN_VALUE_IGNORED_NO_SIDE_EFFECT,org/apache/poi/util/TestBinaryTree.java,testKeySetByValue,1603-1603,[            s.contains(null);],,testKeySetByValue,1611-1611,[            s.contains(new Object());],,
STYLE,UC_USELESS_OBJECT,org/apache/poi/util/TestBinaryTree.java,testConstructors,842-842,[            m = new BinaryTree(m2);],,
STYLE,UC_USELESS_OBJECT,org/apache/poi/util/TestBinaryTree.java,testConstructors,853-853,[            m = new BinaryTree(m2);],,
STYLE,UC_USELESS_OBJECT,org/apache/poi/util/TestBinaryTree.java,testConstructors,864-864,[            m = new BinaryTree(m2);],,
STYLE,UC_USELESS_OBJECT,org/apache/poi/util/TestBinaryTree.java,testConstructors,875-875,[            m = new BinaryTree(m2);],,
STYLE,UC_USELESS_OBJECT,org/apache/poi/util/TestBinaryTree.java,testConstructors,887-887,[            m = new BinaryTree(m2);],,
STYLE,UC_USELESS_OBJECT,org/apache/poi/util/TestBinaryTree.java,testConstructors,900-900,[            m = new BinaryTree(m2);],,
STYLE,UC_USELESS_OBJECT,org/apache/poi/util/TestBinaryTree.java,testConstructors,837-837,[        m2 = new HashMap();],,
STYLE,RV_RETURN_VALUE_IGNORED_NO_SIDE_EFFECT,org/apache/poi/util/TestByteField.java,testConstructors,41-41,[            new ByteField(-1);],,
STYLE,RV_RETURN_VALUE_IGNORED_NO_SIDE_EFFECT,org/apache/poi/util/TestByteField.java,testConstructors,54-54,[            new ByteField(-1, ( byte ) 1);],,
STYLE,UC_USELESS_OBJECT,org/apache/poi/util/TestByteField.java,testReadFromBytes,114-114,[        ByteField field = new ByteField(1);],,
I18N,DM_DEFAULT_ENCODING,org/apache/poi/util/TestHexDump.java,testDump,256-256,[        assertEquals( "No Data" + System.getProperty( "line.separator"), os.toString() );],,
I18N,DM_DEFAULT_ENCODING,org/apache/poi/util/TestHexDump.java,testDump,71-71,[            System.arraycopy(HexDump.EOL.getBytes(), 0, outputArray, offset,],,testDump,72-72,[                             HexDump.EOL.getBytes().length);],,testDump,111-111,[            System.arraycopy(HexDump.EOL.getBytes(), 0, outputArray, offset,],,testDump,112-112,[                             HexDump.EOL.getBytes().length);],,testDump,150-150,[            System.arraycopy(HexDump.EOL.getBytes(), 0, outputArray, offset,],,testDump,151-151,[                             HexDump.EOL.getBytes().length);],,testDump,204-204,[            System.arraycopy(HexDump.EOL.getBytes(), 0, outputArray, offset,],,testDump,205-205,[                             HexDump.EOL.getBytes().length);],,
CORRECTNESS,RC_REF_COMPARISON,org/apache/poi/util/TestIdentifierManager.java,testReserveNew,94-94,[        assertSame(10L,manager.reserveNew());],,testReserveNew,95-95,[        assertSame(11L,manager.reserveNew());],,testReserveNew,96-96,[        assertSame(12L,manager.reserveNew());],,
STYLE,RV_RETURN_VALUE_IGNORED_NO_SIDE_EFFECT,org/apache/poi/util/TestIntegerField.java,testConstructors,40-40,[            new IntegerField(-1);],,
STYLE,RV_RETURN_VALUE_IGNORED_NO_SIDE_EFFECT,org/apache/poi/util/TestIntegerField.java,testConstructors,53-53,[            new IntegerField(-1, 1);],,
STYLE,UC_USELESS_OBJECT,org/apache/poi/util/TestIntegerField.java,testReadFromBytes,126-126,[        IntegerField field = new IntegerField(1);],,
STYLE,RV_RETURN_VALUE_IGNORED_NO_SIDE_EFFECT,org/apache/poi/util/TestLongField.java,testConstructors,40-40,[            new LongField(-1);],,
STYLE,RV_RETURN_VALUE_IGNORED_NO_SIDE_EFFECT,org/apache/poi/util/TestLongField.java,testConstructors,53-53,[            new LongField(-1, 1L);],,
STYLE,UC_USELESS_OBJECT,org/apache/poi/util/TestLongField.java,testReadFromBytes,144-144,[        LongField field = new LongField(1);],,
STYLE,RV_RETURN_VALUE_IGNORED_NO_SIDE_EFFECT,org/apache/poi/util/TestShortField.java,testConstructors,40-40,[            new ShortField(-1);],,
STYLE,RV_RETURN_VALUE_IGNORED_NO_SIDE_EFFECT,org/apache/poi/util/TestShortField.java,testConstructors,53-53,[            new ShortField(-1, ( short ) 1);],,
STYLE,UC_USELESS_OBJECT,org/apache/poi/util/TestShortField.java,testReadFromBytes,118-118,[        ShortField field = new ShortField(1);],,
PERFORMANCE,DM_FP_NUMBER_CTOR,org/apache/poi/util/TestStringUtil.java,testFormat,135-135,[        confirm("This is a test " + fmt(1.2345, 2, 2), "This is a test %2.2", new Double(1.2345));],,testFormat,136-136,[        confirm("This is a test " + fmt(1.2345, -1, 3), "This is a test %.3", new Double(1.2345));],,testFormat,137-137,[        confirm("This is a great test " + fmt(1.2345, -1, 3),],,
I18N,DM_DEFAULT_ENCODING,org/apache/poi/util/TestTempFile.java,testCreateTempFile,34-34,[        FileWriter w = new FileWriter(tempFile);],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/poi/util/TestTempFile.java,testCreateTempFile,34-34,[        FileWriter w = new FileWriter(tempFile);],,testCreateTempFile,35-35,[        w.write("testing");],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/poi/xslf/TestXSLFSlideShow.java,testContainsMainContentType,37-37,[		for(PackagePart part : pack.getParts()) {],,
STYLE,REC_CATCH_EXCEPTION,org/apache/poi/xslf/XSLFTestDataSamples.java,writeOutAndReadBack,47-47,[        } catch (Exception e) {],,
MALICIOUS_CODE,MS_MUTABLE_ARRAY,org/apache/poi/xslf/extractor/XSLFPowerPointExtractor.java,,42-42,[   public static final XSLFRelation[] SUPPORTED_TYPES = new XSLFRelation[] {],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/poi/xslf/extractor/XSLFPowerPointExtractor.java,getText,142-142,[                  if(layout != null) {],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/poi/xslf/extractor/XSLFPowerPointExtractor.java,getText,145-145,[                  if(master != null) {],,
PERFORMANCE,WMI_WRONG_MAP_ITERATOR,org/apache/poi/xslf/geom/TestPresetGeometries.java,testRead,46-46,[            CustomGeometry geom = shapes.get(name);],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/poi/xslf/geom/TestPresetGeometries.java,,47-49,[            Context ctx = new Context(geom, new Rectangle2D.Double(0, 0, 100, 100), new IAdjustableShape() {,                 public Guide getAdjustValue(String name) {,                     return null;],,
PERFORMANCE,WMI_WRONG_MAP_ITERATOR,org/apache/poi/xslf/model/geom/ExpressionParser.java,parse,59-59,[                Class c = impls.get(regexp);],,
MT_CORRECTNESS,LI_LAZY_INIT_STATIC,org/apache/poi/xslf/model/geom/PresetGeometries.java,getInstance,62-62,[        if(_inst == null) _inst = new PresetGeometries();],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION,org/apache/poi/xslf/model/geom/PresetGeometries.java,<init>,40-40,[                    XMLSlideShow.class.getResourceAsStream("presetShapeDefinitions.xml");],,<init>,41-41,[            read(is);],,<init>,44-44,[        }],,<init>,45-45,[    }],,
BAD_PRACTICE,SE_NO_SERIALVERSIONID,org/apache/poi/xslf/model/geom/PresetGeometries.java,,37-64,[    private PresetGeometries(){,         try {,             InputStream is =,                     XMLSlideShow.class.getResourceAsStream("presetShapeDefinitions.xml");,             read(is);,         } catch (Exception e){,             throw new RuntimeException(e);,         },     }, ,     private void read(InputStream is) throws Exception {,         XmlObject obj = XmlObject.Factory.parse(is);,         for (XmlObject def : obj.selectPath("*/*")) {, ,             String name = def.getDomNode().getLocalName();,             CTCustomGeometry2D geom = CTCustomGeometry2D.Factory.parse(def.toString());, ,             if(containsKey(name)) {,                 System.out.println("Duplicate definoition of " + name) ;,             },             put(name, new CustomGeometry(geom));,         },     }, ,     public static PresetGeometries getInstance(){,         if(_inst == null) _inst = new PresetGeometries();, ,         return _inst;],,
STYLE,ICAST_IDIV_CAST_TO_DOUBLE,org/apache/poi/xslf/usermodel/RenderableShape.java,createLinearGradientPaint,174-174,[        double angle = gradFill.getLin().getAng() / 60000;],,
STYLE,REC_CATCH_EXCEPTION,org/apache/poi/xslf/usermodel/RenderableShape.java,createTexturePaint,163-163,[            catch (Exception e) {],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/poi/xslf/usermodel/RenderableShape.java,getDashPattern,445-467,[        switch (lineDash) {,             case SYS_DOT:,                 dash = new float[]{lineWidth, lineWidth};,                 break;,             case SYS_DASH:,                 dash = new float[]{2 * lineWidth, 2 * lineWidth};,                 break;,             case DASH:,                 dash = new float[]{3 * lineWidth, 4 * lineWidth};,                 break;,             case DASH_DOT:,                 dash = new float[]{4 * lineWidth, 3 * lineWidth, lineWidth,,                         3 * lineWidth};,                 break;,             case LG_DASH:,                 dash = new float[]{8 * lineWidth, 3 * lineWidth};,                 break;,             case LG_DASH_DOT:,                 dash = new float[]{8 * lineWidth, 3 * lineWidth, lineWidth,,                         3 * lineWidth};,                 break;,             case LG_DASH_DOT_DOT:,                 dash = new float[]{8 * lineWidth, 3 * lineWidth, lineWidth,],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/poi/xslf/usermodel/RenderableShape.java,,177-181,[        Arrays.sort(gs, new Comparator<CTGradientStop>() {,             public int compare(CTGradientStop o1, CTGradientStop o2) {,                 Integer pos1 = o1.getPos();,                 Integer pos2 = o2.getPos();,                 return pos1.compareTo(pos2);],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/poi/xslf/usermodel/TestXMLSlideShow.java,testContainsMainContentType,37-37,[      for(PackagePart part : pack.getParts()) {],,
PERFORMANCE,WMI_WRONG_MAP_ITERATOR,org/apache/poi/xslf/usermodel/TestXSLFColor.java,testPresetColor,149-149,[            assertEquals(XSLFColor.presetColors.get(colorName), color.getColor());],,
STYLE,BC_VACUOUS_INSTANCEOF,org/apache/poi/xslf/usermodel/TestXSLFTable.java,testCreate,78-78,[        assertTrue(tbl.getXmlObject() instanceof CTGraphicalObjectFrame);],,
STYLE,RV_CHECK_FOR_POSITIVE_INDEXOF,org/apache/poi/xslf/usermodel/TestXSLFTheme.java,slide10,144-144,[        assertTrue(slide.getBackground().getPaint(null).getClass().getName().indexOf("Gradient") > 0);],,
STYLE,RV_CHECK_FOR_POSITIVE_INDEXOF,org/apache/poi/xslf/usermodel/TestXSLFTheme.java,slide3,77-77,[        assertTrue(slide.getBackground().getPaint(null).getClass().getName().indexOf("Gradient") > 0);],,
STYLE,RV_CHECK_FOR_POSITIVE_INDEXOF,org/apache/poi/xslf/usermodel/TestXSLFTheme.java,slide4,82-82,[        assertTrue(slide.getBackground().getPaint(null).getClass().getName().indexOf("Gradient") > 0);],,
STYLE,REC_CATCH_EXCEPTION,org/apache/poi/xslf/usermodel/XMLSlideShow.java,<init>,88-88,[        } catch (Exception e){],,
STYLE,REC_CATCH_EXCEPTION,org/apache/poi/xslf/usermodel/XSLFFactory.java,createDocumentPart,65-65,[        } catch (Exception e){],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/poi/xslf/usermodel/XSLFFreeformShape.java,setPath,75-103,[            switch (type) {,                 case PathIterator.SEG_MOVETO:,                     CTAdjPoint2D mv = ctPath.addNewMoveTo().addNewPt();,                     mv.setX(Units.toEMU(vals[0]) - x0);,                     mv.setY(Units.toEMU(vals[1]) - y0);,                     numPoints++;,                     break;,                 case PathIterator.SEG_LINETO:,                     CTAdjPoint2D ln = ctPath.addNewLnTo().addNewPt();,                     ln.setX(Units.toEMU(vals[0]) - x0);,                     ln.setY(Units.toEMU(vals[1]) - y0);,                     numPoints++;,                     break;,                 case PathIterator.SEG_CUBICTO:,                     CTPath2DCubicBezierTo bez = ctPath.addNewCubicBezTo();,                     CTAdjPoint2D p1 = bez.addNewPt();,                     p1.setX(Units.toEMU(vals[0]) - x0);,                     p1.setY(Units.toEMU(vals[1]) - y0);,                     CTAdjPoint2D p2 = bez.addNewPt();,                     p2.setX(Units.toEMU(vals[2]) - x0);,                     p2.setY(Units.toEMU(vals[3]) - y0);,                     CTAdjPoint2D p3 = bez.addNewPt();,                     p3.setX(Units.toEMU(vals[4]) - x0);,                     p3.setY(Units.toEMU(vals[5]) - y0);,                     numPoints += 3;,                     break;,                 case PathIterator.SEG_CLOSE:,                     numPoints++;,                     ctPath.addNewClose();],,
STYLE,REC_CATCH_EXCEPTION,org/apache/poi/xslf/usermodel/XSLFImageRenderer.java,drawImage,91-91,[		} catch (Exception e) {],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/poi/xslf/usermodel/XSLFPictureData.java,,80-80,[        RELATIONS = new POIXMLRelation[9];],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/poi/xslf/usermodel/XSLFPictureData.java,getFileName,138-138,[        if (name == null)],,
STYLE,REC_CATCH_EXCEPTION,org/apache/poi/xslf/usermodel/XSLFPictureShape.java,resize,92-92,[        catch (Exception e) {],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/poi/xslf/usermodel/XSLFRelation.java,,36-36,[   protected static Map<String, XSLFRelation> _table = new HashMap<String, XSLFRelation>();],,
STYLE,FE_FLOATING_POINT_EQUALITY,org/apache/poi/xslf/usermodel/XSLFSimpleShape.java,copy,677-677,[        if(srcLineWidth != tgtLineWidth) {],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/poi/xslf/usermodel/XSLFSimpleShape.java,,158-165,[        PropertyFetcher<CTTransform2D> fetcher = new PropertyFetcher<CTTransform2D>() {,             public boolean fetch(XSLFSimpleShape shape) {,                 CTShapeProperties pr = shape.getSpPr();,                 if (pr.isSetXfrm()) {,                     setValue(pr.getXfrm());,                     return true;,                 },                 return false;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/poi/xslf/usermodel/XSLFSimpleShape.java,,323-338,[        PropertyFetcher<Double> fetcher = new PropertyFetcher<Double>() {,             public boolean fetch(XSLFSimpleShape shape) {,                 CTShapeProperties spPr = shape.getSpPr();,                 CTLineProperties ln = spPr.getLn();,                 if (ln != null) {,                     if (ln.isSetNoFill()) {,                         setValue(0.);,                         return true;,                     }, ,                     if (ln.isSetW()) {,                         setValue(Units.toPoints(ln.getW()));,                         return true;,                     },                 },                 return false;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/poi/xslf/usermodel/XSLFSimpleShape.java,,380-391,[        PropertyFetcher<LineDash> fetcher = new PropertyFetcher<LineDash>() {,             public boolean fetch(XSLFSimpleShape shape) {,                 CTShapeProperties spPr = shape.getSpPr();,                 CTLineProperties ln = spPr.getLn();,                 if (ln != null) {,                     CTPresetLineDashProperties ctDash = ln.getPrstDash();,                     if (ctDash != null) {,                         setValue(LineDash.values()[ctDash.getVal().intValue() - 1]);,                         return true;,                     },                 },                 return false;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/poi/xslf/usermodel/XSLFSimpleShape.java,,430-441,[        PropertyFetcher<LineCap> fetcher = new PropertyFetcher<LineCap>() {,             public boolean fetch(XSLFSimpleShape shape) {,                 CTShapeProperties spPr = shape.getSpPr();,                 CTLineProperties ln = spPr.getLn();,                 if (ln != null) {,                     STLineCap.Enum stCap = ln.getCap();,                     if (stCap != null) {,                         setValue(LineCap.values()[stCap.intValue() - 1]);,                         return true;,                     },                 },                 return false;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/poi/xslf/usermodel/XSLFSimpleShape.java,,508-516,[        PropertyFetcher<CTOuterShadowEffect> fetcher = new PropertyFetcher<CTOuterShadowEffect>() {,             public boolean fetch(XSLFSimpleShape shape) {,                 CTShapeProperties spPr = shape.getSpPr();,                 if (spPr.isSetEffectLst()) {,                     CTOuterShadowEffect obj = spPr.getEffectLst().getOuterShdw();,                     setValue(obj == null ? NO_SHADOW : obj);,                     return true;,                 },                 return false;],,
I18N,DM_CONVERT_CASE,org/apache/poi/xslf/usermodel/XSLFSlideMaster.java,getLayouts,95-95,[                    _layouts.put(layout.getName().toLowerCase(), layout);],,
BAD_PRACTICE,NM_CONFUSING,org/apache/poi/xslf/usermodel/XSLFTableStyle.java,getStyleId,45-45,[        return _tblStyle.getStyleId();],,getStyleID,195-201,[           if (paragraph.getPPr() != null){,                if(paragraph.getPPr().getPStyle()!= null){,                    if (paragraph.getPPr().getPStyle().getVal()!= null),                        return paragraph.getPPr().getPStyle().getVal();,                },            },            return null;],,
STYLE,FE_FLOATING_POINT_EQUALITY,org/apache/poi/xslf/usermodel/XSLFTextParagraph.java,copy,992-992,[                if(buSize != getBulletFontSize()){],,copy,999-999,[        if(leftMargin != getLeftMargin()){],,copy,1004-1004,[        if(indent != getIndent()){],,copy,1009-1009,[        if(spaceAfter != getSpaceAfter()){],,copy,1013-1013,[        if(spaceBefore != getSpaceBefore()){],,copy,1017-1017,[        if(lineSpacing != getLineSpacing()){],,
STYLE,ICAST_IDIV_CAST_TO_DOUBLE,org/apache/poi/xslf/usermodel/XSLFTextParagraph.java,ensureNotEmpty,801-801,[            if(endPr.isSetSz()) r.setFontSize(endPr.getSz() / 100);],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/poi/xslf/usermodel/XSLFTextParagraph.java,,137-144,[        ParagraphPropertyFetcher<TextAlign> fetcher = new ParagraphPropertyFetcher<TextAlign>(getLevel()){,             public boolean fetch(CTTextParagraphProperties props){,                 if(props.isSetAlgn()){,                     TextAlign val = TextAlign.values()[props.getAlgn().intValue() - 1];,                     setValue(val);,                     return true;,                 },                 return false;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/poi/xslf/usermodel/XSLFTextParagraph.java,,406-415,[        ParagraphPropertyFetcher<Double> fetcher = new ParagraphPropertyFetcher<Double>(getLevel()){,             public boolean fetch(CTTextParagraphProperties props){,                 if(props.isSetLnSpc()){,                     CTTextSpacing spc = props.getLnSpc();, ,                     if(spc.isSetSpcPct()) setValue( spc.getSpcPct().getVal()*0.001 );,                     else if (spc.isSetSpcPts()) setValue( -spc.getSpcPts().getVal()*0.01 );,                     return true;,                 },                 return false;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/poi/xslf/usermodel/XSLFTextParagraph.java,,471-480,[        ParagraphPropertyFetcher<Double> fetcher = new ParagraphPropertyFetcher<Double>(getLevel()){,             public boolean fetch(CTTextParagraphProperties props){,                 if(props.isSetSpcBef()){,                     CTTextSpacing spc = props.getSpcBef();, ,                     if(spc.isSetSpcPct()) setValue( spc.getSpcPct().getVal()*0.001 );,                     else if (spc.isSetSpcPts()) setValue( -spc.getSpcPts().getVal()*0.01 );,                     return true;,                 },                 return false;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/poi/xslf/usermodel/XSLFTextParagraph.java,,527-536,[        ParagraphPropertyFetcher<Double> fetcher = new ParagraphPropertyFetcher<Double>(getLevel()){,             public boolean fetch(CTTextParagraphProperties props){,                 if(props.isSetSpcAft()){,                     CTTextSpacing spc = props.getSpcAft();, ,                     if(spc.isSetSpcPct()) setValue( spc.getSpcPct().getVal()*0.001 );,                     else if (spc.isSetSpcPts()) setValue( -spc.getSpcPts().getVal()*0.01 );,                     return true;,                 },                 return false;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/poi/xslf/usermodel/XSLFTextParagraph.java,,572-582,[        ParagraphPropertyFetcher<Boolean> fetcher = new ParagraphPropertyFetcher<Boolean>(getLevel()){,             public boolean fetch(CTTextParagraphProperties props){,                 if(props.isSetBuNone()) {,                     setValue(false);,                     return true;,                 },                 if(props.isSetBuFont() || props.isSetBuChar()){,                     setValue(true);,                     return true;,                 },                 return false;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/poi/xslf/usermodel/XSLFTextParagraph.java,,172-178,[        ParagraphPropertyFetcher<String> fetcher = new ParagraphPropertyFetcher<String>(getLevel()){,             public boolean fetch(CTTextParagraphProperties props){,                 if(props.isSetBuFont()){,                     setValue(props.getBuFont().getTypeface());,                     return true;,                 },                 return false;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/poi/xslf/usermodel/XSLFTextParagraph.java,,195-201,[        ParagraphPropertyFetcher<String> fetcher = new ParagraphPropertyFetcher<String>(getLevel()){,             public boolean fetch(CTTextParagraphProperties props){,                 if(props.isSetBuChar()){,                     setValue(props.getBuChar().getChar());,                     return true;,                 },                 return false;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/poi/xslf/usermodel/XSLFTextParagraph.java,,216-223,[        ParagraphPropertyFetcher<Color> fetcher = new ParagraphPropertyFetcher<Color>(getLevel()){,             public boolean fetch(CTTextParagraphProperties props){,                 if(props.isSetBuClr()){,                     XSLFColor c = new XSLFColor(props.getBuClr(), theme, null);,                     setValue(c.getColor());,                     return true;,                 },                 return false;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/poi/xslf/usermodel/XSLFTextParagraph.java,,238-248,[        ParagraphPropertyFetcher<Double> fetcher = new ParagraphPropertyFetcher<Double>(getLevel()){,             public boolean fetch(CTTextParagraphProperties props){,                 if(props.isSetBuSzPct()){,                     setValue(props.getBuSzPct().getVal() * 0.001);,                     return true;,                 },                 if(props.isSetBuSzPts()){,                     setValue( - props.getBuSzPts().getVal() * 0.01);,                     return true;,                 },                 return false;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/poi/xslf/usermodel/XSLFTextParagraph.java,,282-288,[        ParagraphPropertyFetcher<Double> fetcher = new ParagraphPropertyFetcher<Double>(getLevel()){,             public boolean fetch(CTTextParagraphProperties props){,                 if(props.isSetIndent()){,                     setValue(Units.toPoints(props.getIndent()));,                     return true;,                 },                 return false;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/poi/xslf/usermodel/XSLFTextParagraph.java,,313-320,[        ParagraphPropertyFetcher<Double> fetcher = new ParagraphPropertyFetcher<Double>(getLevel()){,             public boolean fetch(CTTextParagraphProperties props){,                 if(props.isSetMarL()){,                     double val = Units.toPoints(props.getMarL());,                     setValue(val);,                     return true;,                 },                 return false;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/poi/xslf/usermodel/XSLFTextParagraph.java,,333-340,[        ParagraphPropertyFetcher<Double> fetcher = new ParagraphPropertyFetcher<Double>(getLevel()){,             public boolean fetch(CTTextParagraphProperties props){,                 if(props.isSetDefTabSz()){,                     double val = Units.toPoints(props.getDefTabSz());,                     setValue(val);,                     return true;,                 },                 return false;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/poi/xslf/usermodel/XSLFTextParagraph.java,,348-359,[        ParagraphPropertyFetcher<Double> fetcher = new ParagraphPropertyFetcher<Double>(getLevel()){,             public boolean fetch(CTTextParagraphProperties props){,                 if(props.isSetTabLst()){,                     CTTextTabStopList tabStops = props.getTabLst();,                     if(idx < tabStops.sizeOfTabArray() ) {,                         CTTextTabStop ts = tabStops.getTabArray(idx);,                         double val = Units.toPoints(ts.getPos());,                         setValue(val);,                         return true;,                     },                 },                 return false;],,
STYLE,FE_FLOATING_POINT_EQUALITY,org/apache/poi/xslf/usermodel/XSLFTextRun.java,copy,507-507,[        if(srcFontSize  != getFontSize()){],,
BAD_PRACTICE,NM_CONFUSING,org/apache/poi/xslf/usermodel/XSLFTextRun.java,getRpR,443-443,[        return _r.isSetRPr() ? _r.getRPr() : _r.addNewRPr();],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/poi/xslf/usermodel/XSLFTextRun.java,tab2space,97-112,[        AttributedString string = new AttributedString(" ");,         // user can pass an object to convert fonts via a rendering hint,         string.addAttribute(TextAttribute.FAMILY, getFontFamily());, ,         string.addAttribute(TextAttribute.SIZE, (float)getFontSize());,         TextLayout l = new TextLayout(string.getIterator(), new FontRenderContext(null, true, true));,         double wspace = l.getAdvance();, ,         double tabSz = _p.getDefaultTabSize();, ,         int numSpaces = (int)Math.ceil(tabSz / wspace);,         StringBuffer buf = new StringBuffer();,         for(int i = 0; i < numSpaces; i++) {,             buf.append(' ');,         },         return buf.toString();],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/poi/xslf/usermodel/XSLFTextRun.java,,142-153,[        CharacterPropertyFetcher<Color> fetcher = new CharacterPropertyFetcher<Color>(_p.getLevel()){,             public boolean fetch(CTTextCharacterProperties props){,                 CTSolidColorFillProperties solidFill = props.getSolidFill();,                 if(solidFill != null) {,                     boolean useCtxColor =,                             (solidFill.isSetSchemeClr() && solidFill.getSchemeClr().getVal() == STSchemeColorVal.PH_CLR),                             || isFetchingFromMaster;,                     Color c = new XSLFColor(solidFill, theme, useCtxColor ? phClr : null).getColor();,                     setValue(c);,                     return true;,                 },                 return false;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/poi/xslf/usermodel/XSLFTextRun.java,,381-387,[        CharacterPropertyFetcher<Boolean> fetcher = new CharacterPropertyFetcher<Boolean>(_p.getLevel()){,             public boolean fetch(CTTextCharacterProperties props){,                 if(props.isSetB()){,                     setValue(props.getB());,                     return true;,                 },                 return false;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/poi/xslf/usermodel/XSLFTextRun.java,,405-411,[        CharacterPropertyFetcher<Boolean> fetcher = new CharacterPropertyFetcher<Boolean>(_p.getLevel()){,             public boolean fetch(CTTextCharacterProperties props){,                 if(props.isSetI()){,                     setValue(props.getI());,                     return true;,                 },                 return false;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/poi/xslf/usermodel/XSLFTextRun.java,,429-435,[        CharacterPropertyFetcher<Boolean> fetcher = new CharacterPropertyFetcher<Boolean>(_p.getLevel()){,             public boolean fetch(CTTextCharacterProperties props){,                 if(props.isSetU()){,                     setValue(props.getU() != STTextUnderlineType.NONE);,                     return true;,                 },                 return false;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/poi/xslf/usermodel/XSLFTextRun.java,,182-188,[        CharacterPropertyFetcher<Double> fetcher = new CharacterPropertyFetcher<Double>(_p.getLevel()){,             public boolean fetch(CTTextCharacterProperties props){,                 if(props.isSetSz()){,                     setValue(props.getSz()*0.01);,                     return true;,                 },                 return false;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/poi/xslf/usermodel/XSLFTextRun.java,,202-208,[        CharacterPropertyFetcher<Double> fetcher = new CharacterPropertyFetcher<Double>(_p.getLevel()){,             public boolean fetch(CTTextCharacterProperties props){,                 if(props.isSetSpc()){,                     setValue(props.getSpc()*0.01);,                     return true;,                 },                 return false;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/poi/xslf/usermodel/XSLFTextRun.java,,251-264,[        CharacterPropertyFetcher<String> visitor = new CharacterPropertyFetcher<String>(_p.getLevel()){,             public boolean fetch(CTTextCharacterProperties props){,                 CTTextFont font = props.getLatin();,                 if(font != null){,                     String typeface = font.getTypeface();,                     if("+mj-lt".equals(typeface)) {,                         typeface = theme.getMajorFont();,                     } else if ("+mn-lt".equals(typeface)){,                         typeface = theme.getMinorFont();,                     },                     setValue(typeface);,                     return true;,                 },                 return false;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/poi/xslf/usermodel/XSLFTextRun.java,,275-282,[        CharacterPropertyFetcher<Byte> visitor = new CharacterPropertyFetcher<Byte>(_p.getLevel()){,             public boolean fetch(CTTextCharacterProperties props){,                 CTTextFont font = props.getLatin();,                 if(font != null){,                     setValue(font.getPitchFamily());,                     return true;,                 },                 return false;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/poi/xslf/usermodel/XSLFTextRun.java,,303-309,[        CharacterPropertyFetcher<Boolean> fetcher = new CharacterPropertyFetcher<Boolean>(_p.getLevel()){,             public boolean fetch(CTTextCharacterProperties props){,                 if(props.isSetStrike()){,                     setValue(props.getStrike() != STTextStrikeType.NO_STRIKE);,                     return true;,                 },                 return false;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/poi/xslf/usermodel/XSLFTextRun.java,,320-326,[        CharacterPropertyFetcher<Boolean> fetcher = new CharacterPropertyFetcher<Boolean>(_p.getLevel()){,             public boolean fetch(CTTextCharacterProperties props){,                 if(props.isSetBaseline()){,                     setValue(props.getBaseline() > 0);,                     return true;,                 },                 return false;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/poi/xslf/usermodel/XSLFTextRun.java,,337-343,[        CharacterPropertyFetcher<Boolean> fetcher = new CharacterPropertyFetcher<Boolean>(_p.getLevel()){,             public boolean fetch(CTTextCharacterProperties props){,                 if(props.isSetBaseline()){,                     setValue(props.getBaseline() < 0);,                     return true;,                 },                 return false;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/poi/xslf/usermodel/XSLFTextRun.java,,354-361,[        CharacterPropertyFetcher<TextCap> fetcher = new CharacterPropertyFetcher<TextCap>(_p.getLevel()){,             public boolean fetch(CTTextCharacterProperties props){,                 if(props.isSetCap()){,                     int idx = props.getCap().intValue() - 1;,                     setValue(TextCap.values()[idx]);,                     return true;,                 },                 return false;],,
STYLE,FE_FLOATING_POINT_EQUALITY,org/apache/poi/xslf/usermodel/XSLFTextShape.java,copy,571-571,[        if(leftInset != getLeftInset()) {],,copy,575-575,[        if(rightInset != getRightInset()) {],,copy,579-579,[        if(topInset != getTopInset()) {],,copy,583-583,[        if(bottomInset != getBottomInset()) {],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/poi/xslf/usermodel/XSLFTextShape.java,,149-156,[        PropertyFetcher<VerticalAlignment> fetcher = new TextBodyPropertyFetcher<VerticalAlignment>(){,             public boolean fetch(CTTextBodyProperties props){,                 if(props.isSetAnchor()){,                     int val = props.getAnchor().intValue();,                     setValue(VerticalAlignment.values()[val - 1]);,                     return true;,                 },                 return false;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/poi/xslf/usermodel/XSLFTextShape.java,,200-207,[        PropertyFetcher<Double> fetcher = new TextBodyPropertyFetcher<Double>(){,             public boolean fetch(CTTextBodyProperties props){,                 if(props.isSetBIns()){,                     double val = Units.toPoints(props.getBIns());,                     setValue(val);,                     return true;,                 },                 return false;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/poi/xslf/usermodel/XSLFTextShape.java,,223-230,[        PropertyFetcher<Double> fetcher = new TextBodyPropertyFetcher<Double>(){,             public boolean fetch(CTTextBodyProperties props){,                 if(props.isSetLIns()){,                     double val = Units.toPoints(props.getLIns());,                     setValue(val);,                     return true;,                 },                 return false;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/poi/xslf/usermodel/XSLFTextShape.java,,246-253,[        PropertyFetcher<Double> fetcher = new TextBodyPropertyFetcher<Double>(){,             public boolean fetch(CTTextBodyProperties props){,                 if(props.isSetRIns()){,                     double val = Units.toPoints(props.getRIns());,                     setValue(val);,                     return true;,                 },                 return false;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/poi/xslf/usermodel/XSLFTextShape.java,,268-275,[        PropertyFetcher<Double> fetcher = new TextBodyPropertyFetcher<Double>(){,             public boolean fetch(CTTextBodyProperties props){,                 if(props.isSetTIns()){,                     double val = Units.toPoints(props.getTIns());,                     setValue(val);,                     return true;,                 },                 return false;],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,org/apache/poi/xslf/usermodel/XSLFTextShape.java,,344-350,[        PropertyFetcher<Boolean> fetcher = new TextBodyPropertyFetcher<Boolean>(){,             public boolean fetch(CTTextBodyProperties props){,                if(props.isSetWrap()){,                     setValue(props.getWrap() == STTextWrappingType.SQUARE);,                     return true;,                 },                 return false;],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/poi/xslf/util/PPTX2PNG.java,main,87-87,[            System.out.println("Rendering slide " + (i + 1) + (title == null ? "" : ": " + title));],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/poi/xssf/TestWorkbookProtection.java,testIntegration,100-100,[		FileOutputStream out = new FileOutputStream(tempFile);],,testIntegration,101-101,[		wb.write(out);],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/poi/xssf/dev/XSSFDump.java,dump,60-60,[            FileOutputStream out = new FileOutputStream(f);],,dump,62-62,[            if(entry.getName().endsWith(".xml") || entry.getName().endsWith(".vml") || entry.getName().endsWith(".rels")){],,dump,73-73,[                dump(zip.getInputStream(entry), out);],,
STYLE,REC_CATCH_EXCEPTION,org/apache/poi/xssf/dev/XSSFDump.java,dump,68-68,[                } catch (Exception e){],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/poi/xssf/dev/XSSFDump.java,dump,47-47,[        root.mkdir();],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/poi/xssf/dev/XSSFDump.java,dump,56-56,[                bs.mkdirs();],,
BAD_PRACTICE,NM_CLASS_NAMING_CONVENTION,org/apache/poi/xssf/eventusermodel/XLSX2CSV.java,,73-79,[    enum xssfDataType {,         BOOL,,         ERROR,,         FORMULA,,         INLINESTR,,         SSTINDEX,,         NUMBER,],,
BAD_PRACTICE,NM_CLASS_NAMING_CONVENTION,org/apache/poi/xssf/eventusermodel/XSSFSheetXMLHandler.java,,39-45,[   enum xssfDataType {,        BOOLEAN,,        ERROR,,        FORMULA,,        INLINE_STRING,,        SST_STRING,,        NUMBER,],,
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,org/apache/poi/xssf/extractor/XSSFEventBasedExcelExtractor.java,,196-221,[      private boolean firstCellOfRow = true;,       ,       protected SheetTextExtractor(StringBuffer output) {,          this.output = output;,       },       ,       public void startRow(int rowNum) {,          firstCellOfRow = true;,       },       ,       public void endRow() {,          output.append('\n');,       }, ,       public void cell(String cellRef, String formattedValue) {,          if(firstCellOfRow) {,             firstCellOfRow = false;,          } else {,             output.append('\t');,          },          output.append(formattedValue);,       },       ,       public void headerFooter(String text, boolean isHeader, String tagName) {,          // We don't include headers in the output yet, so ignore,       }],,
MALICIOUS_CODE,MS_MUTABLE_ARRAY,org/apache/poi/xssf/extractor/XSSFExcelExtractor.java,,43-43,[   public static final XSSFRelation[] SUPPORTED_TYPES = new XSSFRelation[] {],,
STYLE,DB_DUPLICATE_SWITCH_CLAUSES,org/apache/poi/xssf/extractor/XSSFExportToXml.java,mapCellOnNode,280-280,[        case XSSFCell.CELL_TYPE_STRING: value = cell.getStringCellValue(); break;],,mapCellOnNode,283-283,[        case XSSFCell.CELL_TYPE_FORMULA: value = cell.getStringCellValue(); break;],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/poi/xssf/extractor/XSSFExportToXml.java,exportToXML,169-169,[                    if (cell!=null) {],,
BAD_PRACTICE,SE_COMPARATOR_SHOULD_BE_SERIALIZABLE,org/apache/poi/xssf/extractor/XSSFExportToXml.java,,77-505,[public class XSSFExportToXml implements Comparator<String>{, ,     private XSSFMap map;, ,     /**,      * Creates a new exporter and sets the mapping to be used when generating the XML output document,      *,      * @param map the mapping rule to be used,      */,     public XSSFExportToXml(XSSFMap map) {,         this.map = map;,     }, ,     /**,      *,      * Exports the data in an XML stream,      *,      * @param os OutputStream in which will contain the output XML,      * @param validate if true, validates the XML againts the XML Schema,      * @throws SAXException,      * @throws TransformerException  ,      * @throws ParserConfigurationException ,      */,     public void exportToXML(OutputStream os, boolean validate) throws SAXException, ParserConfigurationException, TransformerException {,         exportToXML(os, "UTF-8", validate);,     }, ,     private Document getEmptyDocument() throws ParserConfigurationException{, ,         DocumentBuilderFactory dbfac = DocumentBuilderFactory.newInstance();,         DocumentBuilder docBuilder = dbfac.newDocumentBuilder();,         Document doc = docBuilder.newDocument();, ,         return doc;,     }, ,     /**,      * Exports the data in an XML stream,      *,      * @param os OutputStream in which will contain the output XML,      * @param encoding the output charset encoding,      * @param validate if true, validates the XML againts the XML Schema,      * @throws SAXException,      * @throws ParserConfigurationException ,      * @throws TransformerException ,      * @throws InvalidFormatException,      */,     public void exportToXML(OutputStream os, String encoding, boolean validate) throws SAXException, ParserConfigurationException, TransformerException{,         List<XSSFSingleXmlCell> singleXMLCells = map.getRelatedSingleXMLCell();,         List<XSSFTable> tables = map.getRelatedTables();, ,         String rootElement = map.getCtMap().getRootElement();, ,         Document doc = getEmptyDocument();, ,         Element root = null;, ,         if (isNamespaceDeclared()) {,             root=doc.createElementNS(getNamespace(),rootElement);,         } else {,             root = doc.createElementNS("", rootElement);,         },         doc.appendChild(root);, , ,         List<String> xpaths = new Vector<String>();,         Map<String,XSSFSingleXmlCell> singleXmlCellsMappings = new HashMap<String,XSSFSingleXmlCell>();,         Map<String,XSSFTable> tableMappings = new HashMap<String,XSSFTable>();, ,         for(XSSFSingleXmlCell simpleXmlCell : singleXMLCells) {,             xpaths.add(simpleXmlCell.getXpath());,             singleXmlCellsMappings.put(simpleXmlCell.getXpath(), simpleXmlCell);,         },         for(XSSFTable table : tables) {,             String commonXPath = table.getCommonXpath();,             xpaths.add(commonXPath);,             tableMappings.put(commonXPath, table);,         }, , ,         Collections.sort(xpaths,this);, ,         for(String xpath : xpaths) {, ,             XSSFSingleXmlCell simpleXmlCell = singleXmlCellsMappings.get(xpath);,             XSSFTable table = tableMappings.get(xpath);, ,             if (!xpath.matches(".*\\[.*")) {, ,                 // Exports elements and attributes mapped with simpleXmlCell,                 if (simpleXmlCell!=null) {,                     XSSFCell cell = simpleXmlCell.getReferencedCell();,                     if (cell!=null) {,                         Node currentNode = getNodeByXPath(xpath,doc.getFirstChild(),doc,false);,                         STXmlDataType.Enum dataType = simpleXmlCell.getXmlDataType();,                         mapCellOnNode(cell,currentNode,dataType);,                     },                 }, ,                 // Exports elements and attributes mapped with tables,                 if (table!=null) {, ,                     List<XSSFXmlColumnPr> tableColumns = table.getXmlColumnPrs();, ,                     XSSFSheet sheet = table.getXSSFSheet();, ,                     int startRow = table.getStartCellReference().getRow();,                     // In mappings created with Microsoft Excel the first row contains the table header and must be skipped,                     startRow +=1;, ,                     int endRow = table.getEndCellReference().getRow();, ,                     for(int i = startRow; i<= endRow; i++) {,                         XSSFRow row = sheet.getRow(i);, ,                         Node tableRootNode = getNodeByXPath(table.getCommonXpath(),doc.getFirstChild(),doc,true);, ,                         short startColumnIndex = table.getStartCellReference().getCol();,                         for(int j = startColumnIndex; j<= table.getEndCellReference().getCol();j++) {,                             XSSFCell cell = row.getCell(j);,                             if (cell!=null) {,                                 XSSFXmlColumnPr pointer = tableColumns.get(j-startColumnIndex);,                                 String localXPath = pointer.getLocalXPath();,                                 Node currentNode = getNodeByXPath(localXPath,tableRootNode,doc,false);,                                 STXmlDataType.Enum dataType = pointer.getXmlDataType();, , ,                                 mapCellOnNode(cell,currentNode,dataType);,                             }, ,                         }, ,                     }, , , ,                 },             } else {,                 // TODO:  implement filtering management in xpath,             },         }, ,         boolean isValid = true;,         if (validate) {,             isValid =isValid(doc);,         }, , , ,         if (isValid) {, ,             /////////////////,             //Output the XML, ,             //set up a transformer,             TransformerFactory transfac = TransformerFactory.newInstance();,             Transformer trans = transfac.newTransformer();,             trans.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, "yes");,             trans.setOutputProperty(OutputKeys.INDENT, "yes");,             trans.setOutputProperty(OutputKeys.ENCODING, encoding);, ,             //create string from xml tree, ,             StreamResult result = new StreamResult(os);,             DOMSource source = new DOMSource(doc);,             trans.transform(source, result);, ,         },     }, , ,     /**,      * Validate the generated XML against the XML Schema associated with the XSSFMap,      *,      * @param xml the XML to validate,      * @return,      */,     private boolean isValid(Document xml) throws SAXException{,         boolean isValid = false;,         try{,             String language = "http://www.w3.org/2001/XMLSchema";,             SchemaFactory factory = SchemaFactory.newInstance(language);, ,             Source source = new DOMSource(map.getSchema());,             Schema schema = factory.newSchema(source);,             Validator validator = schema.newValidator();,             validator.validate(new DOMSource(xml));,             //if no exceptions where raised, the document is valid,             isValid=true;, , ,         } catch(IOException e) {,             e.printStackTrace();,         },         return isValid;,     }, , ,     private void mapCellOnNode(XSSFCell cell, Node node, STXmlDataType.Enum  outputDataType) {, ,         String value ="";,         switch (cell.getCellType()) {, ,         case XSSFCell.CELL_TYPE_STRING: value = cell.getStringCellValue(); break;,         case XSSFCell.CELL_TYPE_BOOLEAN: value += cell.getBooleanCellValue(); break;,         case XSSFCell.CELL_TYPE_ERROR: value = cell.getErrorCellString();  break;,         case XSSFCell.CELL_TYPE_FORMULA: value = cell.getStringCellValue(); break;,         case XSSFCell.CELL_TYPE_NUMERIC: value += cell.getRawValue(); break;,         default: ;, ,         },         if (node instanceof Element) {,             Element currentElement = (Element) node;,             currentElement.setTextContent(value);,         } else {,             node.setNodeValue(value);,         },     }, ,     private String removeNamespace(String elementName) {,         return elementName.matches(".*:.*")?elementName.split(":")[1]:elementName;,     }, , , ,     private Node getNodeByXPath(String xpath,Node rootNode,Document doc,boolean createMultipleInstances) {,         String[] xpathTokens = xpath.split("/");, , ,         Node currentNode =rootNode;,         // The first token is empty, the second is the root node,         for(int i =2; i<xpathTokens.length;i++) {, ,             String axisName = removeNamespace(xpathTokens[i]);, , ,             if (!axisName.startsWith("@")) {, ,                 NodeList list =currentNode.getChildNodes();, ,                 Node selectedNode = null;,                 if (!(createMultipleInstances && i==xpathTokens.length-1) ) {,                     // select the last child node only if we need to map to a single cell,                     selectedNode = selectNode(axisName, list);,                 },                 if (selectedNode==null) {,                     selectedNode = createElement(doc, currentNode, axisName);,                 },                 currentNode = selectedNode;,             } else {, , ,                 Node attribute = createAttribute(doc, currentNode, axisName);, ,                 currentNode = attribute;,             },         },         return currentNode;,     }, ,     private Node createAttribute(Document doc, Node currentNode, String axisName) {,         String attributeName = axisName.substring(1);,         NamedNodeMap attributesMap = currentNode.getAttributes();,         Node attribute = attributesMap.getNamedItem(attributeName);,         if (attribute==null) {,             attribute = doc.createAttributeNS("", attributeName);,             attributesMap.setNamedItem(attribute);,         },         return attribute;,     }, ,     private Node createElement(Document doc, Node currentNode, String axisName) {,         Node selectedNode;,         if (isNamespaceDeclared()) {,             selectedNode =doc.createElementNS(getNamespace(),axisName);,         } else {,             selectedNode = doc.createElementNS("", axisName);,         },         currentNode.appendChild(selectedNode);,         return selectedNode;,     }, ,     private Node selectNode(String axisName, NodeList list) {,         Node selectedNode = null;,         for(int j=0;j<list.getLength();j++) {,             Node node = list.item(j);,             if (node.getNodeName().equals(axisName)) {,                 selectedNode=node;,                 break;,             },         },         return selectedNode;,     }, , ,     private boolean isNamespaceDeclared() {,         String schemaNamespace = getNamespace();,         return schemaNamespace!=null && !schemaNamespace.equals("");,     }, ,     private String getNamespace() {,         return map.getCTSchema().getNamespace();,     }, , ,     /**,      * Compares two xpaths to define an ordering according to the XML Schema,      *,      */,     public int compare(String leftXpath, String rightXpath) {, ,         int result = 0;,         Node xmlSchema = map.getSchema();, , ,         String[] leftTokens = leftXpath.split("/");,         String[] rightTokens = rightXpath.split("/");, ,         int minLenght = leftTokens.length< rightTokens.length? leftTokens.length : rightTokens.length;, ,         Node localComplexTypeRootNode = xmlSchema;, , ,         for(int i =1;i <minLenght; i++) {, ,             String leftElementName =leftTokens[i];,             String rightElementName = rightTokens[i];, ,             if (leftElementName.equals(rightElementName)) {, , ,                 Node complexType = getComplexTypeForElement(leftElementName, xmlSchema,localComplexTypeRootNode);,                 localComplexTypeRootNode = complexType;,             } else {,                 int leftIndex = indexOfElementInComplexType(leftElementName,localComplexTypeRootNode);,                 int rightIndex = indexOfElementInComplexType(rightElementName,localComplexTypeRootNode);,                 if (leftIndex!=-1 && rightIndex!=-1) {,                     if ( leftIndex < rightIndex) {,                         result = -1;,                     }if ( leftIndex > rightIndex) {,                         result = 1;,                     },                 } else {,                     // NOTE: the xpath doesn't match correctly in the schema,                 },             },         }, ,         return result;,     }, ,     private int indexOfElementInComplexType(String elementName,Node complexType) {, ,         NodeList list  = complexType.getChildNodes();,         int indexOf = -1;, ,         for(int i=0; i< list.getLength();i++) {,             Node node = list.item(i);,             if (node instanceof Element) {,                 if (node.getLocalName().equals("element")) {,                     Node nameAttribute  = node.getAttributes().getNamedItem("name");,                     if (nameAttribute.getNodeValue().equals(removeNamespace(elementName))) {,                         indexOf = i;,                         break;,                     }, ,                 },             },         },         return indexOf;,     }, ,     private Node getComplexTypeForElement(String elementName,Node xmlSchema,Node localComplexTypeRootNode) {,         Node complexTypeNode = null;, ,         String elementNameWithoutNamespace = removeNamespace(elementName);, , ,         NodeList  list  = localComplexTypeRootNode.getChildNodes();,         String complexTypeName = "";, , , ,         for(int i=0; i< list.getLength();i++) {,             Node node = list.item(i);,             if ( node instanceof Element) {,                 if (node.getLocalName().equals("element")) {,                     Node nameAttribute  = node.getAttributes().getNamedItem("name");,                     if (nameAttribute.getNodeValue().equals(elementNameWithoutNamespace)) {,                         Node complexTypeAttribute = node.getAttributes().getNamedItem("type");,                         if (complexTypeAttribute!=null) {,                             complexTypeName = complexTypeAttribute.getNodeValue();,                             break;,                         },                     },                 },             },         },         // Note: we expect that all the complex types are defined at root level,         if (!"".equals(complexTypeName)) {,             NodeList  complexTypeList  = xmlSchema.getChildNodes();,             for(int i=0; i< complexTypeList.getLength();i++) {,                 Node node = list.item(i);,                 if ( node instanceof Element) {,                     if (node.getLocalName().equals("complexType")) {,                         Node nameAttribute  = node.getAttributes().getNamedItem("name");,                         if (nameAttribute.getNodeValue().equals(complexTypeName)) {, ,                             NodeList complexTypeChildList  =node.getChildNodes();,                             for(int j=0; j<complexTypeChildList.getLength();j++) {,                                 Node sequence = complexTypeChildList.item(j);, ,                                 if ( sequence instanceof Element) {,                                     if (sequence.getLocalName().equals("sequence")) {,                                         complexTypeNode = sequence;,                                         break;,                                     },                                 },                             },                             if (complexTypeNode!=null) {,                                 break;,                             }, ,                         },                     },                 },             },         },         return complexTypeNode;],,
PERFORMANCE,WMI_WRONG_MAP_ITERATOR,org/apache/poi/xssf/model/StylesTable.java,putNumberFormat,183-183,[				if(numberFormats.get(key).equals(fmt)) {],,
I18N,DM_DEFAULT_ENCODING,org/apache/poi/xssf/model/TestSharedStringsTable.java,readStrings,168-168,[                new InputStreamReader(samples.openResourceAsStream(filename)));],,
I18N,DM_DEFAULT_ENCODING,org/apache/poi/xssf/streaming/GZIPSheetDataWriter.java,createWriter,48-48,[        return new OutputStreamWriter(new GZIPOutputStream(new FileOutputStream(fd)));],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/poi/xssf/streaming/SXSSFCell.java,setProperty,673-682,[            switch(type),             {,                 case Property.COMMENT:,                 {,                     current=new CommentProperty(value);,                     break;,                 },                 case Property.HYPERLINK:,                 {,                     current=new HyperlinkProperty(value);],,
BAD_PRACTICE,CN_IDIOM,org/apache/poi/xssf/streaming/SXSSFSheet.java,,39-1282,[public class SXSSFSheet implements Sheet, Cloneable, {,     SXSSFWorkbook _workbook;,     XSSFSheet _sh;,     TreeMap<Integer,SXSSFRow> _rows=new TreeMap<Integer,SXSSFRow>();,     SheetDataWriter _writer;,     int _randomAccessWindowSize = SXSSFWorkbook.DEFAULT_WINDOW_SIZE;, ,     public SXSSFSheet(SXSSFWorkbook workbook, XSSFSheet xSheet) throws IOException,     {,         _workbook=workbook;,         _sh=xSheet;,         _writer = workbook.createSheetDataWriter();,         setRandomAccessWindowSize(_workbook.getRandomAccessWindowSize());, ,     }, ,     /**,      * for testing purposes only,      */,     SheetDataWriter getSheetDataWriter(){,         return _writer;,     }, , /* Gets "<sheetData>" document fragment*/,     public InputStream getWorksheetXMLInputStream() throws IOException ,     {,         // flush all remaining data and close the temp file writer,         flushRows(0);,         _writer.close();,         return _writer.getWorksheetXMLInputStream();,     }, , //start of interface implementation,     public Iterator<Row> iterator(),     {,         return rowIterator();,     }, ,     /**,      * Create a new row within the sheet and return the high level representation,      *,      * @param rownum  row number,      * @return high level Row object representing a row in the sheet,      * @see #removeRow(Row),      */,     public Row createRow(int rownum),     {, //Make the initial allocation as big as the row above.,         Row previousRow=rownum>0?getRow(rownum-1):null;,         int initialAllocationSize=0;, //have previous row in memory -> take that value.,         if(previousRow!=null),             initialAllocationSize=previousRow.getLastCellNum();, //are we called after a flush(0)? If yes, ask the writer for the value.,         if(initialAllocationSize<=0&&_writer.getNumberOfFlushedRows()>0),             initialAllocationSize=_writer.getNumberOfCellsOfLastFlushedRow();, //default to 10 on the first row.,         if(initialAllocationSize<=0),             initialAllocationSize=10;,         SXSSFRow newRow=new SXSSFRow(this,initialAllocationSize);,         _rows.put(new Integer(rownum),newRow);,         if(_randomAccessWindowSize>=0&&_rows.size()>_randomAccessWindowSize),         {,             try,             {,                flushRows(_randomAccessWindowSize);,             },             catch (IOException ioe),             {,                 throw new RuntimeException(ioe);,             },         },         return newRow;,     }, ,     /**,      * Remove a row from this sheet.  All cells contained in the row are removed as well,      *,      * @param row   representing a row to remove.,      */,     public void removeRow(Row row),     {,         if (row.getSheet() != this) {,             throw new IllegalArgumentException("Specified row does not belong to this sheet");,         }, ,         for(Iterator<Map.Entry<Integer,SXSSFRow>> iter=_rows.entrySet().iterator();iter.hasNext();),         {,             Map.Entry<Integer,SXSSFRow> entry=iter.next();,             if(entry.getValue()==row),             {,                 iter.remove();,                 return;,             },         },     }, ,     /**,      * Returns the logical row (not physical) 0-based.  If you ask for a row that is not,      * defined you get a null.  This is to say row 4 represents the fifth row on a sheet.,      *,      * @param rownum  row to get (0-based),      * @return Row representing the rownumber or null if its not defined on the sheet,      */,     public Row getRow(int rownum),     {,         return _rows.get(new Integer(rownum));,     }, ,     /**,      * Returns the number of physically defined rows (NOT the number of rows in the sheet),      *,      * @return the number of physically defined rows in this sheet,      */,     public int getPhysicalNumberOfRows(),     {,         return _rows.size()+_writer.getNumberOfFlushedRows();,     }, ,     /**,      * Gets the first row on the sheet,      *,      * @return the number of the first logical row on the sheet (0-based),      */,     public int getFirstRowNum(),     {,         if(_writer.getNumberOfFlushedRows() > 0),             return _writer.getLowestIndexOfFlushedRows();,         return _rows.size() == 0 ? 0 : _rows.firstKey();,     }, ,     /**,      * Gets the last row on the sheet,      *,      * @return last row contained n this sheet (0-based),      */,     public int getLastRowNum(),     {,         return _rows.size() == 0 ? 0 : _rows.lastKey();,     }, ,     /**,      * Get the visibility state for a given column,      *,      * @param columnIndex - the column to get (0-based),      * @param hidden - the visiblity state of the column,      */,     public void setColumnHidden(int columnIndex, boolean hidden),     {,         _sh.setColumnHidden(columnIndex,hidden);,     }, ,     /**,      * Get the hidden state for a given column,      *,      * @param columnIndex - the column to set (0-based),      * @return hidden - <code>false</code> if the column is visible,      */,     public boolean isColumnHidden(int columnIndex),     {,         return _sh.isColumnHidden(columnIndex);,     }, ,     /**,      * Set the width (in units of 1/256th of a character width),      * <p>,      * The maximum column width for an individual cell is 255 characters.,      * This value represents the number of characters that can be displayed,      * in a cell that is formatted with the standard font.,      * </p>,      *,      * @param columnIndex - the column to set (0-based),      * @param width - the width in units of 1/256th of a character width,      */,     public void setColumnWidth(int columnIndex, int width),     {,         _sh.setColumnWidth(columnIndex,width);,     }, ,     /**,      * get the width (in units of 1/256th of a character width ),      * @param columnIndex - the column to set (0-based),      * @return width - the width in units of 1/256th of a character width,      */,     public int getColumnWidth(int columnIndex),     {,         return _sh.getColumnWidth(columnIndex);,     }, ,     /**,      * Set the default column width for the sheet (if the columns do not define their own width),      * in characters,      *,      * @param width default column width measured in characters,      */,     public void setDefaultColumnWidth(int width),     {,         _sh.setDefaultColumnWidth(width);,     }, ,     /**,      * Get the default column width for the sheet (if the columns do not define their own width),      * in characters,      *,      * @return default column width measured in characters,      */,     public int getDefaultColumnWidth(),     {,         return _sh.getDefaultColumnWidth();,     },  , ,     /**,      * Get the default row height for the sheet (if the rows do not define their own height) in,      * twips (1/20 of  a point),      *,      * @return  default row height measured in twips (1/20 of  a point),      */,     public short getDefaultRowHeight(),     {,         return _sh.getDefaultRowHeight();,     }, ,     /**,      * Get the default row height for the sheet (if the rows do not define their own height) in,      * points.,      *,      * @return  default row height in points,      */,     public float getDefaultRowHeightInPoints(),     {,         return _sh.getDefaultRowHeightInPoints();,     }, ,     /**,      * Set the default row height for the sheet (if the rows do not define their own height) in,      * twips (1/20 of  a point),      *,      * @param  height default row height measured in twips (1/20 of  a point),      */,     public void setDefaultRowHeight(short height),     {,         _sh.setDefaultRowHeight(height);,     }, ,     /**,      * Set the default row height for the sheet (if the rows do not define their own height) in,      * points,      * @param height default row height,      */,     public void setDefaultRowHeightInPoints(float height),     {,         _sh.setDefaultRowHeightInPoints(height);,     },     , ,     /**,      * Returns the CellStyle that applies to the given,      *  (0 based) column, or null if no style has been,      *  set for that column,      */,     public CellStyle getColumnStyle(int column),     {,         return _sh.getColumnStyle(column);,     }, ,     /**,      * Sets the CellStyle that applies to the given,      *  (0 based) column.,      */, //    public CellStyle setColumnStyle(int column, CellStyle style);, ,     /**,      * Adds a merged region of cells (hence those cells form one),      *,      * @param region (rowfrom/colfrom-rowto/colto) to merge,      * @return index of this region,      */,     public int addMergedRegion(CellRangeAddress region),     {,         return _sh.addMergedRegion(region);,     }, ,     /**,      * Determines whether the output is vertically centered on the page.,      *,      * @param value true to vertically center, false otherwise.,      */,     public void setVerticallyCenter(boolean value),     {,         _sh.setVerticallyCenter(value);,     }, ,     /**,      * Determines whether the output is horizontally centered on the page.,      *,      * @param value true to horizontally center, false otherwise.,      */,     public void setHorizontallyCenter(boolean value),     {,         _sh.setHorizontallyCenter(value);,     }, ,     /**,      * Determine whether printed output for this sheet will be horizontally centered.,      */, ,     public boolean getHorizontallyCenter(),     {,         return _sh.getHorizontallyCenter();,     }, ,     /**,      * Determine whether printed output for this sheet will be vertically centered.,      */,     public boolean getVerticallyCenter(),     {,         return _sh.getVerticallyCenter();,     }, ,     /**,      * Removes a merged region of cells (hence letting them free),      *,      * @param index of the region to unmerge,      */,     public void removeMergedRegion(int index),     {,         _sh.removeMergedRegion(index);,     }, ,     /**,      * Returns the number of merged regions,      *,      * @return number of merged regions,      */,     public int getNumMergedRegions(),     {,         return _sh.getNumMergedRegions();,     }, ,     /**,      * Returns the merged region at the specified index,      *,      * @return the merged region at the specified index,      */,     public CellRangeAddress getMergedRegion(int index),     {,         return _sh.getMergedRegion(index);,     }, ,     /**,      *  Returns an iterator of the physical rows,      *,      * @return an iterator of the PHYSICAL rows.  Meaning the 3rd element may not,      * be the third row if say for instance the second row is undefined.,      */,     public Iterator<Row> rowIterator(),     {,         @SuppressWarnings("unchecked"),         Iterator<Row> result = (Iterator<Row>)(Iterator<? extends Row>)_rows.values().iterator();,         return result;,     }, ,     /**,      * Flag indicating whether the sheet displays Automatic Page Breaks.,      *,      * @param value <code>true</code> if the sheet displays Automatic Page Breaks.,      */,     public void setAutobreaks(boolean value),     {,         _sh.setAutobreaks(value);,     }, ,     /**,      * Set whether to display the guts or not,      *,      * @param value - guts or no guts,      */,     public void setDisplayGuts(boolean value),     {,         _sh.setDisplayGuts(value);,     }, ,     /**,      * Set whether the window should show 0 (zero) in cells containing zero value.,      * When false, cells with zero value appear blank instead of showing the number zero.,      *,      * @param value whether to display or hide all zero values on the worksheet,      */,     public void setDisplayZeros(boolean value),     {,         _sh.setDisplayZeros(value);,     }, , ,     /**,      * Gets the flag indicating whether the window should show 0 (zero) in cells containing zero value.,      * When false, cells with zero value appear blank instead of showing the number zero.,      *,      * @return whether all zero values on the worksheet are displayed,      */,     public boolean isDisplayZeros(),     {,         return _sh.isDisplayZeros();,     },     ,     /**,      * Sets whether the worksheet is displayed from right to left instead of from left to right.,      *,      * @param value true for right to left, false otherwise.,      */,     public void setRightToLeft(boolean value),     {,        _sh.setRightToLeft(value);,     }, ,     /**,      * Whether the text is displayed in right-to-left mode in the window,      *,      * @return whether the text is displayed in right-to-left mode in the window,      */,     public boolean isRightToLeft(),     {,        return _sh.isRightToLeft();,     }, ,     /**,      * Flag indicating whether the Fit to Page print option is enabled.,      *,      * @param value <code>true</code> if the Fit to Page print option is enabled.,      */,     public void setFitToPage(boolean value),     {,         _sh.setFitToPage(value);,     }, ,     /**,      * Flag indicating whether summary rows appear below detail in an outline, when applying an outline.,      *,      * <p>,      * When true a summary row is inserted below the detailed data being summarized and a,      * new outline level is established on that row.,      * </p>,      * <p>,      * When false a summary row is inserted above the detailed data being summarized and a new outline level,      * is established on that row.,      * </p>,      * @param value <code>true</code> if row summaries appear below detail in the outline,      */,     public void setRowSumsBelow(boolean value),     {,         _sh.setRowSumsBelow(value);,     }, ,     /**,      * Flag indicating whether summary columns appear to the right of detail in an outline, when applying an outline.,      *,      * <p>,      * When true a summary column is inserted to the right of the detailed data being summarized,      * and a new outline level is established on that column.,      * </p>,      * <p>,      * When false a summary column is inserted to the left of the detailed data being,      * summarized and a new outline level is established on that column.,      * </p>,      * @param value <code>true</code> if col summaries appear right of the detail in the outline,      */,     public void setRowSumsRight(boolean value),     {,         _sh.setRowSumsRight(value);,     }, ,     /**,      * Flag indicating whether the sheet displays Automatic Page Breaks.,      *,      * @return <code>true</code> if the sheet displays Automatic Page Breaks.,      */,     public boolean getAutobreaks(),     {,         return _sh.getAutobreaks();,     }, ,     /**,      * Get whether to display the guts or not,,      * default value is true,      *,      * @return boolean - guts or no guts,      */,     public boolean getDisplayGuts(),     {,         return _sh.getDisplayGuts();,     }, ,     /**,      * Flag indicating whether the Fit to Page print option is enabled.,      *,      * @return <code>true</code> if the Fit to Page print option is enabled.,      */,     public boolean getFitToPage(),     {,         return _sh.getFitToPage();,     }, ,     /**,      * Flag indicating whether summary rows appear below detail in an outline, when applying an outline.,      *,      * <p>,      * When true a summary row is inserted below the detailed data being summarized and a,      * new outline level is established on that row.,      * </p>,      * <p>,      * When false a summary row is inserted above the detailed data being summarized and a new outline level,      * is established on that row.,      * </p>,      * @return <code>true</code> if row summaries appear below detail in the outline,      */,     public boolean getRowSumsBelow(),     {,         return _sh.getRowSumsBelow();,     }, ,     /**,      * Flag indicating whether summary columns appear to the right of detail in an outline, when applying an outline.,      *,      * <p>,      * When true a summary column is inserted to the right of the detailed data being summarized,      * and a new outline level is established on that column.,      * </p>,      * <p>,      * When false a summary column is inserted to the left of the detailed data being,      * summarized and a new outline level is established on that column.,      * </p>,      * @return <code>true</code> if col summaries appear right of the detail in the outline,      */,     public boolean getRowSumsRight(),     {,         return _sh.getRowSumsRight();,     }, ,     /**,      * Gets the flag indicating whether this sheet displays the lines,      * between rows and columns to make editing and reading easier.,      *,      * @return <code>true</code> if this sheet displays gridlines.,      * @see #isPrintGridlines() to check if printing of gridlines is turned on or off,      */,     public boolean isPrintGridlines(),     {,         return _sh.isPrintGridlines();,     }, ,     /**,      * Sets the flag indicating whether this sheet should display the lines,      * between rows and columns to make editing and reading easier.,      * To turn printing of gridlines use {@link #setPrintGridlines(boolean)},      *,      *,      * @param show <code>true</code> if this sheet should display gridlines.,      * @see #setPrintGridlines(boolean),      */,     public void setPrintGridlines(boolean show),     {,         _sh.setPrintGridlines(show);,     }, ,     /**,      * Gets the print setup object.,      *,      * @return The user model for the print setup object.,      */,     public PrintSetup getPrintSetup(),     {,         return _sh.getPrintSetup();,     }, ,     /**,      * Gets the user model for the default document header.,      * <p/>,      * Note that XSSF offers more kinds of document headers than HSSF does,      * </p>,      * @return the document header. Never <code>null</code>,      */,     public Header getHeader(),     {,         return _sh.getHeader();,     }, ,     /**,      * Gets the user model for the default document footer.,      * <p/>,      * Note that XSSF offers more kinds of document footers than HSSF does.,      *,      * @return the document footer. Never <code>null</code>,      */,     public Footer getFooter(),     {,         return _sh.getFooter();,     }, ,     /**,      * Sets a flag indicating whether this sheet is selected.,      *<p>,      * Note: multiple sheets can be selected, but only one sheet can be active at one time.,      *</p>,      * @param value <code>true</code> if this sheet is selected,      * @see Workbook#setActiveSheet(int),      */,     public void setSelected(boolean value),     {,         _sh.setSelected(value);,     }, ,     /**,      * Gets the size of the margin in inches.,      *,      * @param margin which margin to get,      * @return the size of the margin,      */,     public double getMargin(short margin),     {,         return _sh.getMargin(margin);,     }, ,     /**,      * Sets the size of the margin in inches.,      *,      * @param margin which margin to get,      * @param size the size of the margin,      */,     public void setMargin(short margin, double size),     {,         _sh.setMargin(margin,size);,     }, ,     /**,      * Answer whether protection is enabled or disabled,      *,      * @return true => protection enabled; false => protection disabled,      */,     public boolean getProtect(),     {,         return _sh.getProtect();,     },     ,     /**,      * Sets the protection enabled as well as the password,      * @param password to set for protection. Pass <code>null</code> to remove protection,      */,     public void protectSheet(String password),     {,         _sh.protectSheet(password);,     },     ,     /**,      * Answer whether scenario protection is enabled or disabled,      *,      * @return true => protection enabled; false => protection disabled,      */,     public boolean getScenarioProtect(),     {,         return _sh.getScenarioProtect();,     }, ,     /**,      * Sets the zoom magnication for the sheet.  The zoom is expressed as a,      * fraction.  For example to express a zoom of 75% use 3 for the numerator,      * and 4 for the denominator.,      *,      * @param numerator     The numerator for the zoom magnification.,      * @param denominator   The denominator for the zoom magnification.,      */,     public void setZoom(int numerator, int denominator),     {,         _sh.setZoom(numerator,denominator);,     }, ,     /**,      * The top row in the visible view when the sheet is,      * first viewed after opening it in a viewer,      *,      * @return short indicating the rownum (0 based) of the top row,      */,     public short getTopRow(),     {,         return _sh.getTopRow();,     }, ,     /**,      * The left col in the visible view when the sheet is,      * first viewed after opening it in a viewer,      *,      * @return short indicating the rownum (0 based) of the top row,      */,     public short getLeftCol(),     {,         return _sh.getLeftCol();,     }, ,     /**,      * Sets desktop window pane display area, when the,      * file is first opened in a viewer.,      *,      * @param toprow the top row to show in desktop window pane,      * @param leftcol the left column to show in desktop window pane,      */,     public void showInPane(short toprow, short leftcol),     {,         _sh.showInPane(toprow, leftcol);,     }, ,     /**,      * Control if Excel should be asked to recalculate all formulas when the,      *  workbook is opened, via the "sheetCalcPr fullCalcOnLoad" option.,      *  Calculating the formula values with {@link org.apache.poi.ss.usermodel.FormulaEvaluator} is the,      *  recommended solution, but this may be used for certain cases where,      *  evaluation in POI is not possible.,      */,     public void setForceFormulaRecalculation(boolean value) {,        _sh.setForceFormulaRecalculation(value);,     }, ,     /**,      * Whether Excel will be asked to recalculate all formulas when the,      *  workbook is opened.,      */,     public boolean getForceFormulaRecalculation() {,        return _sh.getForceFormulaRecalculation();,     }, ,     /**,      * Shifts rows between startRow and endRow n number of rows.,      * If you use a negative number, it will shift rows up.,      * Code ensures that rows don't wrap around.,      *,      * Calls shiftRows(startRow, endRow, n, false, false);,      *,      * <p>,      * Additionally shifts merged regions that are completely defined in these,      * rows (ie. merged 2 cells on a row to be shifted).,      * @param startRow the row to start shifting,      * @param endRow the row to end shifting,      * @param n the number of rows to shift,      */,     public void shiftRows(int startRow, int endRow, int n),     {,         throw new RuntimeException("NotImplemented");,     }, ,     /**,      * Shifts rows between startRow and endRow n number of rows.,      * If you use a negative number, it will shift rows up.,      * Code ensures that rows don't wrap around,      *,      * <p>,      * Additionally shifts merged regions that are completely defined in these,      * rows (ie. merged 2 cells on a row to be shifted).,      * <p>,      * @param startRow the row to start shifting,      * @param endRow the row to end shifting,      * @param n the number of rows to shift,      * @param copyRowHeight whether to copy the row height during the shift,      * @param resetOriginalRowHeight whether to set the original row's height to the default,      */,     public void shiftRows(int startRow, int endRow, int n, boolean copyRowHeight, boolean resetOriginalRowHeight),     {,         throw new RuntimeException("NotImplemented");,     }, ,     /**,      * Creates a split (freezepane). Any existing freezepane or split pane is overwritten.,      * @param colSplit      Horizonatal position of split.,      * @param rowSplit      Vertical position of split.,      * @param leftmostColumn   Left column visible in right pane.,      * @param topRow        Top row visible in bottom pane,      */,     public void createFreezePane(int colSplit, int rowSplit, int leftmostColumn, int topRow),     {,         _sh.createFreezePane(colSplit, rowSplit, leftmostColumn, topRow);,     }, ,     /**,      * Creates a split (freezepane). Any existing freezepane or split pane is overwritten.,      * @param colSplit      Horizonatal position of split.,      * @param rowSplit      Vertical position of split.,      */,     public void createFreezePane(int colSplit, int rowSplit),     {,         _sh.createFreezePane(colSplit,rowSplit);,     }, ,     /**,      * Creates a split pane. Any existing freezepane or split pane is overwritten.,      * @param xSplitPos      Horizonatal position of split (in 1/20th of a point).,      * @param ySplitPos      Vertical position of split (in 1/20th of a point).,      * @param topRow        Top row visible in bottom pane,      * @param leftmostColumn   Left column visible in right pane.,      * @param activePane    Active pane.  One of: PANE_LOWER_RIGHT,,      *                      PANE_UPPER_RIGHT, PANE_LOWER_LEFT, PANE_UPPER_LEFT,      * @see #PANE_LOWER_LEFT,      * @see #PANE_LOWER_RIGHT,      * @see #PANE_UPPER_LEFT,      * @see #PANE_UPPER_RIGHT,      */,     public void createSplitPane(int xSplitPos, int ySplitPos, int leftmostColumn, int topRow, int activePane),     {,         _sh.createSplitPane(xSplitPos, ySplitPos, leftmostColumn, topRow, activePane);,     }, ,     /**,      * Returns the information regarding the currently configured pane (split or freeze),      *,      * @return null if no pane configured, or the pane information.,      */,     public PaneInformation getPaneInformation(),     {,         return _sh.getPaneInformation();,     }, ,     /**,      * Sets whether the gridlines are shown in a viewer,      *,      * @param show whether to show gridlines or not,      */,     public void setDisplayGridlines(boolean show),     {,         _sh.setDisplayGridlines(show);,     }, ,     /**,      * Returns if gridlines are displayed,      *,      * @return whether gridlines are displayed,      */,     public boolean isDisplayGridlines(),     {,         return _sh.isDisplayGridlines();,     }, ,     /**,      * Sets whether the formulas are shown in a viewer,      *,      * @param show whether to show formulas or not,      */,     public void setDisplayFormulas(boolean show),     {,         _sh.setDisplayFormulas(show);,     }, ,     /**,      * Returns if formulas are displayed,      *,      * @return whether formulas are displayed,      */,     public boolean isDisplayFormulas(),     {,         return _sh.isDisplayFormulas();,     }, ,     /**,      * Sets whether the RowColHeadings are shown in a viewer,      *,      * @param show whether to show RowColHeadings or not,      */,     public void setDisplayRowColHeadings(boolean show),     {,         _sh.setDisplayRowColHeadings(show);,     }, ,     /**,      * Returns if RowColHeadings are displayed.,      * @return whether RowColHeadings are displayed,      */,     public boolean isDisplayRowColHeadings(),     {,         return _sh.isDisplayRowColHeadings();,     }, ,     /**,      * Sets a page break at the indicated row,      * @param row FIXME: Document this!,      */,     public void setRowBreak(int row),     {,         _sh.setRowBreak(row);,     }, ,     /**,      * Determines if there is a page break at the indicated row,      * @param row FIXME: Document this!,      * @return FIXME: Document this!,      */,     public boolean isRowBroken(int row),     {,         return _sh.isRowBroken(row);,     }, ,     /**,      * Removes the page break at the indicated row,      * @param row,      */,     public void removeRowBreak(int row),     {,         _sh.removeRowBreak(row);,     }, ,     /**,      * Retrieves all the horizontal page breaks,      * @return all the horizontal page breaks, or null if there are no row page breaks,      */,     public int[] getRowBreaks(),     {,         return _sh.getRowBreaks();,     }, ,     /**,      * Retrieves all the vertical page breaks,      * @return all the vertical page breaks, or null if there are no column page breaks,      */,     public int[] getColumnBreaks(),     {,         return _sh.getColumnBreaks();,     }, ,     /**,      * Sets a page break at the indicated column,      * @param column,      */,     public void setColumnBreak(int column),     {,         _sh.setColumnBreak(column);,     }, ,     /**,      * Determines if there is a page break at the indicated column,      * @param column FIXME: Document this!,      * @return FIXME: Document this!,      */,     public boolean isColumnBroken(int column),     {,         return _sh.isColumnBroken(column);,     }, ,     /**,      * Removes a page break at the indicated column,      * @param column,      */,     public void removeColumnBreak(int column),     {,         _sh.removeColumnBreak(column);,     }, ,     /**,      * Expands or collapses a column group.,      *,      * @param columnNumber      One of the columns in the group.,      * @param collapsed         true = collapse group, false = expand group.,      */,     public void setColumnGroupCollapsed(int columnNumber, boolean collapsed),     {,         _sh.setColumnGroupCollapsed(columnNumber, collapsed);,     }, ,     /**,      * Create an outline for the provided column range.,      *,      * @param fromColumn        beginning of the column range.,      * @param toColumn          end of the column range.,      */,     public void groupColumn(int fromColumn, int toColumn),     {,         _sh.groupColumn(fromColumn,toColumn);,     }, ,     /**,      * Ungroup a range of columns that were previously groupped,      *,      * @param fromColumn   start column (0-based),      * @param toColumn     end column (0-based),      */,     public void ungroupColumn(int fromColumn, int toColumn),     {,         _sh.ungroupColumn(fromColumn, toColumn);,     }, ,     /**,      * Tie a range of rows together so that they can be collapsed or expanded,      *,      * @param fromRow   start row (0-based),      * @param toRow     end row (0-based),      */,     public void groupRow(int fromRow, int toRow),     {,         _sh.groupRow(fromRow, toRow);,     }, ,     /**,      * Ungroup a range of rows that were previously groupped,      *,      * @param fromRow   start row (0-based),      * @param toRow     end row (0-based),      */,     public void ungroupRow(int fromRow, int toRow),     {,         _sh.ungroupRow(fromRow, toRow);,     }, ,     /**,      * Set view state of a groupped range of rows,      *,      * @param row   start row of a groupped range of rows (0-based),      * @param collapse whether to expand/collapse the detail rows,      */,     public void setRowGroupCollapsed(int row, boolean collapse),     {,         _sh.setRowGroupCollapsed(row, collapse);,     }, ,     /**,      * Sets the default column style for a given column.  POI will only apply this style to new cells added to the sheet.,      *,      * @param column the column index,      * @param style the style to set,      */,     public void setDefaultColumnStyle(int column, CellStyle style),     {,         _sh.setDefaultColumnStyle(column, style);,     }, ,     /**,      * Adjusts the column width to fit the contents.,      *,      * <p>,      * This process can be relatively slow on large sheets, so this should,      *  normally only be called once per column, at the end of your,      *  processing.,      * </p>,      * You can specify whether the content of merged cells should be considered or ignored.,      *  Default is to ignore merged cells.,      *,      * @param column the column index,      */,     public void autoSizeColumn(int column),     {,         autoSizeColumn(column, false);,     }, ,     /**,      * Adjusts the column width to fit the contents.,      * <p>,      * This process can be relatively slow on large sheets, so this should,      *  normally only be called once per column, at the end of your,      *  processing.,      * </p>,      * You can specify whether the content of merged cells should be considered or ignored.,      *  Default is to ignore merged cells.,      *,      * @param column the column index,      * @param useMergedCells whether to use the contents of merged cells when calculating the width of the column,      */,     public void autoSizeColumn(int column, boolean useMergedCells),     {,         double width = SheetUtil.getColumnWidth(this, column, useMergedCells);, ,         if (width != -1) {,             width *= 256;,             int maxColumnWidth = 255*256; // The maximum column width for an individual cell is 255 characters,             if (width > maxColumnWidth) {,                 width = maxColumnWidth;,             },             setColumnWidth(column, (int)(width));,         },     }, ,     /**,      * Returns cell comment for the specified row and column,      *,      * @return cell comment or <code>null</code> if not found,      */,     public Comment getCellComment(int row, int column),     {,         return _sh.getCellComment(row, column);,     }, ,     /**,      * Creates the top-level drawing patriarch.,      *,      * @return  The new drawing patriarch.,      */,     public Drawing createDrawingPatriarch(),     {,         return _sh.createDrawingPatriarch();,     }, , ,     /**,      * Return the parent workbook,      *,      * @return the parent workbook,      */,     public Workbook getWorkbook(),     {,         return _workbook;,     }, ,     /**,      * Returns the name of this sheet,      *,      * @return the name of this sheet,      */,     public String getSheetName(),     {,         return _sh.getSheetName();,     }, ,     /**,      * Note - this is not the same as whether the sheet is focused (isActive),      * @return <code>true</code> if this sheet is currently selected,      */,     public boolean isSelected(),     {,         return _sh.isSelected();,     }, , ,     /**,      * Sets array formula to specified region for result.,      *,      * @param formula text representation of the formula,      * @param range Region of array formula for result.,      * @return the {@link CellRange} of cells affected by this change,      */,     public CellRange<? extends Cell> setArrayFormula(String formula, CellRangeAddress range),     {,         return _sh.setArrayFormula(formula, range);,     }, ,     /**,      * Remove a Array Formula from this sheet.  All cells contained in the Array Formula range are removed as well,      *,      * @param cell   any cell within Array Formula range,      * @return the {@link CellRange} of cells affected by this change,      */,     public CellRange<? extends Cell> removeArrayFormula(Cell cell),     {,         return _sh.removeArrayFormula(cell);,     },     ,     public DataValidationHelper getDataValidationHelper(),     {,         return _sh.getDataValidationHelper();,     }, ,     /**,      * Creates a data validation object,      * @param dataValidation The Data validation object settings,      */,     public void addValidationData(DataValidation dataValidation),     {,         _sh.addValidationData(dataValidation);,     }, ,     /**,      * Enable filtering for a range of cells,      * ,      * @param range the range of cells to filter,      */,     public AutoFilter setAutoFilter(CellRangeAddress range),     {,         return _sh.setAutoFilter(range);,     }, ,     public SheetConditionalFormatting getSheetConditionalFormatting(){,         return _sh.getSheetConditionalFormatting();,     }, , //end of interface implementation,     /**,      * Specifies how many rows can be accessed at most via getRow().,      * When a new node is created via createRow() and the total number,      * of unflushed records would exeed the specified value, then the,      * row with the lowest index value is flushed and cannot be accessed,      * via getRow() anymore.,      * A value of -1 indicates unlimited access. In this case all,      * records that have not been flushed by a call to flush() are available,      * for random access.,      * A value of 0 is not allowed because it would flush any newly created row,      * without having a chance to specify any cells.,      */,     public void setRandomAccessWindowSize(int value),     {,          if(value == 0 || value < -1) {,              throw new IllegalArgumentException("RandomAccessWindowSize must be either -1 or a positive integer");,          },          _randomAccessWindowSize=value;,     }, ,     /**,      * Specifies how many rows can be accessed at most via getRow().,      * The exeeding rows (if any) are flushed to the disk while rows,      * with lower index values are flushed first.,      */,     public void flushRows(int remaining) throws IOException,     {,         while(_rows.size() > remaining) flushOneRow();,     }, ,     /**,      * Flush all rows to disk. After this call no rows can be accessed via getRow(),      *,      * @throws IOException,      */,     public void flushRows() throws IOException,     {,         this.flushRows(0);,     }, ,     private void flushOneRow() throws IOException,     {,         Integer firstRowNum = _rows.firstKey();,         if (firstRowNum!=null) {,             int rowIndex = firstRowNum.intValue();,             SXSSFRow row = _rows.get(firstRowNum);,             _writer.writeRow(rowIndex, row);,             _rows.remove(firstRowNum);,         },     },     public void changeRowNum(SXSSFRow row, int newRowNum),     {,         ,         removeRow(row);,         _rows.put(new Integer(newRowNum),row);,     }, ,     public int getRowNum(SXSSFRow row),     {,         for(Iterator<Map.Entry<Integer,SXSSFRow>> iter=_rows.entrySet().iterator();iter.hasNext();),         {,             Map.Entry<Integer,SXSSFRow> entry=iter.next();,             if(entry.getValue()==row),                 return entry.getKey().intValue();,         },         assert false;,         return -1;],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/poi/xssf/streaming/SXSSFSheet.java,changeRowNum,1270-1270,[        _rows.put(new Integer(newRowNum),row);],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/poi/xssf/streaming/SXSSFSheet.java,createRow,100-100,[        _rows.put(new Integer(rownum),newRow);],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/poi/xssf/streaming/SXSSFSheet.java,getRow,146-146,[        return _rows.get(new Integer(rownum));],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/poi/xssf/streaming/SXSSFWorkbook.java,write,727-727,[        FileOutputStream os = new FileOutputStream(tmplFile);],,write,728-728,[        _wb.write(os);],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/poi/xssf/streaming/SXSSFWorkbook.java,write,733-733,[        tmplFile.delete();],,
I18N,DM_DEFAULT_ENCODING,org/apache/poi/xssf/streaming/SheetDataWriter.java,createWriter,70-70,[        return new BufferedWriter(new FileWriter(fd));],,
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,org/apache/poi/xssf/streaming/SheetDataWriter.java,finalize,107-107,[        _fd.delete();],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/poi/xssf/streaming/SheetDataWriter.java,writeCell,169-173,[                switch (cell.getCachedFormulaResultType()) {,                     case Cell.CELL_TYPE_NUMERIC:,                         double nval = cell.getNumericCellValue();,                         if (!Double.isNaN(nval)) {,                             _out.write("<v>" + nval + "</v>");],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/poi/xssf/usermodel/TestFormulaEvaluatorOnXSSF.java,confirmExpectedResult,118-143,[		switch (expected.getCellType()) {, 			case Cell.CELL_TYPE_BLANK:, 				assertEquals(msg, Cell.CELL_TYPE_BLANK, actual.getCellType());, 				break;, 			case Cell.CELL_TYPE_BOOLEAN:, 				assertEquals(msg, Cell.CELL_TYPE_BOOLEAN, actual.getCellType());, 				assertEquals(msg, expected.getBooleanCellValue(), actual.getBooleanValue());, 				break;, 			case Cell.CELL_TYPE_ERROR:, 				assertEquals(msg, Cell.CELL_TYPE_ERROR, actual.getCellType());, 				if(false) { // TODO: fix ~45 functions which are currently returning incorrect error values, 					assertEquals(msg, expected.getErrorCellValue(), actual.getErrorValue());, 				}, 				break;, 			case Cell.CELL_TYPE_FORMULA: // will never be used, since we will call method after formula evaluation, 				throw new AssertionFailedError("Cannot expect formula as result of formula evaluation: " + msg);, 			case Cell.CELL_TYPE_NUMERIC:, 				assertEquals(msg, Cell.CELL_TYPE_NUMERIC, actual.getCellType());, 				TestMathX.assertEquals(msg, expected.getNumericCellValue(), actual.getNumberValue(), TestMathX.POS_ZERO, TestMathX.DIFF_TOLERANCE_FACTOR);, //				double delta = Math.abs(expected.getNumericCellValue()-actual.getNumberValue());, //				double pctExpected = Math.abs(0.00001*expected.getNumericCellValue());, //				assertTrue(msg, delta <= pctExpected);, 				break;, 			case Cell.CELL_TYPE_STRING:, 				assertEquals(msg, Cell.CELL_TYPE_STRING, actual.getCellType());, 				assertEquals(msg, expected.getRichStringCellValue().getString(), actual.getStringValue());],,
I18N,DM_DEFAULT_ENCODING,org/apache/poi/xssf/usermodel/TestXSSFFont.java,testRgbColor,219-219,[		color.setRgb(Integer.toHexString(0xFFFFFF).getBytes());],,testRgbColor,228-228,[		color.setRgb(Integer.toHexString(0xF1F1F1).getBytes());],,
I18N,DM_DEFAULT_ENCODING,org/apache/poi/xssf/usermodel/TestXSSFPicture.java,testCreate,48-48,[        byte[] jpegData = "test jpeg data".getBytes();],,
I18N,DM_DEFAULT_ENCODING,org/apache/poi/xssf/usermodel/TestXSSFPicture.java,testShapeId,84-84,[        byte[] jpegData = "picture1".getBytes();],,testShapeId,90-90,[        jpegData = "picture2".getBytes();],,
I18N,DM_DEFAULT_ENCODING,org/apache/poi/xssf/usermodel/TestXSSFPictureData.java,testNew,63-63,[        byte[] jpegData = "test jpeg data".getBytes();],,testNew,64-64,[        byte[] wmfData =  "test wmf data".getBytes();],,testNew,65-65,[        byte[] pngData =  "test png data".getBytes();],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/poi/xssf/usermodel/TestXSSFWorkbook.java,testSaveLoadNew,75-75,[		OutputStream out = new FileOutputStream(file);],,testSaveLoadNew,76-76,[		workbook.write(out);],,
STYLE,DB_DUPLICATE_SWITCH_CLAUSES,org/apache/poi/xssf/usermodel/XSSFCell.java,getBooleanCellValue,159-159,[                return _cell.isSetV() && TRUE_AS_STRING.equals(_cell.getV());],,getBooleanCellValue,162-162,[                return _cell.isSetV() && TRUE_AS_STRING.equals(_cell.getV());],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/poi/xssf/usermodel/XSSFCell.java,getRichStringCellValue,247-247,[        return str == null ? null : str.getString();],,
BAD_PRACTICE,HE_EQUALS_USE_HASHCODE,org/apache/poi/xssf/usermodel/XSSFClientAnchor.java,equals,161-165,[        if (o == null || !(o instanceof XSSFClientAnchor)) return false;, ,         XSSFClientAnchor anchor = (XSSFClientAnchor) o;,         return cell1.toString().equals(anchor.getFrom().toString()) &&,                cell2.toString().equals(anchor.getTo().toString()) ;],,
I18N,DM_CONVERT_CASE,org/apache/poi/xssf/usermodel/XSSFColor.java,getARGBHex,206-206,[	   return sb.toString().toUpperCase();],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/poi/xssf/usermodel/XSSFColor.java,getARgb,127-127,[      if(rgb == null) return null;],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/poi/xssf/usermodel/XSSFColor.java,getRGBOrARGB,156-156,[            return null;],,
STYLE,PZLA_PREFER_ZERO_LENGTH_ARRAYS,org/apache/poi/xssf/usermodel/XSSFColor.java,getRgb,110-110,[      if(rgb == null) return null;],,
STYLE,RV_RETURN_VALUE_IGNORED_NO_SIDE_EFFECT,org/apache/poi/xssf/usermodel/XSSFComment.java,setColumn,127-127,[           _vmlShape.getClientDataList().toString();],,
MT_CORRECTNESS,LI_LAZY_INIT_STATIC,org/apache/poi/xssf/usermodel/XSSFConnector.java,prototype,65-103,[        if(prototype == null) {,             CTConnector shape = CTConnector.Factory.newInstance();,             CTConnectorNonVisual nv = shape.addNewNvCxnSpPr();,             CTNonVisualDrawingProps nvp = nv.addNewCNvPr();,             nvp.setId(1);,             nvp.setName("Shape 1");,             nv.addNewCNvCxnSpPr();, ,             CTShapeProperties sp = shape.addNewSpPr();,             CTTransform2D t2d = sp.addNewXfrm();,             CTPositiveSize2D p1 = t2d.addNewExt();,             p1.setCx(0);,             p1.setCy(0);,             CTPoint2D p2 = t2d.addNewOff();,             p2.setX(0);,             p2.setY(0);, ,             CTPresetGeometry2D geom = sp.addNewPrstGeom();,             geom.setPrst(STShapeType.LINE);,             geom.addNewAvLst();, ,             CTShapeStyle style = shape.addNewStyle();,             CTSchemeColor scheme = style.addNewLnRef().addNewSchemeClr();,             scheme.setVal(STSchemeColorVal.ACCENT_1);,             style.getLnRef().setIdx(1);, ,             CTStyleMatrixReference fillref = style.addNewFillRef();,             fillref.setIdx(0);,             fillref.addNewSchemeClr().setVal(STSchemeColorVal.ACCENT_1);, ,             CTStyleMatrixReference effectRef = style.addNewEffectRef();,             effectRef.setIdx(0);,             effectRef.addNewSchemeClr().setVal(STSchemeColorVal.ACCENT_1);, ,             CTFontReference fontRef = style.addNewFontRef();,             fontRef.setIdx(STFontCollectionIndex.MINOR);,             fontRef.addNewSchemeClr().setVal(STSchemeColorVal.TX_1);, ,             prototype = shape;],,
STYLE,UC_USELESS_CONDITION,org/apache/poi/xssf/usermodel/XSSFDataValidationConstraint.java,prettyPrint,192-192,[			if (validationType != ValidationType.LIST && validationType != ValidationType.ANY && validationType != ValidationType.FORMULA) {],,
STYLE,DB_DUPLICATE_SWITCH_CLAUSES,org/apache/poi/xssf/usermodel/XSSFDataValidationHelper.java,createValidation,124-125,[				newDataValidation.setType(STDataValidationType.NONE);				, 				break;],,createValidation,145-145,[				newDataValidation.setType(STDataValidationType.NONE);				],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/poi/xssf/usermodel/XSSFDataValidationHelper.java,,41-41,[		this.xssfSheet = xssfSheet;],,
STYLE,RI_REDUNDANT_INTERFACES,org/apache/poi/xssf/usermodel/XSSFDialogsheet.java,,33-105,[public class XSSFDialogsheet extends XSSFSheet implements Sheet{,     protected CTDialogsheet dialogsheet;, ,     protected XSSFDialogsheet(XSSFSheet sheet) {,         super(sheet.getPackagePart(), sheet.getPackageRelationship());,         this.dialogsheet = CTDialogsheet.Factory.newInstance();,         this.worksheet = CTWorksheet.Factory.newInstance();,     }, ,     public XSSFRow createRow(int rowNum) {,         return null;,     }, ,     protected CTHeaderFooter getSheetTypeHeaderFooter() {,         if (dialogsheet.getHeaderFooter() == null) {,             dialogsheet.setHeaderFooter(CTHeaderFooter.Factory.newInstance());,         },         return dialogsheet.getHeaderFooter();,     }, ,     protected CTSheetPr getSheetTypeSheetPr() {,         if (dialogsheet.getSheetPr() == null) {,             dialogsheet.setSheetPr(CTSheetPr.Factory.newInstance());,         },         return dialogsheet.getSheetPr();,     }, ,     protected CTPageBreak getSheetTypeColumnBreaks() {,         return null;,     }, ,     protected CTSheetFormatPr getSheetTypeSheetFormatPr() {,         if (dialogsheet.getSheetFormatPr() == null) {,             dialogsheet.setSheetFormatPr(CTSheetFormatPr.Factory.newInstance());,         },         return dialogsheet.getSheetFormatPr();,     }, ,     protected CTPageMargins getSheetTypePageMargins() {,         if (dialogsheet.getPageMargins() == null) {,             dialogsheet.setPageMargins(CTPageMargins.Factory.newInstance());,         },         return dialogsheet.getPageMargins();,     }, ,     protected CTPageBreak getSheetTypeRowBreaks() {,         return null;,     }, ,     protected CTSheetViews getSheetTypeSheetViews() {,         if (dialogsheet.getSheetViews() == null) {,             dialogsheet.setSheetViews(CTSheetViews.Factory.newInstance());,             dialogsheet.getSheetViews().addNewSheetView();,         },         return dialogsheet.getSheetViews();,     }, ,     protected CTPrintOptions getSheetTypePrintOptions() {,         if (dialogsheet.getPrintOptions() == null) {,             dialogsheet.setPrintOptions(CTPrintOptions.Factory.newInstance());,         },         return dialogsheet.getPrintOptions();,     }, ,     protected CTSheetProtection getSheetTypeProtection() {,         if (dialogsheet.getSheetProtection() == null) {,             dialogsheet.setSheetProtection(CTSheetProtection.Factory.newInstance());,         },         return dialogsheet.getSheetProtection();,     }, ,     public boolean getDialog(){,         return true;],,
STYLE,REC_CATCH_EXCEPTION,org/apache/poi/xssf/usermodel/XSSFFactory.java,createDocumentPart,61-61,[        } catch (Exception e){],,
STYLE,SF_SWITCH_NO_DEFAULT,org/apache/poi/xssf/usermodel/XSSFFont.java,setTypeOffset,480-488,[            switch (offset) {,                 case Font.SS_NONE:,                     offsetProperty.setVal(STVerticalAlignRun.BASELINE);,                     break;,                 case Font.SS_SUB:,                     offsetProperty.setVal(STVerticalAlignRun.SUBSCRIPT);,                     break;,                 case Font.SS_SUPER:,                     offsetProperty.setVal(STVerticalAlignRun.SUPERSCRIPT);],,
MT_CORRECTNESS,LI_LAZY_INIT_STATIC,org/apache/poi/xssf/usermodel/XSSFGraphicFrame.java,prototype,66-86,[		if (prototype == null) {, 			CTGraphicalObjectFrame graphicFrame = CTGraphicalObjectFrame.Factory.newInstance();, , 			CTGraphicalObjectFrameNonVisual nvGraphic = graphicFrame.addNewNvGraphicFramePr();, 			CTNonVisualDrawingProps props = nvGraphic.addNewCNvPr();, 			props.setId(0);, 			props.setName("Diagramm 1");, 			nvGraphic.addNewCNvGraphicFramePr();, , 			CTTransform2D transform = graphicFrame.addNewXfrm();, 			CTPositiveSize2D extPoint = transform.addNewExt();, 			CTPoint2D offPoint = transform.addNewOff();, , 			extPoint.setCx(0);, 			extPoint.setCy(0);, 			offPoint.setX(0);, 			offPoint.setY(0);, , 			CTGraphicalObject graphic = graphicFrame.addNewGraphic();, , 			prototype = graphicFrame;],,
PERFORMANCE,URF_UNREAD_FIELD,org/apache/poi/xssf/usermodel/XSSFGraphicFrame.java,,53-53,[		this.drawing = drawing;],,
MT_CORRECTNESS,LI_LAZY_INIT_STATIC,org/apache/poi/xssf/usermodel/XSSFPicture.java,prototype,97-126,[        if(prototype == null) {,             CTPicture pic = CTPicture.Factory.newInstance();,             CTPictureNonVisual nvpr = pic.addNewNvPicPr();,             CTNonVisualDrawingProps nvProps = nvpr.addNewCNvPr();,             nvProps.setId(1);,             nvProps.setName("Picture 1");,             nvProps.setDescr("Picture");,             CTNonVisualPictureProperties nvPicProps = nvpr.addNewCNvPicPr();,             nvPicProps.addNewPicLocks().setNoChangeAspect(true);, ,             CTBlipFillProperties blip = pic.addNewBlipFill();,             blip.addNewBlip().setEmbed("");,             blip.addNewStretch().addNewFillRect();, ,             CTShapeProperties sppr = pic.addNewSpPr();,             CTTransform2D t2d = sppr.addNewXfrm();,             CTPositiveSize2D ext = t2d.addNewExt();,             //should be original picture width and height expressed in EMUs,             ext.setCx(0);,             ext.setCy(0);, ,             CTPoint2D off = t2d.addNewOff();,             off.setX(0);,             off.setY(0);, ,             CTPresetGeometry2D prstGeom = sppr.addNewPrstGeom();,             prstGeom.setPrst(STShapeType.RECT);,             prstGeom.addNewAvLst();, ,             prototype = pic;],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/poi/xssf/usermodel/XSSFPictureData.java,,42-42,[        RELATIONS = new POIXMLRelation[8];],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/poi/xssf/usermodel/XSSFRelation.java,,54-54,[    protected static Map<String, XSSFRelation> _table = new HashMap<String, XSSFRelation>();],,
PERFORMANCE,WMI_WRONG_MAP_ITERATOR,org/apache/poi/xssf/usermodel/XSSFRichTextString.java,buildCTRst,553-553,[            CTRPrElt fmt = formats.get(runEndIdx);],,
BAD_PRACTICE,EQ_COMPARETO_USE_OBJECT_EQUALS,org/apache/poi/xssf/usermodel/XSSFRow.java,compareTo,128-132,[        int thisVal = this.getRowNum();,         if(row.getSheet() != getSheet()) throw new IllegalArgumentException("The compared rows must belong to the same XSSFSheet");, ,         int anotherVal = row.getRowNum();,         return (thisVal < anotherVal ? -1 : (thisVal == anotherVal ? 0 : 1));],,
MT_CORRECTNESS,LI_LAZY_INIT_STATIC,org/apache/poi/xssf/usermodel/XSSFShapeGroup.java,prototype,62-85,[        if (prototype == null) {,             CTGroupShape shape = CTGroupShape.Factory.newInstance();, ,             CTGroupShapeNonVisual nv = shape.addNewNvGrpSpPr();,             CTNonVisualDrawingProps nvpr = nv.addNewCNvPr();,             nvpr.setId(0);,             nvpr.setName("Group 0");,             nv.addNewCNvGrpSpPr();,             CTGroupShapeProperties sp = shape.addNewGrpSpPr();,             CTGroupTransform2D t2d = sp.addNewXfrm();,             CTPositiveSize2D p1 = t2d.addNewExt();,             p1.setCx(0);,             p1.setCy(0);,             CTPoint2D p2 = t2d.addNewOff();,             p2.setX(0);,             p2.setY(0);,             CTPositiveSize2D p3 = t2d.addNewChExt();,             p3.setCx(0);,             p3.setCy(0);,             CTPoint2D p4 = t2d.addNewChOff();,             p4.setX(0);,             p4.setY(0);, ,             prototype = shape;],,
MT_CORRECTNESS,LI_LAZY_INIT_STATIC,org/apache/poi/xssf/usermodel/XSSFSimpleShape.java,prototype,56-108,[        if(prototype == null) {,             CTShape shape = CTShape.Factory.newInstance();, ,             CTShapeNonVisual nv = shape.addNewNvSpPr();,             CTNonVisualDrawingProps nvp = nv.addNewCNvPr();,             nvp.setId(1);,             nvp.setName("Shape 1");,             nv.addNewCNvSpPr();, ,             CTShapeProperties sp = shape.addNewSpPr();,             CTTransform2D t2d = sp.addNewXfrm();,             CTPositiveSize2D p1 = t2d.addNewExt();,             p1.setCx(0);,             p1.setCy(0);,             CTPoint2D p2 = t2d.addNewOff();,             p2.setX(0);,             p2.setY(0);, ,             CTPresetGeometry2D geom = sp.addNewPrstGeom();,             geom.setPrst(STShapeType.RECT);,             geom.addNewAvLst();, ,             CTShapeStyle style = shape.addNewStyle();,             CTSchemeColor scheme = style.addNewLnRef().addNewSchemeClr();,             scheme.setVal(STSchemeColorVal.ACCENT_1);,             scheme.addNewShade().setVal(50000);,             style.getLnRef().setIdx(2);, ,             CTStyleMatrixReference fillref = style.addNewFillRef();,             fillref.setIdx(1);,             fillref.addNewSchemeClr().setVal(STSchemeColorVal.ACCENT_1);, ,             CTStyleMatrixReference effectRef = style.addNewEffectRef();,             effectRef.setIdx(0);,             effectRef.addNewSchemeClr().setVal(STSchemeColorVal.ACCENT_1);, ,             CTFontReference fontRef = style.addNewFontRef();,             fontRef.setIdx(STFontCollectionIndex.MINOR);,             fontRef.addNewSchemeClr().setVal(STSchemeColorVal.LT_1);, ,             CTTextBody body = shape.addNewTxBody();,             CTTextBodyProperties bodypr = body.addNewBodyPr();,             bodypr.setAnchor(STTextAnchoringType.CTR);,             bodypr.setRtlCol(false);,             CTTextParagraph p = body.addNewP();,             p.addNewPPr().setAlgn(STTextAlignType.CTR);,             CTTextCharacterProperties endPr = p.addNewEndParaRPr();,             endPr.setLang("en-US");,             endPr.setSz(1100);, ,             body.addNewLstStyle();, ,             prototype = shape;],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/poi/xssf/usermodel/XSSFTable.java,getStartCellReference,273-273,[		if (from!=null && to!=null){],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/poi/xssf/usermodel/XSSFTable.java,getEndCellReference,273-273,[		if (from!=null && to!=null){],,
CORRECTNESS,NP_NULL_PARAM_DEREF,org/apache/poi/xssf/usermodel/XSSFWorkbook.java,containsSheet,1239-1239,[        if (containsSheet(sheetname, sheetIndex ))],,containsSheet,1236-1236,[        if(sheetname != null && sheetname.length() > 31) sheetname = sheetname.substring(0, 31);],,
STYLE,FE_FLOATING_POINT_EQUALITY,org/apache/poi/xssf/usermodel/charts/TestXSSFManualLayout.java,testAccessorMethods,45-45,[		assertTrue(layout.getWidthRatio() == newRatio);],,testAccessorMethods,48-48,[		assertTrue(layout.getHeightRatio() == newRatio);],,testAccessorMethods,51-51,[		assertTrue(layout.getX() == newCoordinate);],,testAccessorMethods,54-54,[		assertTrue(layout.getY() == newCoordinate);],,
MT_CORRECTNESS,LI_LAZY_INIT_STATIC,org/apache/poi/xssf/usermodel/charts/XSSFChartDataFactory.java,getInstance,46-47,[		if (instance == null) {, 			instance = new XSSFChartDataFactory();],,
BAD_PRACTICE,OS_OPEN_STREAM,org/apache/poi/xssf/usermodel/examples/BigGridDemo.java,substitute,168-168,[        ZipFile zip = new ZipFile(zipfile);],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/poi/xssf/usermodel/examples/Outlining.java,collapseExpandRowColumn,71-71,[	FileOutputStream fileOut = new FileOutputStream("outlining_collapsed.xlsx");],,collapseExpandRowColumn,72-72,[	wb2.write(fileOut);],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/poi/xssf/usermodel/examples/Outlining.java,groupRowColumn,47-47,[	FileOutputStream fileOut = new FileOutputStream("outlining.xlsx");],,groupRowColumn,48-48,[	wb.write(fileOut);],,
STYLE,BC_VACUOUS_INSTANCEOF,org/apache/poi/xssf/usermodel/examples/WorkingWithPictures.java,main,64-64,[        if(wb instanceof XSSFWorkbook) file += "x";],,
BAD_PRACTICE,NM_CONFUSING,org/apache/poi/xssf/usermodel/helpers/XSSFSingleXmlCell.java,getXpath,75-78,[		CTXmlCellPr xmlCellPr = singleXmlCell.getXmlCellPr();, 		CTXmlPr xmlPr = xmlCellPr.getXmlPr();, 		String xpath = xmlPr.getXpath();, 		return xpath;],,getXPath,51-51,[		return ctXmlColumnPr.getXpath();],,
PERFORMANCE,SBSC_USE_STRINGBUFFER_CONCATENATION,org/apache/poi/xssf/usermodel/helpers/XSSFXmlColumnPr.java,getLocalXPath,73-73,[			localXPath += "/" +xPathTokens[i];],,
BAD_PRACTICE,SE_COMPARATOR_SHOULD_BE_SERIALIZABLE,org/apache/poi/xssf/util/CTColComparator.java,,24-40,[public class CTColComparator implements Comparator<CTCol>{, ,     public int compare(CTCol o1, CTCol o2) {,         if (o1.getMin() < o2.getMin()) {,             return -1;,         },         else if (o1.getMin() > o2.getMin()) {,             return 1;,         },         else {,             if (o1.getMax() < o2.getMax()) {,                 return -1;,             },             if (o1.getMax() > o2.getMax()) {,                 return 1;,             },             return 0;],,
STYLE,UC_USELESS_OBJECT,org/apache/poi/xssf/util/MemoryUsage.java,testXmlAttached,163-163,[        List<CTRow> rows = new ArrayList<CTRow>();],,
STYLE,UC_USELESS_OBJECT,org/apache/poi/xssf/util/MemoryUsage.java,testXmlDetached,141-141,[        List<CTRow> rows = new ArrayList<CTRow>();],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/poi/xssf/util/NumericRanges.java,,22-22,[    public static int NO_OVERLAPS = -1;],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/poi/xssf/util/NumericRanges.java,,23-23,[    public static int OVERLAPS_1_MINOR = 0;],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/poi/xssf/util/NumericRanges.java,,25-25,[    public static int OVERLAPS_1_WRAPS = 2;],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/poi/xssf/util/NumericRanges.java,,24-24,[    public static int OVERLAPS_2_MINOR = 1;],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/poi/xssf/util/NumericRanges.java,,26-26,[    public static int OVERLAPS_2_WRAPS = 3;],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/poi/xwpf/TestDocumentProtection.java,testIntegration,128-128,[        FileOutputStream out = new FileOutputStream(tempFile);],,testIntegration,130-130,[        doc.write(out);],,
MALICIOUS_CODE,MS_MUTABLE_ARRAY,org/apache/poi/xwpf/extractor/XWPFWordExtractor.java,,43-43,[   public static final XWPFRelation[] SUPPORTED_TYPES = new XWPFRelation[] {],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/poi/xwpf/extractor/XWPFWordExtractor.java,getText,123-123,[			   if(footnameText != null && footnameText.length() > 0) {],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/poi/xwpf/model/TestXWPFDecorators.java,testComments,92-92,[      for(XWPFParagraph p : comments.getParagraphs()) {],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/poi/xwpf/model/TestXWPFDecorators.java,testHyperlink,47-47,[      assertEquals(5, hyperlink.getParagraphs().size());],,
STYLE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,org/apache/poi/xwpf/model/TestXWPFDecorators.java,testHyperlink,46-46,[      assertEquals(7, simple.getParagraphs().size());],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/poi/xwpf/model/XWPFHeaderFooterPolicy.java,buildHdrFtr,229-246,[        CTHdrFtr ftr = CTHdrFtr.Factory.newInstance();,         if (paragraphs != null) {,             for (int i = 0 ; i < paragraphs.length ; i++) {,                 CTP p = ftr.addNewP();,                 //ftr.setPArray(0, paragraphs[i].getCTP());		// MB 23 May 2010,                 ftr.setPArray(i, paragraphs[i].getCTP());   	// MB 23 May 2010,             },         },         else {,             CTP p = ftr.addNewP();,             byte[] rsidr = doc.getDocument().getBody().getPArray(0).getRsidR();,             byte[] rsidrdefault = doc.getDocument().getBody().getPArray(0).getRsidRDefault();,             p.setRsidP(rsidr);,             p.setRsidRDefault(rsidrdefault);,             CTPPr pPr = p.addNewPPr();,             pPr.addNewPStyle().setVal(pStyle);,         },         return ftr;],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/poi/xwpf/usermodel/BreakClear.java,<clinit>,99-99,[          imap.put(new Integer(p.getValue()), p);],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/poi/xwpf/usermodel/BreakClear.java,valueOf,104-104,[       BreakClear bType = imap.get(new Integer(type));],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/poi/xwpf/usermodel/BreakType.java,<clinit>,72-72,[          imap.put(new Integer(p.getValue()), p);],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/poi/xwpf/usermodel/BreakType.java,valueOf,77-77,[       BreakType bType = imap.get(new Integer(type));],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/poi/xwpf/usermodel/LineSpacingRule.java,<clinit>,65-65,[          imap.put(new Integer(p.getValue()), p);],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/poi/xwpf/usermodel/LineSpacingRule.java,valueOf,70-70,[       LineSpacingRule lineType = imap.get(new Integer(type));],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/poi/xwpf/usermodel/ParagraphAlignment.java,<clinit>,56-56,[            imap.put(new Integer(p.getValue()), p);],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/poi/xwpf/usermodel/ParagraphAlignment.java,valueOf,61-61,[        ParagraphAlignment err = imap.get(new Integer(type));],,
STYLE,DB_DUPLICATE_BRANCHES,org/apache/poi/xwpf/usermodel/SimpleTable.java,createStyledTable,179-180,[                    rh.setText("row " + rowCt + ", col " + colCt);,                     para.setAlignment(ParagraphAlignment.LEFT);],,createStyledTable,184-185,[                    rh.setText("row " + rowCt + ", col " + colCt);,                     para.setAlignment(ParagraphAlignment.LEFT);],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/poi/xwpf/usermodel/SimpleTable.java,createSimpleTable,86-86,[        FileOutputStream out = new FileOutputStream("simpleTable.docx");],,createSimpleTable,87-87,[        doc.write(out);],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE,org/apache/poi/xwpf/usermodel/SimpleTable.java,createStyledTable,194-194,[        FileOutputStream out = new FileOutputStream("styledTable.docx");],,createStyledTable,195-195,[        doc.write(out);],,
PERFORMANCE,DM_BOXED_PRIMITIVE_TOSTRING,org/apache/poi/xwpf/usermodel/TOC.java,addRow,117-117,[		run.addNewT().setStringValue(Integer.valueOf(page).toString());],,
I18N,DM_DEFAULT_ENCODING,org/apache/poi/xwpf/usermodel/TOC.java,<init>,70-70,[		p.setRsidR("00EF7E24".getBytes());],,<init>,71-71,[		p.setRsidRDefault("00EF7E24".getBytes());],,
I18N,DM_DEFAULT_ENCODING,org/apache/poi/xwpf/usermodel/TOC.java,addRow,84-84,[		p.setRsidR("00EF7E24".getBytes());],,addRow,85-85,[		p.setRsidRDefault("00EF7E24".getBytes());],,
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,org/apache/poi/xwpf/usermodel/TestXWPFPictureData.java,process,153-153,[    }],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/poi/xwpf/usermodel/TextAlignment.java,<clinit>,68-68,[          imap.put(new Integer(p.getValue()), p);],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/poi/xwpf/usermodel/TextAlignment.java,valueOf,73-73,[       TextAlignment align = imap.get(new Integer(type));],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/poi/xwpf/usermodel/UnderlinePatterns.java,<clinit>,151-151,[          imap.put(new Integer(p.getValue()), p);],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/poi/xwpf/usermodel/UnderlinePatterns.java,valueOf,156-156,[       UnderlinePatterns align = imap.get(new Integer(type));],,
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION,org/apache/poi/xwpf/usermodel/UpdateEmbeddedDoc.java,updateEmbeddedDoc,150-150,[            this.doc.write(new FileOutputStream(this.docFile));],,updateEmbeddedDoc,152-152,[    }],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/poi/xwpf/usermodel/UpdateEmbeddedDoc.java,checkUpdatedDoc,187-187,[        if (embeddedDocs != null && !embeddedDocs.isEmpty()) {],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/poi/xwpf/usermodel/UpdateEmbeddedDoc.java,updateEmbeddedDoc,129-129,[        if (embeddedDocs != null && !embeddedDocs.isEmpty()) {],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/poi/xwpf/usermodel/VerticalAlign.java,<clinit>,63-63,[          imap.put(new Integer(p.getValue()), p);],,
PERFORMANCE,DM_NUMBER_CTOR,org/apache/poi/xwpf/usermodel/VerticalAlign.java,valueOf,68-68,[       VerticalAlign align = imap.get(new Integer(type));],,
PERFORMANCE,DM_BOXED_PRIMITIVE_FOR_PARSING,org/apache/poi/xwpf/usermodel/XWPFDocument.java,createTOC,867-867,[                    int level = Integer.valueOf(parStyle.substring("Heading".length())).intValue();],,
BAD_PRACTICE,NM_CONFUSING,org/apache/poi/xwpf/usermodel/XWPFDocument.java,getFootnoteByID,354-355,[       if(footnotes == null) return null;,        return footnotes.getFootnoteById(id);],,getFootnoteById,108-112,[		for(XWPFFootnote note : listFootnote) {, 			if(note.getCTFtnEdn().getId().intValue() == id), 				return note;, 		}, 		return null;],,
CORRECTNESS,NP_NULL_ON_SOME_PATH_EXCEPTION,org/apache/poi/xwpf/usermodel/XWPFDocument.java,addPictureData,1116-1116,[                    out.close();],,addPictureData,1108-1108,[            OutputStream out = null;],,addPictureData,1110-1110,[                out = picDataPart.getOutputStream();],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/poi/xwpf/usermodel/XWPFDocument.java,getTableCell,1305-1305,[		if(row == null){],,
STYLE,REC_CATCH_EXCEPTION,org/apache/poi/xwpf/usermodel/XWPFFactory.java,createDocumentPart,65-65,[        } catch (Exception e){],,
STYLE,REC_CATCH_EXCEPTION,org/apache/poi/xwpf/usermodel/XWPFFooter.java,onDocumentRead,123-123,[        } catch (Exception e) {],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/poi/xwpf/usermodel/XWPFFootnote.java,getTableCell,183-183,[        if(row == null){],,
CORRECTNESS,NP_NULL_ON_SOME_PATH_EXCEPTION,org/apache/poi/xwpf/usermodel/XWPFHeaderFooter.java,addPictureData,255-255,[                    out.close();],,addPictureData,247-247,[            OutputStream out = null;],,addPictureData,249-249,[                out = picDataPart.getOutputStream();],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/poi/xwpf/usermodel/XWPFHeaderFooter.java,getTableCell,495-495,[        if(row == null){],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/poi/xwpf/usermodel/XWPFHeaderFooter.java,getText,136-136,[                if(text != null && text.length() > 0) {],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/poi/xwpf/usermodel/XWPFHeaderFooter.java,getText,146-146,[            if(text != null && text.length() > 0) {],,
STYLE,UCF_USELESS_CONTROL_FLOW_NEXT_LINE,org/apache/poi/xwpf/usermodel/XWPFLatentStyles.java,isLatentStyle,43-43,[			if(lsd.getName().equals(latentStyleID));],,
STYLE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,org/apache/poi/xwpf/usermodel/XWPFLatentStyles.java,,35-35,[		this.styles=styles;],,
BAD_PRACTICE,NM_CONFUSING,org/apache/poi/xwpf/usermodel/XWPFParagraph.java,getNumID,210-216,[        if(paragraph.getPPr()!=null){,             if(paragraph.getPPr().getNumPr()!=null){,                 if(paragraph.getPPr().getNumPr().getNumId()!=null),                     return paragraph.getPPr().getNumPr().getNumId().getVal();,             },         },         return null;],,
BAD_PRACTICE,NM_CONFUSING,org/apache/poi/xwpf/usermodel/XWPFParagraph.java,setNumID,224-232,[        if(paragraph.getPPr()==null),             paragraph.addNewPPr();,         if(paragraph.getPPr().getNumPr()==null),             paragraph.getPPr().addNewNumPr();,         if(paragraph.getPPr().getNumPr().getNumId()==null){,             paragraph.getPPr().getNumPr().addNewNumId();,         },         paragraph.getPPr().getNumPr().getNumId().setVal(numPos);,     }],,
CORRECTNESS,NP_NULL_ON_SOME_PATH,org/apache/poi/xwpf/usermodel/XWPFParagraph.java,setBorderTop,401-401,[        CTBorder pr = (ct != null && ct.isSetTop()) ? ct.getTop() : ct.addNewTop();],,
MALICIOUS_CODE,MS_PKGPROTECT,org/apache/poi/xwpf/usermodel/XWPFPictureData.java,,47-47,[        RELATIONS = new POIXMLRelation[9];],,
CORRECTNESS,NP_NULL_ON_SOME_PATH_EXCEPTION,org/apache/poi/xwpf/usermodel/XWPFPictureData.java,getChecksum,159-159,[                    is.close();],,getChecksum,150-150,[            InputStream is = null;],,getChecksum,153-153,[                is = getPackagePart().getInputStream();],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/poi/xwpf/usermodel/XWPFPictureData.java,getFileName,110-110,[        if (name == null)],,
MALICIOUS_CODE,MS_SHOULD_BE_FINAL,org/apache/poi/xwpf/usermodel/XWPFRelation.java,,34-34,[    protected static Map<String, XWPFRelation> _table = new HashMap<String, XWPFRelation>();],,
STYLE,RV_RETURN_VALUE_IGNORED_NO_SIDE_EFFECT,org/apache/poi/xwpf/usermodel/XWPFTable.java,getRows,116-116,[		getRows();],,
STYLE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,org/apache/poi/xwpf/usermodel/XWPFTableCell.java,getTableCell,349-349,[		if(row == null){],,
